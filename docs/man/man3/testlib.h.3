.TH "src/testlib.h" 3 "competitive-contest" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/testlib.h
.SH SYNOPSIS
.br
.PP
\fR#include <stdlib\&.h>\fP
.br
\fR#include <cstdlib>\fP
.br
\fR#include <climits>\fP
.br
\fR#include <algorithm>\fP
.br
\fR#include <cstdio>\fP
.br
\fR#include <cctype>\fP
.br
\fR#include <string>\fP
.br
\fR#include <vector>\fP
.br
\fR#include <map>\fP
.br
\fR#include <set>\fP
.br
\fR#include <cmath>\fP
.br
\fR#include <iterator>\fP
.br
\fR#include <iostream>\fP
.br
\fR#include <sstream>\fP
.br
\fR#include <fstream>\fP
.br
\fR#include <cstring>\fP
.br
\fR#include <limits>\fP
.br
\fR#include <stdarg\&.h>\fP
.br
\fR#include <fcntl\&.h>\fP
.br
\fR#include <functional>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <unistd\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBpattern\fP"
.br
.ti -1c
.RI "class \fBrandom_t\fP"
.br
.ti -1c
.RI "class \fBInputStreamReader\fP"
.br
.ti -1c
.RI "class \fBStringInputStreamReader\fP"
.br
.ti -1c
.RI "class \fBFileInputStreamReader\fP"
.br
.ti -1c
.RI "class \fBBufferedFileInputStreamReader\fP"
.br
.ti -1c
.RI "struct \fBInStream\fP"
.br
.ti -1c
.RI "struct \fBValidatorBoundsHit\fP"
.br
.ti -1c
.RI "struct \fBConstantBound\fP"
.br
.ti -1c
.RI "struct \fBConstantBounds\fP"
.br
.ti -1c
.RI "class \fBValidator\fP"
.br
.ti -1c
.RI "struct \fBTestlibFinalizeGuard\fP"
.br
.ti -1c
.RI "class \fBChecker\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBVERSION\fP   '0\&.9\&.42\-SNAPSHOT'"
.br
.ti -1c
.RI "#define \fBrandom\fP   __random_deprecated"
.br
.ti -1c
.RI "#define \fBWORD\fP   unsigned short"
.br
.ti -1c
.RI "#define \fBLLONG_MIN\fP   (\-9223372036854775807LL \- 1)"
.br
.ti -1c
.RI "#define \fBULLONG_MAX\fP   (18446744073709551615)"
.br
.ti -1c
.RI "#define \fBLF\fP   ((char)10)"
.br
.ti -1c
.RI "#define \fBCR\fP   ((char)13)"
.br
.ti -1c
.RI "#define \fBTAB\fP   ((char)9)"
.br
.ti -1c
.RI "#define \fBSPACE\fP   ((char)' ')"
.br
.ti -1c
.RI "#define \fBEOFC\fP   (255)"
.br
.ti -1c
.RI "#define \fBOK_EXIT_CODE\fP   0"
.br
.ti -1c
.RI "#define \fBWA_EXIT_CODE\fP   1"
.br
.ti -1c
.RI "#define \fBPE_EXIT_CODE\fP   2"
.br
.ti -1c
.RI "#define \fBFAIL_EXIT_CODE\fP   3"
.br
.ti -1c
.RI "#define \fBDIRT_EXIT_CODE\fP   4"
.br
.ti -1c
.RI "#define \fBPOINTS_EXIT_CODE\fP   7"
.br
.ti -1c
.RI "#define \fBUNEXPECTED_EOF_EXIT_CODE\fP   8"
.br
.ti -1c
.RI "#define \fBPC_BASE_EXIT_CODE\fP   0"
.br
.ti -1c
.RI "#define \fB__TESTLIB_STATIC_ASSERT\fP(condition)   typedef void* __testlib_static_assert_type[(condition) ? 1 : \-1]"
.br
.ti -1c
.RI "#define \fBI64\fP   '%lld'"
.br
.ti -1c
.RI "#define \fBU64\fP   '%llu'"
.br
.ti -1c
.RI "#define \fBNORETURN\fP"
.br
.ti -1c
.RI "#define \fBFMT_TO_RESULT\fP(fmt,  cstr,  result)"
.br
.ti -1c
.RI "#define \fB_pc\fP(exitCode)   (\fBTResult\fP(\fB_partially\fP + (exitCode)))"
.br
.ti -1c
.RI "#define \fB__testlib_readMany\fP(readMany,  readOne,  typeName,  space)"
.br
.ti -1c
.RI "#define \fBensure\fP(cond)   __testlib_ensure(cond, 'Condition failed: \\'' #cond '\\'')"
.br
.ti -1c
.RI "#define \fBSTRINGIZE_DETAIL\fP(x)   #x"
.br
.ti -1c
.RI "#define \fBSTRINGIZE\fP(x)   \fBSTRINGIZE_DETAIL\fP(x)"
.br
.ti -1c
.RI "#define \fBensure_ext\fP(cond)   __testlib_ensure(cond, 'Line ' STRINGIZE(__LINE__) ': Condition failed: \\'' #cond '\\'')"
.br
.ti -1c
.RI "#define \fBRAND_THROW_STATEMENT\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBTMode\fP { \fB_input\fP, \fB_output\fP, \fB_answer\fP }"
.br
.ti -1c
.RI "enum \fBTResult\fP { \fB_ok\fP = 0, \fB_wa\fP = 1, \fB_pe\fP = 2, \fB_fail\fP = 3, \fB_dirt\fP = 4, \fB_points\fP = 5, \fB_unexpected_eof\fP = 8, \fB_partially\fP = 16 }"
.br
.ti -1c
.RI "enum \fBTTestlibMode\fP { \fB_unknown\fP, \fB_checker\fP, \fB_validator\fP, \fB_generator\fP, \fB_interactor\fP, \fB_scorer\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBsetTestCase\fP (int testCase)"
.br
.ti -1c
.RI "void \fBunsetTestCase\fP ()"
.br
.ti -1c
.RI "std::string \fBupperCase\fP (std::string s)"
.br
.ti -1c
.RI "std::string \fBlowerCase\fP (std::string s)"
.br
.ti -1c
.RI "std::string \fBformat\fP (const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "std::string \fBformat\fP (const std::string fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "bool \fBdoubleCompare\fP (double expected, double result, double MAX_DOUBLE_ERROR)"
.br
.ti -1c
.RI "double \fBdoubleDelta\fP (double expected, double result)"
.br
.ti -1c
.RI "template<typename C > bool \fBisEof\fP (C c)"
.br
.ti -1c
.RI "template<typename C > bool \fBisEoln\fP (C c)"
.br
.ti -1c
.RI "template<typename C > bool \fBisBlanks\fP (C c)"
.br
.ti -1c
.RI "std::string \fBtrim\fP (const std::string &s)"
.br
.ti -1c
.RI "void \fBdisableFinalizeGuard\fP ()"
.br
.ti -1c
.RI "int \fBresultExitCode\fP (\fBTResult\fP r)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBhalt\fP (int exitCode)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquit\fP (\fBTResult\fP result, const std::string &msg)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquit\fP (\fBTResult\fP result, const char *msg)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fB__testlib_quitp\fP (double points, const char *message)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fB__testlib_quitp\fP (int points, const char *message)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitp\fP (float points, const std::string &message='')"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitp\fP (double points, const std::string &message='')"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitp\fP (long double points, const std::string &message='')"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitp\fP (int points, const std::string &message='')"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitpi\fP (const std::string &points_info, const std::string &message='')"
.br
.ti -1c
.RI "template<typename F > \fBNORETURN\fP void \fBquitp\fP (F points, const char *\fBformat\fP,\&.\&.\&.)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fBquitf\fP (\fBTResult\fP result, const char *\fBformat\fP,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBquitif\fP (bool condition, \fBTResult\fP result, const char *\fBformat\fP,\&.\&.\&.)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fB__testlib_help\fP ()"
.br
.ti -1c
.RI "std::string \fBgetTestset\fP ()"
.br
.ti -1c
.RI "std::string \fBgetGroup\fP ()"
.br
.ti -1c
.RI "void \fBregisterGen\fP (int argc, char *argv[], int randomGeneratorVersion)"
.br
.ti -1c
.RI "void \fBregisterGen\fP (int argc, char *argv[])"
.br
.ti -1c
.RI "void \fBsetAppesModeEncoding\fP (std::string \fBappesModeEncoding\fP)"
.br
.ti -1c
.RI "void \fBregisterInteraction\fP (int argc, char *argv[])"
.br
.ti -1c
.RI "void \fBregisterValidation\fP ()"
.br
.ti -1c
.RI "void \fBregisterValidation\fP (int argc, char *argv[])"
.br
.ti -1c
.RI "void \fBaddFeature\fP (const std::string &\fBfeature\fP)"
.br
.ti -1c
.RI "void \fBfeature\fP (const std::string &feature)"
.br
.ti -1c
.RI "void \fBregisterTestlibCmd\fP (int argc, char *argv[])"
.br
.ti -1c
.RI "void \fBregisterTestlib\fP (int argc,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBensuref\fP (bool cond, const char *\fBformat\fP,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBsetName\fP (const char *\fBformat\fP,\&.\&.\&.)"
.br
.ti -1c
.RI "template<typename _RandomAccessIter > void \fBshuffle\fP (_RandomAccessIter __first, _RandomAccessIter __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIter > void \fBrandom_shuffle\fP (_RandomAccessIter, _RandomAccessIter)"
.br
.ti -1c
.RI "int \fBrand\fP () \fBRAND_THROW_STATEMENT\fP"
.br
.ti -1c
.RI "void \fBsrand\fP (unsigned int seed) \fBRAND_THROW_STATEMENT\fP"
.br
.ti -1c
.RI "void \fBstartTest\fP (int test)"
.br
.ti -1c
.RI "std::string \fBcompress\fP (const std::string &s)"
.br
.ti -1c
.RI "std::string \fBenglishEnding\fP (int x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Separator > std::string \fBjoin\fP (_ForwardIterator first, _ForwardIterator last, _Separator separator)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > std::string \fBjoin\fP (_ForwardIterator first, _ForwardIterator last)"
.br
.ti -1c
.RI "template<typename _Collection , typename _Separator > std::string \fBjoin\fP (const _Collection &collection, _Separator separator)"
.br
.ti -1c
.RI "template<typename _Collection > std::string \fBjoin\fP (const _Collection &collection)"
.br
.ti -1c
.RI "std::vector< std::string > \fBsplit\fP (const std::string &s, char separator)"
.br
.ti -1c
.RI "std::vector< std::string > \fBsplit\fP (const std::string &s, const std::string &separators)"
.br
.ti -1c
.RI "std::vector< std::string > \fBtokenize\fP (const std::string &s, char separator)"
.br
.ti -1c
.RI "std::vector< std::string > \fBtokenize\fP (const std::string &s, const std::string &separators)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fB__testlib_expectedButFound\fP (\fBTResult\fP result, std::string expected, std::string found, const char *prepend)"
.br
.ti -1c
.RI "\fBNORETURN\fP void \fB__testlib_expectedButFound\fP (\fBTResult\fP result, double expected, double found, const char *prepend)"
.br
.ti -1c
.RI "template<typename T > \fBNORETURN\fP void \fBexpectedButFound\fP (\fBTResult\fP result, T expected, T found, const char *prependFormat='',\&.\&.\&.)"
.br
.ti -1c
.RI "template<> \fBNORETURN\fP void \fBexpectedButFound< std::string >\fP (\fBTResult\fP result, std::string expected, std::string found, const char *prependFormat,\&.\&.\&.)"
.br
.ti -1c
.RI "template<> \fBNORETURN\fP void \fBexpectedButFound< double >\fP (\fBTResult\fP result, double expected, double found, const char *prependFormat,\&.\&.\&.)"
.br
.ti -1c
.RI "template<> \fBNORETURN\fP void \fBexpectedButFound< const char * >\fP (\fBTResult\fP result, const char *expected, const char *found, const char *prependFormat,\&.\&.\&.)"
.br
.ti -1c
.RI "template<> \fBNORETURN\fP void \fBexpectedButFound< float >\fP (\fBTResult\fP result, float expected, float found, const char *prependFormat,\&.\&.\&.)"
.br
.ti -1c
.RI "template<> \fBNORETURN\fP void \fBexpectedButFound< long double >\fP (\fBTResult\fP result, long double expected, long double found, const char *prependFormat,\&.\&.\&.)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char * \fBlatestFeatures\fP []"
.br
.ti -1c
.RI "const long long \fB__TESTLIB_LONGLONG_MAX\fP = 9223372036854775807LL"
.br
.ti -1c
.RI "const int \fB__TESTLIB_MAX_TEST_CASE\fP = 1073741823"
.br
.ti -1c
.RI "int \fB__testlib_exitCode\fP"
.br
.ti -1c
.RI "bool \fB__testlib_hasTestCase\fP"
.br
.ti -1c
.RI "int \fB__testlib_testCase\fP = \-1"
.br
.ti -1c
.RI "const std::string \fBoutcomes\fP []"
.br
.ti -1c
.RI "\fBInStream\fP \fBinf\fP"
.br
.ti -1c
.RI "\fBInStream\fP \fBouf\fP"
.br
.ti -1c
.RI "\fBInStream\fP \fBans\fP"
.br
.ti -1c
.RI "bool \fBappesMode\fP"
.br
.ti -1c
.RI "std::string \fBappesModeEncoding\fP = 'windows\-1251'"
.br
.ti -1c
.RI "std::string \fBresultName\fP"
.br
.ti -1c
.RI "std::string \fBcheckerName\fP = 'untitled checker'"
.br
.ti -1c
.RI "\fBrandom_t\fP \fBrnd\fP"
.br
.ti -1c
.RI "\fBTTestlibMode\fP \fBtestlibMode\fP = \fB_unknown\fP"
.br
.ti -1c
.RI "double \fB__testlib_points\fP = std::numeric_limits<float>::infinity()"
.br
.ti -1c
.RI "const size_t \fBVALIDATOR_MAX_VARIABLE_COUNT\fP = 255"
.br
.ti -1c
.RI "class \fBValidator\fP \fBvalidator\fP"
.br
.ti -1c
.RI "\fBTestlibFinalizeGuard\fP \fBtestlibFinalizeGuard\fP"
.br
.ti -1c
.RI "std::fstream \fBtout\fP"
.br
.ti -1c
.RI "std::string \fB__testlib_testset\fP"
.br
.ti -1c
.RI "std::string \fB__testlib_group\fP"
.br
.ti -1c
.RI "class \fBChecker\fP \fBchecker\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __testlib_readMany(readMany, readOne, typeName, space)"
\fBValue:\fP.PP
.nf
    if (size < 0)                                                               \\
        quit(_fail, #readMany ": size should be non\-negative\&.");                \\
    if (size > 100000000)                                                       \\
        quit(_fail, #readMany ": size should be at most 100000000\&.");           \\
                                                                                \\
    std::vector<typeName> result(size);                                         \\
    readManyIteration = indexBase;                                              \\
                                                                                \\
    for (int i = 0; i < size; i++)                                              \\
    {                                                                           \\
        result[i] = readOne;                                                    \\
        readManyIteration++;                                                    \\
        if (strict && space && i + 1 < size)                                              \\
            readSpace();                                                        \\
    }                                                                           \\
                                                                                \\
    readManyIteration = NO_INDEX;                                               \\
    return result;                                                              \\
.fi

.PP
Definition at line \fB3436\fP of file \fBtestlib\&.h\fP\&.
.SS "#define __TESTLIB_STATIC_ASSERT(condition)   typedef void* __testlib_static_assert_type[(condition) ? 1 : \-1]"

.PP
Definition at line \fB299\fP of file \fBtestlib\&.h\fP\&.
.SS "#define _pc(exitCode)   (\fBTResult\fP(\fB_partially\fP + (exitCode)))"

.PP
Definition at line \fB1636\fP of file \fBtestlib\&.h\fP\&.
.SS "#define CR   ((char)13)"

.PP
Definition at line \fB229\fP of file \fBtestlib\&.h\fP\&.
.SS "#define DIRT_EXIT_CODE   4"

.PP
Definition at line \fB276\fP of file \fBtestlib\&.h\fP\&.
.SS "#define ensure(cond)   __testlib_ensure(cond, 'Condition failed: \\'' #cond '\\'')"

.PP
Definition at line \fB4908\fP of file \fBtestlib\&.h\fP\&.
.SS "#define ensure_ext(cond)   __testlib_ensure(cond, 'Line ' STRINGIZE(__LINE__) ': Condition failed: \\'' #cond '\\'')"

.PP
Definition at line \fB4911\fP of file \fBtestlib\&.h\fP\&.
.SS "#define EOFC   (255)"

.PP
Definition at line \fB232\fP of file \fBtestlib\&.h\fP\&.
.SS "#define FAIL_EXIT_CODE   3"

.PP
Definition at line \fB268\fP of file \fBtestlib\&.h\fP\&.
.SS "#define FMT_TO_RESULT(fmt, cstr, result)"
\fBValue:\fP.PP
.nf
            std::string result;                              \\
            if (__testlib_format_buffer_usage_count != 0)                                  \\
                __testlib_fail("FMT_TO_RESULT::__testlib_format_buffer_usage_count != 0"); \\
            __testlib_format_buffer_usage_count++;                                         \\
            va_list ap;                                                                    \\
            va_start(ap, fmt);                                                             \\
            vsnprintf(__testlib_format_buffer, sizeof(__testlib_format_buffer), cstr, ap); \\
            va_end(ap);                                                                    \\
            __testlib_format_buffer[sizeof(__testlib_format_buffer) \- 1] = 0;              \\
            result = std::string(__testlib_format_buffer);                                 \\
            __testlib_format_buffer_usage_count\-\-;                                         \\
.fi

.PP
Definition at line \fB321\fP of file \fBtestlib\&.h\fP\&.
.SS "#define I64   '%lld'"

.PP
Definition at line \fB306\fP of file \fBtestlib\&.h\fP\&.
.SS "#define LF   ((char)10)"

.PP
Definition at line \fB228\fP of file \fBtestlib\&.h\fP\&.
.SS "#define LLONG_MIN   (\-9223372036854775807LL \- 1)"

.PP
Definition at line \fB221\fP of file \fBtestlib\&.h\fP\&.
.SS "#define NORETURN"

.PP
Definition at line \fB315\fP of file \fBtestlib\&.h\fP\&.
.SS "#define OK_EXIT_CODE   0"

.PP
Definition at line \fB238\fP of file \fBtestlib\&.h\fP\&.
.SS "#define PC_BASE_EXIT_CODE   0"

.PP
Definition at line \fB292\fP of file \fBtestlib\&.h\fP\&.
.SS "#define PE_EXIT_CODE   2"

.PP
Definition at line \fB258\fP of file \fBtestlib\&.h\fP\&.
.SS "#define POINTS_EXIT_CODE   7"

.PP
Definition at line \fB281\fP of file \fBtestlib\&.h\fP\&.
.SS "#define RAND_THROW_STATEMENT"

.PP
Definition at line \fB4961\fP of file \fBtestlib\&.h\fP\&.
.SS "#define random   __random_deprecated"

.PP
Definition at line \fB167\fP of file \fBtestlib\&.h\fP\&.
.SS "#define SPACE   ((char)' ')"

.PP
Definition at line \fB231\fP of file \fBtestlib\&.h\fP\&.
.SS "#define STRINGIZE(x)   \fBSTRINGIZE_DETAIL\fP(x)"

.PP
Definition at line \fB4910\fP of file \fBtestlib\&.h\fP\&.
.SS "#define STRINGIZE_DETAIL(x)   #x"

.PP
Definition at line \fB4909\fP of file \fBtestlib\&.h\fP\&.
.SS "#define TAB   ((char)9)"

.PP
Definition at line \fB230\fP of file \fBtestlib\&.h\fP\&.
.SS "#define U64   '%llu'"

.PP
Definition at line \fB307\fP of file \fBtestlib\&.h\fP\&.
.SS "#define ULLONG_MAX   (18446744073709551615)"

.PP
Definition at line \fB225\fP of file \fBtestlib\&.h\fP\&.
.SS "#define UNEXPECTED_EOF_EXIT_CODE   8"

.PP
Definition at line \fB285\fP of file \fBtestlib\&.h\fP\&.
.SS "#define VERSION   '0\&.9\&.42\-SNAPSHOT'"

.PP
Definition at line \fB28\fP of file \fBtestlib\&.h\fP\&.
.SS "#define WA_EXIT_CODE   1"

.PP
Definition at line \fB248\fP of file \fBtestlib\&.h\fP\&.
.SS "#define WORD   unsigned short"

.PP
Definition at line \fB212\fP of file \fBtestlib\&.h\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBTMode\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI_input \fP\fP
.TP
\fB\fI_output \fP\fP
.TP
\fB\fI_answer \fP\fP
.PP
Definition at line \fB1616\fP of file \fBtestlib\&.h\fP\&.
.SS "enum \fBTResult\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI_ok \fP\fP
.TP
\fB\fI_wa \fP\fP
.TP
\fB\fI_pe \fP\fP
.TP
\fB\fI_fail \fP\fP
.TP
\fB\fI_dirt \fP\fP
.TP
\fB\fI_points \fP\fP
.TP
\fB\fI_unexpected_eof \fP\fP
.TP
\fB\fI_partially \fP\fP
.PP
Definition at line \fB1621\fP of file \fBtestlib\&.h\fP\&.
.SS "enum \fBTTestlibMode\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI_unknown \fP\fP
.TP
\fB\fI_checker \fP\fP
.TP
\fB\fI_validator \fP\fP
.TP
\fB\fI_generator \fP\fP
.TP
\fB\fI_interactor \fP\fP
.TP
\fB\fI_scorer \fP\fP
.PP
Definition at line \fB1632\fP of file \fBtestlib\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBNORETURN\fP void __testlib_expectedButFound (\fBTResult\fP result, double expected, double found, const char * prepend)"

.PP
Definition at line \fB5176\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void __testlib_expectedButFound (\fBTResult\fP result, std::string expected, std::string found, const char * prepend)"

.PP
Definition at line \fB5165\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void __testlib_help ()"

.PP
Definition at line \fB4497\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void __testlib_quitp (double points, const char * message)"

.PP
Definition at line \fB4419\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void __testlib_quitp (int points, const char * message)"

.PP
Definition at line \fB4432\fP of file \fBtestlib\&.h\fP\&.
.SS "void addFeature (const std::string & feature)"

.PP
Definition at line \fB4765\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string compress (const std::string & s)\fR [inline]\fP"

.PP
Definition at line \fB5006\fP of file \fBtestlib\&.h\fP\&.
.SS "void disableFinalizeGuard ()"

.PP
Definition at line \fB2817\fP of file \fBtestlib\&.h\fP\&.
.SS "bool doubleCompare (double expected, double result, double MAX_DOUBLE_ERROR)\fR [inline]\fP"

.PP
Definition at line \fB482\fP of file \fBtestlib\&.h\fP\&.
.SS "double doubleDelta (double expected, double result)\fR [inline]\fP"

.PP
Definition at line \fB508\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string englishEnding (int x)\fR [inline]\fP"

.PP
Definition at line \fB5013\fP of file \fBtestlib\&.h\fP\&.
.SS "void ensuref (bool cond, const char * format,  \&.\&.\&.)\fR [inline]\fP"

.PP
Definition at line \fB4916\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename T > \fBNORETURN\fP void expectedButFound (\fBTResult\fP result, T expected, T found, const char * prependFormat = \fR''\fP,  \&.\&.\&.)"

.PP
Definition at line \fB5186\fP of file \fBtestlib\&.h\fP\&.
.SS "template<> \fBNORETURN\fP void \fBexpectedButFound\fP< const char * > (\fBTResult\fP result, const char * expected, const char * found, const char * prependFormat,  \&.\&.\&.)"

.PP
Definition at line \fB5218\fP of file \fBtestlib\&.h\fP\&.
.SS "template<> \fBNORETURN\fP void \fBexpectedButFound\fP< double > (\fBTResult\fP result, double expected, double found, const char * prependFormat,  \&.\&.\&.)"

.PP
Definition at line \fB5207\fP of file \fBtestlib\&.h\fP\&.
.SS "template<> \fBNORETURN\fP void \fBexpectedButFound\fP< float > (\fBTResult\fP result, float expected, float found, const char * prependFormat,  \&.\&.\&.)"

.PP
Definition at line \fB5229\fP of file \fBtestlib\&.h\fP\&.
.SS "template<> \fBNORETURN\fP void \fBexpectedButFound\fP< long double > (\fBTResult\fP result, long double expected, long double found, const char * prependFormat,  \&.\&.\&.)"

.PP
Definition at line \fB5238\fP of file \fBtestlib\&.h\fP\&.
.SS "template<> \fBNORETURN\fP void \fBexpectedButFound\fP< std::string > (\fBTResult\fP result, std::string expected, std::string found, const char * prependFormat,  \&.\&.\&.)"

.PP
Definition at line \fB5197\fP of file \fBtestlib\&.h\fP\&.
.SS "void feature (const std::string & feature)"

.PP
Definition at line \fB4771\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string format (const char * fmt,  \&.\&.\&.)"

.PP
Definition at line \fB436\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string format (const std::string fmt,  \&.\&.\&.)"

.PP
Definition at line \fB441\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string getGroup ()"

.PP
Definition at line \fB4546\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string getTestset ()"

.PP
Definition at line \fB4540\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void halt (int exitCode)"

.PP
Definition at line \fB2969\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename C > bool isBlanks (C c)\fR [inline]\fP"

.PP
Definition at line \fB1593\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename C > bool isEof (C c)\fR [inline]\fP"

.PP
Definition at line \fB1583\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename C > bool isEoln (C c)\fR [inline]\fP"

.PP
Definition at line \fB1588\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _ForwardIterator > std::string join (_ForwardIterator first, _ForwardIterator last)"

.PP
Definition at line \fB5047\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _ForwardIterator , typename _Separator > std::string join (_ForwardIterator first, _ForwardIterator last, _Separator separator)"

.PP
Definition at line \fB5030\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _Collection > std::string join (const _Collection & collection)"

.PP
Definition at line \fB5063\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _Collection , typename _Separator > std::string join (const _Collection & collection, _Separator separator)"

.PP
Definition at line \fB5055\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string lowerCase (std::string s)\fR [inline]\fP"

.PP
Definition at line \fB426\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quit (\fBTResult\fP result, const char * msg)"

.PP
Definition at line \fB4415\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quit (\fBTResult\fP result, const std::string & msg)"

.PP
Definition at line \fB4411\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitf (\fBTResult\fP result, const char * format,  \&.\&.\&.)"

.PP
Definition at line \fB4482\fP of file \fBtestlib\&.h\fP\&.
.SS "void quitif (bool condition, \fBTResult\fP result, const char * format,  \&.\&.\&.)"

.PP
Definition at line \fB4490\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitp (double points, const std::string & message = \fR''\fP)"

.PP
Definition at line \fB4449\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename F > \fBNORETURN\fP void quitp (F points, const char * format,  \&.\&.\&.)"

.PP
Definition at line \fB4474\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitp (float points, const std::string & message = \fR''\fP)"

.PP
Definition at line \fB4445\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitp (int points, const std::string & message = \fR''\fP)"

.PP
Definition at line \fB4457\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitp (long double points, const std::string & message = \fR''\fP)"

.PP
Definition at line \fB4453\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBNORETURN\fP void quitpi (const std::string & points_info, const std::string & message = \fR''\fP)"

.PP
Definition at line \fB4461\fP of file \fBtestlib\&.h\fP\&.
.SS "int rand ()"

.PP
Definition at line \fB4971\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _RandomAccessIter > void random_shuffle (_RandomAccessIter, _RandomAccessIter)"

.PP
Definition at line \fB4954\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerGen (int argc, char * argv[])"

.PP
Definition at line \fB4605\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerGen (int argc, char * argv[], int randomGeneratorVersion)"

.PP
Definition at line \fB4566\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerInteraction (int argc, char * argv[])"

.PP
Definition at line \fB4638\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerTestlib (int argc,  \&.\&.\&.)"

.PP
Definition at line \fB4876\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerTestlibCmd (int argc, char * argv[])"

.PP
Definition at line \fB4812\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerValidation ()"

.PP
Definition at line \fB4691\fP of file \fBtestlib\&.h\fP\&.
.SS "void registerValidation (int argc, char * argv[])"

.PP
Definition at line \fB4705\fP of file \fBtestlib\&.h\fP\&.
.SS "int resultExitCode (\fBTResult\fP r)"

.PP
Definition at line \fB2900\fP of file \fBtestlib\&.h\fP\&.
.SS "void setAppesModeEncoding (std::string appesModeEncoding)"

.PP
Definition at line \fB4614\fP of file \fBtestlib\&.h\fP\&.
.SS "void setName (const char * format,  \&.\&.\&.)"

.PP
Definition at line \fB4930\fP of file \fBtestlib\&.h\fP\&.
.SS "void setTestCase (int testCase)"

.PP
Definition at line \fB2878\fP of file \fBtestlib\&.h\fP\&.
.SS "template<typename _RandomAccessIter > void shuffle (_RandomAccessIter __first, _RandomAccessIter __last)"

.PP
Definition at line \fB4943\fP of file \fBtestlib\&.h\fP\&.
.SS "std::vector< std::string > split (const std::string & s, char separator)"
Splits string s by character separator returning exactly k+1 items, where k is the number of separator occurrences\&. 
.PP
Definition at line \fB5074\fP of file \fBtestlib\&.h\fP\&.
.SS "std::vector< std::string > split (const std::string & s, const std::string & separators)"
Splits string s by character separators returning exactly k+1 items, where k is the number of separator occurrences\&. 
.PP
Definition at line \fB5094\fP of file \fBtestlib\&.h\fP\&.
.SS "void srand (unsigned int seed)"

.PP
Definition at line \fB4989\fP of file \fBtestlib\&.h\fP\&.
.SS "void startTest (int test)"

.PP
Definition at line \fB4997\fP of file \fBtestlib\&.h\fP\&.
.SS "std::vector< std::string > tokenize (const std::string & s, char separator)"
Splits string s by character separator returning non-empty items\&. 
.PP
Definition at line \fB5120\fP of file \fBtestlib\&.h\fP\&.
.SS "std::vector< std::string > tokenize (const std::string & s, const std::string & separators)"
Splits string s by character separators returning non-empty items\&. 
.PP
Definition at line \fB5141\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string trim (const std::string & s)\fR [inline]\fP"

.PP
Definition at line \fB1597\fP of file \fBtestlib\&.h\fP\&.
.SS "void unsetTestCase ()"

.PP
Definition at line \fB343\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string upperCase (std::string s)\fR [inline]\fP"

.PP
Definition at line \fB416\fP of file \fBtestlib\&.h\fP\&.
.SH "Variable Documentation"
.PP 
.SS "int __testlib_exitCode"

.PP
Definition at line \fB336\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string __testlib_group"

.PP
Definition at line \fB4544\fP of file \fBtestlib\&.h\fP\&.
.SS "bool __testlib_hasTestCase"

.PP
Definition at line \fB338\fP of file \fBtestlib\&.h\fP\&.
.SS "const long long __TESTLIB_LONGLONG_MAX = 9223372036854775807LL"

.PP
Definition at line \fB333\fP of file \fBtestlib\&.h\fP\&.
.SS "const int __TESTLIB_MAX_TEST_CASE = 1073741823"

.PP
Definition at line \fB334\fP of file \fBtestlib\&.h\fP\&.
.SS "double __testlib_points = std::numeric_limits<float>::infinity()"

.PP
Definition at line \fB2380\fP of file \fBtestlib\&.h\fP\&.
.SS "int __testlib_testCase = \-1"

.PP
Definition at line \fB339\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string __testlib_testset"

.PP
Definition at line \fB4538\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBInStream\fP ans"

.PP
Definition at line \fB2373\fP of file \fBtestlib\&.h\fP\&.
.SS "bool appesMode"

.PP
Definition at line \fB2374\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string appesModeEncoding = 'windows\-1251'"

.PP
Definition at line \fB2375\fP of file \fBtestlib\&.h\fP\&.
.SS "class \fBChecker\fP checker"

.SS "std::string checkerName = 'untitled checker'"

.PP
Definition at line \fB2377\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBInStream\fP inf"

.PP
Definition at line \fB2371\fP of file \fBtestlib\&.h\fP\&.
.SS "const char* latestFeatures[]"

.PP
Definition at line \fB65\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBInStream\fP ouf"

.PP
Definition at line \fB2372\fP of file \fBtestlib\&.h\fP\&.
.SS "const std::string outcomes[]"
\fBInitial value:\fP.PP
.nf
= {
        "accepted",
        "wrong\-answer",
        "presentation\-error",
        "fail",
        "fail",

        "points",



        "reserved",
        "reserved",
        "unexpected\-eof",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "partially\-correct"
}
.fi

.PP
Definition at line \fB1639\fP of file \fBtestlib\&.h\fP\&.
.SS "std::string resultName"

.PP
Definition at line \fB2376\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBrandom_t\fP rnd"

.PP
Definition at line \fB2378\fP of file \fBtestlib\&.h\fP\&.
.SS "\fBTestlibFinalizeGuard\fP testlibFinalizeGuard\fR [extern]\fP"

.SS "\fBTTestlibMode\fP testlibMode = \fB_unknown\fP"

.PP
Definition at line \fB2379\fP of file \fBtestlib\&.h\fP\&.
.SS "std::fstream tout"

.PP
Definition at line \fB2823\fP of file \fBtestlib\&.h\fP\&.
.SS "class \fBValidator\fP validator"

.SS "const size_t VALIDATOR_MAX_VARIABLE_COUNT = 255"

.PP
Definition at line \fB2382\fP of file \fBtestlib\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for competitive-contest from the source code\&.
