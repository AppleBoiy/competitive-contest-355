{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment competitive-contest }competitive-contest}
{\comment Generated by doxygen 1.10.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt competitive-contest}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
competitive-contest\par \pard\plain 
{\tc\tcl1 \v competitive-contest}
{\xe \v competitive-contest}
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Fibonacci Modulo Problem
\par}
{\tc\tcl2 \v Fibonacci Modulo Problem}
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Problem Statement
\par}
{\tc\tcl3 \v Problem Statement}
You are given two integers, {\b n}  and {\b m} , and you need to find the {\b nth Fibonacci number modulo m} .\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Approach
\par}
{\tc\tcl4 \v Approach}
The naive approach to find the Fibonacci number at position {\b n}  and then taking the modulo {\b m}  might be inefficient for large values of {\b n} . However, you can optimize the solution using the Pisano Period.\par}
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Pisano Period
\par}
{\tc\tcl4 \v Pisano Period}
The Pisano period, also known as the Fibonacci period or cycle, refers to the periodic and repetitive nature of the remainders when the Fibonacci sequence is divided by a positive integer called the "modulus."\par
{\f2 read more}\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Fibonacci Sequence
\par}
{\tc\tcl4 \v Fibonacci Sequence}
The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1.\par
Example Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\par}
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Pisano Period
\par}
{\tc\tcl4 \v Pisano Period}
When the Fibonacci sequence is divided by a modulus (a positive integer), the remainders exhibit a periodic pattern known as the Pisano period. The length of this period depends on the modulus chosen.\par
The Pisano period is useful in various applications, especially in problems related to number theory and modular arithmetic.\par}
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Formula
\par}
{\tc\tcl4 \v Formula}
Given a modulus 'm,' the Pisano period is denoted as \'CF\'80(m). The period starts with the pair (0, 1) and repeats after a certain number of terms.\par}
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Example
\par}
{\tc\tcl4 \v Example}
For example, if the modulus is 5: Fibonacci sequence modulo 5 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0, 1, 1, 2, 3, 0, 3, 3, 1, 4,\par
0, 4, 4, 3, 2, 0, 2, 2, 4, 1,\par
\par
--- Pisano period starts here ---\par
\par
0, 1, 1, 2, 3, 0, 3, 3, 1, 4,\par
0, 4, 4, 3, 2, 0, 2, 2, 4, 1,\par
0, 1, 1, 2, 3, 0, 3, 3, 1, 4\par
\par
... and so on\par
}
 In this case, the Pisano period (\'CF\'80(5)) is 20, as the sequence starts repeating after 20 terms.\par}
\par}
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Code Explanation
\par}
{\tc\tcl4 \v Code Explanation}
Below is the C++ code implementing this approach:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <iostream>}\par
\par
{\cf21 #define ll long long}\par
\par
ll fib_fast(ll n, ll m) \{\par
    {\cf19 if} (n <= 1)\par
        {\cf19 return} n;\par
\par
    {\cf20 // Pisano period}\par
    ll remainder = 0;\par
\par
    ll a = 0, b = 1, c;\par
    {\cf19 for} (ll i = 0; i < n - 1; i++) \{\par
        c = (a + b) % m;\par
        a = b;\par
        b = c;\par
        {\cf19 if} (a == 0 && b == 1) \{\par
            remainder = i + 1;\par
            {\cf19 break};\par
        \}\par
    \}\par
\par
    ll new_n = n % remainder;\par
    {\cf19 if} (new_n <= 1)\par
        {\cf19 return} new_n;\par
\par
    a = 0, b = 1, c = a + b;\par
    {\cf19 for} (ll i = 0; i < new_n - 1; i++) \{\par
        c = (a + b) % m;\par
        a = b;\par
        b = c;\par
    \}\par
\par
    {\cf19 return} c % m;\par
\}\par
\par
{\cf18 int} main() \{\par
    {\cf18 long} {\cf18 long} n, m;\par
    std::cin >> n >> m;\par
    std::cout << fib_fast(n, m) << {\cf23 '\\n'};\par
\}\par
}
\par}
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Input
\par}
{\tc\tcl4 \v Input}
The program takes two inputs, {\b n}  and {\b m} , representing the position of the Fibonacci number and the modulo value.\par}
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Output
\par}
{\tc\tcl4 \v Output}
The program outputs the {\b nth Fibonacci number modulo m} .\par}
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Time Complexity
\par}
{\tc\tcl4 \v Time Complexity}
The time complexity of this solution is {\b O(remainder + new_n)} , where {\b remainder}  is the Pisano Period and {\b new_n}  is the position of the Fibonacci number within the Pisano Period. This is a significant optimization over the naive approach. \par}
\par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Checker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ConstantBound\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ConstantBounds\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
fib\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
generator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InputStreamReader\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
BufferedFileInputStreamReader\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
FileInputStreamReader\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
StringInputStreamReader\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
InStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
pattern\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
random_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TestlibFinalizeGuard\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Validator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ValidatorBoundsHit\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b BufferedFileInputStreamReader} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Checker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ConstantBound} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ConstantBounds} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b fib} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FileInputStreamReader} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b generator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InputStreamReader} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pattern} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b random_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b StringInputStreamReader} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TestlibFinalizeGuard} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Validator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ValidatorBoundsHit} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/{\b checker.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b defaultsol.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b fib.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b fib.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b generator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b generator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b officialsol.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b test.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b testlib.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b validator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BufferedFileInputStreamReader Class Reference\par \pard\plain 
{\tc\tcl2 \v BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\par
{
{\f2 #include <testlib.h>}}\par
Inheritance diagram for BufferedFileInputStreamReader:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_buffered_file_input_stream_reader.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BufferedFileInputStreamReader} (std::FILE *file, const std::string &name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~BufferedFileInputStreamReader} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestCase} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b getReadChars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b curChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nextChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unreadChar} (int c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b eof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b InputStreamReader}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~InputStreamReader} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1869} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BufferedFileInputStreamReader\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:BufferedFileInputStreamReader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BufferedFileInputStreamReader::BufferedFileInputStreamReader (std::FILE *  {\i file}, const std::string &  {\i name}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1916} of file {\b testlib.h}.}\par
}
{\xe \v ~BufferedFileInputStreamReader\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:~BufferedFileInputStreamReader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BufferedFileInputStreamReader::~BufferedFileInputStreamReader (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1923} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v close\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BufferedFileInputStreamReader::close (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1982} of file {\b testlib.h}.}\par
}
{\xe \v curChar\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:curChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BufferedFileInputStreamReader::curChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1942} of file {\b testlib.h}.}\par
}
{\xe \v eof\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool BufferedFileInputStreamReader::eof (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1978} of file {\b testlib.h}.}\par
}
{\xe \v getLine\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:getLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BufferedFileInputStreamReader::getLine (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1974} of file {\b testlib.h}.}\par
}
{\xe \v getName\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string BufferedFileInputStreamReader::getName (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1970} of file {\b testlib.h}.}\par
}
{\xe \v getReadChars\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:getReadChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > BufferedFileInputStreamReader::getReadChars (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1938} of file {\b testlib.h}.}\par
}
{\xe \v nextChar\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:nextChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BufferedFileInputStreamReader::nextChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1949} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BufferedFileInputStreamReader::setTestCase (int ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1934} of file {\b testlib.h}.}\par
}
{\xe \v skipChar\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:skipChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BufferedFileInputStreamReader::skipChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1956} of file {\b testlib.h}.}\par
}
{\xe \v unreadChar\:BufferedFileInputStreamReader}
{\xe \v BufferedFileInputStreamReader\:unreadChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BufferedFileInputStreamReader::unreadChar (int  {\i c}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1960} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Checker Class Reference\par \pard\plain 
{\tc\tcl2 \v Checker}
{\xe \v Checker}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Checker} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testset} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b group} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestset} (const char *const {\b testset})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGroup} (const char *const {\b group})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4777} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Checker\:Checker}
{\xe \v Checker\:Checker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Checker::Checker (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4784} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v group\:Checker}
{\xe \v Checker\:group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Checker::group () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4797} of file {\b testlib.h}.}\par
}
{\xe \v initialize\:Checker}
{\xe \v Checker\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Checker::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4787} of file {\b testlib.h}.}\par
}
{\xe \v setGroup\:Checker}
{\xe \v Checker\:setGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Checker::setGroup (const char *const  {\i group}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4807} of file {\b testlib.h}.}\par
}
{\xe \v setTestset\:Checker}
{\xe \v Checker\:setTestset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Checker::setTestset (const char *const  {\i testset}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4803} of file {\b testlib.h}.}\par
}
{\xe \v testset\:Checker}
{\xe \v Checker\:testset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Checker::testset () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4791} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ConstantBound Struct Reference\par \pard\plain 
{\tc\tcl2 \v ConstantBound}
{\xe \v ConstantBound}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b adjust} (T t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b has_value} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b broken}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 2400} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v adjust\:ConstantBound}
{\xe \v ConstantBound\:adjust}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void ConstantBound::adjust (T  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2405} of file {\b testlib.h}.}\par
}
{\xe \v has_value\:ConstantBound}
{\xe \v ConstantBound\:has_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ConstantBound::has_value (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2420} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v broken\:ConstantBound}
{\xe \v ConstantBound\:broken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ConstantBound::broken}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2402} of file {\b testlib.h}.}\par
}
{\xe \v value\:ConstantBound}
{\xe \v ConstantBound\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string ConstantBound::value}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2401} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ConstantBounds Struct Reference\par \pard\plain 
{\tc\tcl2 \v ConstantBounds}
{\xe \v ConstantBounds}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ConstantBound} {\b lowerBound}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ConstantBound} {\b upperBound}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 2425} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v lowerBound\:ConstantBounds}
{\xe \v ConstantBounds\:lowerBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ConstantBound} ConstantBounds::lowerBound}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2426} of file {\b testlib.h}.}\par
}
{\xe \v upperBound\:ConstantBounds}
{\xe \v ConstantBounds\:upperBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ConstantBound} ConstantBounds::upperBound}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2427} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fib Class Reference\par \pard\plain 
{\tc\tcl2 \v fib}
{\xe \v fib}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
{
{\f2 #include <fib.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 14} of file {\b fib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b fib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileInputStreamReader Class Reference\par \pard\plain 
{\tc\tcl2 \v FileInputStreamReader}
{\xe \v FileInputStreamReader}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\par
{
{\f2 #include <testlib.h>}}\par
Inheritance diagram for FileInputStreamReader:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_file_input_stream_reader.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FileInputStreamReader} (std::FILE *file, const std::string &name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestCase} (int testCase)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b getReadChars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b curChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nextChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unreadChar} (int c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b eof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b InputStreamReader}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~InputStreamReader} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1754} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FileInputStreamReader\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:FileInputStreamReader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FileInputStreamReader::FileInputStreamReader (std::FILE *  {\i file}, const std::string &  {\i name}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1802} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v close\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FileInputStreamReader::close (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1861} of file {\b testlib.h}.}\par
}
{\xe \v curChar\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:curChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FileInputStreamReader::curChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1816} of file {\b testlib.h}.}\par
}
{\xe \v eof\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FileInputStreamReader::eof (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1849} of file {\b testlib.h}.}\par
}
{\xe \v getLine\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:getLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FileInputStreamReader::getLine (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1845} of file {\b testlib.h}.}\par
}
{\xe \v getName\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string FileInputStreamReader::getName (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1841} of file {\b testlib.h}.}\par
}
{\xe \v getReadChars\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:getReadChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > FileInputStreamReader::getReadChars (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1812} of file {\b testlib.h}.}\par
}
{\xe \v nextChar\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:nextChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FileInputStreamReader::nextChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1826} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FileInputStreamReader::setTestCase (int  {\i testCase}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1806} of file {\b testlib.h}.}\par
}
{\xe \v skipChar\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:skipChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FileInputStreamReader::skipChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1833} of file {\b testlib.h}.}\par
}
{\xe \v unreadChar\:FileInputStreamReader}
{\xe \v FileInputStreamReader\:unreadChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FileInputStreamReader::unreadChar (int  {\i c}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1837} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
generator Class Reference\par \pard\plain 
{\tc\tcl2 \v generator}
{\xe \v generator}
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\par
{
{\f2 #include <generator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b generator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gen_input} ({\b ll} max_n=1e14, {\b ll} max_m=1e3)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gen_input_all} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gen_output} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b generator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v generator\:generator}
{\xe \v generator\:generator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
generator::generator (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b generator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v gen_input\:generator}
{\xe \v generator\:gen_input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void generator::gen_input ({\b ll}  {\i max_n} = {\f2 1e14}, {\b ll}  {\i max_m} = {\f2 1e3}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b generator.h}.}\par
}
{\xe \v gen_input_all\:generator}
{\xe \v generator\:gen_input_all}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void generator::gen_input_all (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b generator.h}.}\par
}
{\xe \v gen_output\:generator}
{\xe \v generator\:gen_output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void generator::gen_output (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b generator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b generator.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputStreamReader Class Reference\par \pard\plain 
{\tc\tcl2 \v InputStreamReader}
{\xe \v InputStreamReader}
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\par
{
{\f2 #include <testlib.h>}}\par
Inheritance diagram for InputStreamReader:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_stream_reader.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setTestCase} (int testCase)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< int > {\b getReadChars} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b curChar} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b nextChar} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b skipChar} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b unreadChar} (int c)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b getName} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b eof} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b close} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getLine} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~InputStreamReader} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1663} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~InputStreamReader\:InputStreamReader}
{\xe \v InputStreamReader\:~InputStreamReader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InputStreamReader::~InputStreamReader (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1688} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v close\:InputStreamReader}
{\xe \v InputStreamReader\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InputStreamReader::close (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v curChar\:InputStreamReader}
{\xe \v InputStreamReader\:curChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int InputStreamReader::curChar (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v eof\:InputStreamReader}
{\xe \v InputStreamReader\:eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool InputStreamReader::eof (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getLine\:InputStreamReader}
{\xe \v InputStreamReader\:getLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int InputStreamReader::getLine (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getName\:InputStreamReader}
{\xe \v InputStreamReader\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string InputStreamReader::getName (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getReadChars\:InputStreamReader}
{\xe \v InputStreamReader\:getReadChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< int > InputStreamReader::getReadChars (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v nextChar\:InputStreamReader}
{\xe \v InputStreamReader\:nextChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int InputStreamReader::nextChar (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setTestCase\:InputStreamReader}
{\xe \v InputStreamReader\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InputStreamReader::setTestCase (int  {\i testCase}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v skipChar\:InputStreamReader}
{\xe \v InputStreamReader\:skipChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InputStreamReader::skipChar (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v unreadChar\:InputStreamReader}
{\xe \v InputStreamReader\:unreadChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InputStreamReader::unreadChar (int  {\i c}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b FileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b BufferedFileInputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InStream Struct Reference\par \pard\plain 
{\tc\tcl2 \v InStream}
{\xe \v InStream}
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~InStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InStream} (const {\b InStream} &baseStream, std::string content)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (std::string fileName, {\b TMode} {\b mode})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (std::FILE *f, {\b TMode} {\b mode})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestCase} (int testCase)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b getReadChars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipBlanks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b curChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b nextChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b readChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b readChar} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b readSpace} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unreadChar} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (std::FILE *file=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b eof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b seekEof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b eoln} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b seekEoln} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nextLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readWord} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readToken} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readWord} (const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readWord} (const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readWords} (int size, const std::string &ptrn, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readWords} (int size, const {\b pattern} &p, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readWords} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readToken} (const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readToken} (const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readTokens} (int size, const std::string &ptrn, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readTokens} (int size, const {\b pattern} &p, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readTokens} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readWordTo} (std::string &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readWordTo} (std::string &result, const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readWordTo} (std::string &result, const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readTokenTo} (std::string &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readTokenTo} (std::string &result, const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readTokenTo} (std::string &result, const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b readLong} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b readUnsignedLong} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readInteger} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readInt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b readLong} (long long minv, long long maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< long long > {\b readLongs} (int size, long long minv, long long maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< long long > {\b readLongs} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b readUnsignedLong} (unsigned long long minv, unsigned long long maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< unsigned long long > {\b readUnsignedLongs} (int size, unsigned long long minv, unsigned long long maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< unsigned long long > {\b readUnsignedLongs} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b readLong} (unsigned long long minv, unsigned long long maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< unsigned long long > {\b readLongs} (int size, unsigned long long minv, unsigned long long maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readInteger} (int minv, int maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readInt} (int minv, int maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b readIntegers} (int size, int minv, int maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b readIntegers} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b readInts} (int size, int minv, int maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b readInts} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readReal} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readDouble} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readReal} (double minv, double maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readReals} (int size, double minv, double maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readReals} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readDouble} (double minv, double maxv, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readDoubles} (int size, double minv, double maxv, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readDoubles} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readStrictReal} (double minv, double maxv, int minAfterPointDigitCount, int maxAfterPointDigitCount, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readStrictReals} (int size, double minv, double maxv, int minAfterPointDigitCount, int maxAfterPointDigitCount, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readStrictDouble} (double minv, double maxv, int minAfterPointDigitCount, int maxAfterPointDigitCount, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b readStrictDoubles} (int size, double minv, double maxv, int minAfterPointDigitCount, int maxAfterPointDigitCount, const std::string &variablesName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readString} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readStrings} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readStringTo} (std::string &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readString} (const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readString} (const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readStrings} (int size, const {\b pattern} &p, const std::string &variableName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readStrings} (int size, const std::string &ptrn, const std::string &variableName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readStringTo} (std::string &result, const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readStringTo} (std::string &result, const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readLines} (int size, int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readLineTo} (std::string &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readLine} (const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readLine} (const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readLines} (int size, const {\b pattern} &p, const std::string &variableName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b readLines} (int size, const std::string &ptrn, const std::string &variableName="", int indexBase=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readLineTo} (std::string &result, const {\b pattern} &p, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readLineTo} (std::string &result, const std::string &ptrn, const std::string &variableName="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readEoln} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readEof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quit} ({\b TResult} result, const char *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitf} ({\b TResult} result, const char *msg,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b quitif} (bool condition, {\b TResult} result, const char *msg,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quits} ({\b TResult} result, std::string msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ensuref} (bool cond, const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b __testlib_ensure} (bool cond, std::string message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b xmlSafeWrite} (std::FILE *file, const char *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipBom} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b textColor} ({\b WORD} color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b quitscr} ({\b WORD} color, const char *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b quitscrS} ({\b WORD} color, std::string msg)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputStreamReader} * {\b reader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lastLine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TMode} {\b mode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b opened}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stdfile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b strict}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wordReserveSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _tmpReadToken}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readManyIteration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b maxFileSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b maxTokenLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b maxMessageLength}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b NO_INDEX} = INT_MAX\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b OPEN_BRACKET} = char(11)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b CLOSE_BRACKET} = char(17)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b WORD} {\b LightGray} = 0x07\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b WORD} {\b LightRed} = 0x0c\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b WORD} {\b LightCyan} = 0x0b\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b WORD} {\b LightGreen} = 0x0a\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b WORD} {\b LightYellow} = 0x0e\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1998} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InStream\:InStream}
{\xe \v InStream\:InStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InStream::InStream ()}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2828} of file {\b testlib.h}.}\par
}
{\xe \v ~InStream\:InStream}
{\xe \v InStream\:~InStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InStream::~InStream ()}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2857} of file {\b testlib.h}.}\par
}
{\xe \v InStream\:InStream}
{\xe \v InStream\:InStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InStream::InStream (const {\b InStream} &  {\i baseStream}, std::string  {\i content})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2843} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v __testlib_ensure\:InStream}
{\xe \v InStream\:__testlib_ensure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::__testlib_ensure (bool  {\i cond}, std::string  {\i message})}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4396} of file {\b testlib.h}.}\par
}
{\xe \v close\:InStream}
{\xe \v InStream\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::close ()}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4401} of file {\b testlib.h}.}\par
}
{\xe \v curChar\:InStream}
{\xe \v InStream\:curChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char InStream::curChar ()}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3331} of file {\b testlib.h}.}\par
}
{\xe \v ensuref\:InStream}
{\xe \v InStream\:ensuref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::ensuref (bool  {\i cond}, const char *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4389} of file {\b testlib.h}.}\par
}
{\xe \v eof\:InStream}
{\xe \v InStream\:eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::eof ()}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4154} of file {\b testlib.h}.}\par
}
{\xe \v eoln\:InStream}
{\xe \v InStream\:eoln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::eoln ()}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4168} of file {\b testlib.h}.}\par
}
{\xe \v getReadChars\:InStream}
{\xe \v InStream\:getReadChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > InStream::getReadChars ()}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2872} of file {\b testlib.h}.}\par
}
{\xe \v init\:InStream}
{\xe \v InStream\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::init (std::FILE *  {\i f}, {\b TMode}  {\i mode})}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3301} of file {\b testlib.h}.}\par
}
{\xe \v init\:InStream}
{\xe \v InStream\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::init (std::string  {\i fileName}, {\b TMode}  {\i mode})}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3277} of file {\b testlib.h}.}\par
}
{\xe \v nextChar\:InStream}
{\xe \v InStream\:nextChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char InStream::nextChar ()}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3335} of file {\b testlib.h}.}\par
}
{\xe \v nextLine\:InStream}
{\xe \v InStream\:nextLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::nextLine ()}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4246} of file {\b testlib.h}.}\par
}
{\xe \v quit\:InStream}
{\xe \v InStream\:quit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void InStream::quit ({\b TResult}  {\i result}, const char *  {\i msg})}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3046} of file {\b testlib.h}.}\par
}
{\xe \v quitf\:InStream}
{\xe \v InStream\:quitf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void InStream::quitf ({\b TResult}  {\i result}, const char *  {\i msg},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3189} of file {\b testlib.h}.}\par
}
{\xe \v quitif\:InStream}
{\xe \v InStream\:quitif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::quitif (bool  {\i condition}, {\b TResult}  {\i result}, const char *  {\i msg},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3197} of file {\b testlib.h}.}\par
}
{\xe \v quits\:InStream}
{\xe \v InStream\:quits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void InStream::quits ({\b TResult}  {\i result}, std::string  {\i msg})}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3204} of file {\b testlib.h}.}\par
}
{\xe \v quitscr\:InStream}
{\xe \v InStream\:quitscr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::quitscr ({\b WORD}  {\i color}, const char *  {\i msg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3239} of file {\b testlib.h}.}\par
}
{\xe \v quitscrS\:InStream}
{\xe \v InStream\:quitscrS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::quitscrS ({\b WORD}  {\i color}, std::string  {\i msg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3235} of file {\b testlib.h}.}\par
}
{\xe \v readChar\:InStream}
{\xe \v InStream\:readChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char InStream::readChar ()}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3339} of file {\b testlib.h}.}\par
}
{\xe \v readChar\:InStream}
{\xe \v InStream\:readChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char InStream::readChar (char  {\i c})}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3343} of file {\b testlib.h}.}\par
}
{\xe \v readDouble\:InStream}
{\xe \v InStream\:readDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readDouble ()}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4022} of file {\b testlib.h}.}\par
}
{\xe \v readDouble\:InStream}
{\xe \v InStream\:readDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readDouble (double  {\i minv}, double  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4071} of file {\b testlib.h}.}\par
}
{\xe \v readDoubles\:InStream}
{\xe \v InStream\:readDoubles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readDoubles (int  {\i size}, double  {\i minv}, double  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4076} of file {\b testlib.h}.}\par
}
{\xe \v readDoubles\:InStream}
{\xe \v InStream\:readDoubles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readDoubles (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4082} of file {\b testlib.h}.}\par
}
{\xe \v readEof\:InStream}
{\xe \v InStream\:readEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readEof ()}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4224} of file {\b testlib.h}.}\par
}
{\xe \v readEoln\:InStream}
{\xe \v InStream\:readEoln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readEoln ()}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4218} of file {\b testlib.h}.}\par
}
{\xe \v readInt\:InStream}
{\xe \v InStream\:readInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::readInt ()}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3956} of file {\b testlib.h}.}\par
}
{\xe \v readInt\:InStream}
{\xe \v InStream\:readInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::readInt (int  {\i minv}, int  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3960} of file {\b testlib.h}.}\par
}
{\xe \v readInteger\:InStream}
{\xe \v InStream\:readInteger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::readInteger ()}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3832} of file {\b testlib.h}.}\par
}
{\xe \v readInteger\:InStream}
{\xe \v InStream\:readInteger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::readInteger (int  {\i minv}, int  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3991} of file {\b testlib.h}.}\par
}
{\xe \v readIntegers\:InStream}
{\xe \v InStream\:readIntegers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > InStream::readIntegers (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4011} of file {\b testlib.h}.}\par
}
{\xe \v readIntegers\:InStream}
{\xe \v InStream\:readIntegers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > InStream::readIntegers (int  {\i size}, int  {\i minv}, int  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4005} of file {\b testlib.h}.}\par
}
{\xe \v readInts\:InStream}
{\xe \v InStream\:readInts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > InStream::readInts (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4001} of file {\b testlib.h}.}\par
}
{\xe \v readInts\:InStream}
{\xe \v InStream\:readInts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > InStream::readInts (int  {\i size}, int  {\i minv}, int  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3995} of file {\b testlib.h}.}\par
}
{\xe \v readLine\:InStream}
{\xe \v InStream\:readLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readLine ()}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4347} of file {\b testlib.h}.}\par
}
{\xe \v readLine\:InStream}
{\xe \v InStream\:readLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readLine (const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4363} of file {\b testlib.h}.}\par
}
{\xe \v readLine\:InStream}
{\xe \v InStream\:readLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readLine (const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4374} of file {\b testlib.h}.}\par
}
{\xe \v readLines\:InStream}
{\xe \v InStream\:readLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readLines (int  {\i size}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4368} of file {\b testlib.h}.}\par
}
{\xe \v readLines\:InStream}
{\xe \v InStream\:readLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readLines (int  {\i size}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4379} of file {\b testlib.h}.}\par
}
{\xe \v readLines\:InStream}
{\xe \v InStream\:readLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readLines (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4351} of file {\b testlib.h}.}\par
}
{\xe \v readLineTo\:InStream}
{\xe \v InStream\:readLineTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readLineTo (std::string &  {\i result})}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4343} of file {\b testlib.h}.}\par
}
{\xe \v readLineTo\:InStream}
{\xe \v InStream\:readLineTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readLineTo (std::string &  {\i result}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4355} of file {\b testlib.h}.}\par
}
{\xe \v readLineTo\:InStream}
{\xe \v InStream\:readLineTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readLineTo (std::string &  {\i result}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4359} of file {\b testlib.h}.}\par
}
{\xe \v readLong\:InStream}
{\xe \v InStream\:readLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long InStream::readLong ()}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3845} of file {\b testlib.h}.}\par
}
{\xe \v readLong\:InStream}
{\xe \v InStream\:readLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long InStream::readLong (long long  {\i minv}, long long  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3863} of file {\b testlib.h}.}\par
}
{\xe \v readLong\:InStream}
{\xe \v InStream\:readLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long InStream::readLong (unsigned long long  {\i minv}, unsigned long long  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3952} of file {\b testlib.h}.}\par
}
{\xe \v readLongs\:InStream}
{\xe \v InStream\:readLongs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< long long > InStream::readLongs (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3901} of file {\b testlib.h}.}\par
}
{\xe \v readLongs\:InStream}
{\xe \v InStream\:readLongs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< long long > InStream::readLongs (int  {\i size}, long long  {\i minv}, long long  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3895} of file {\b testlib.h}.}\par
}
{\xe \v readLongs\:InStream}
{\xe \v InStream\:readLongs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< unsigned long long > InStream::readLongs (int  {\i size}, unsigned long long  {\i minv}, unsigned long long  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readReal\:InStream}
{\xe \v InStream\:readReal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readReal ()}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4015} of file {\b testlib.h}.}\par
}
{\xe \v readReal\:InStream}
{\xe \v InStream\:readReal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readReal (double  {\i minv}, double  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4026} of file {\b testlib.h}.}\par
}
{\xe \v readReals\:InStream}
{\xe \v InStream\:readReals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readReals (int  {\i size}, double  {\i minv}, double  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4061} of file {\b testlib.h}.}\par
}
{\xe \v readReals\:InStream}
{\xe \v InStream\:readReals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readReals (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4067} of file {\b testlib.h}.}\par
}
{\xe \v readSpace\:InStream}
{\xe \v InStream\:readSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char InStream::readSpace ()}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3357} of file {\b testlib.h}.}\par
}
{\xe \v readStrictDouble\:InStream}
{\xe \v InStream\:readStrictDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readStrictDouble (double  {\i minv}, double  {\i maxv}, int  {\i minAfterPointDigitCount}, int  {\i maxAfterPointDigitCount}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4136} of file {\b testlib.h}.}\par
}
{\xe \v readStrictDoubles\:InStream}
{\xe \v InStream\:readStrictDoubles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readStrictDoubles (int  {\i size}, double  {\i minv}, double  {\i maxv}, int  {\i minAfterPointDigitCount}, int  {\i maxAfterPointDigitCount}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4144} of file {\b testlib.h}.}\par
}
{\xe \v readStrictReal\:InStream}
{\xe \v InStream\:readStrictReal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double InStream::readStrictReal (double  {\i minv}, double  {\i maxv}, int  {\i minAfterPointDigitCount}, int  {\i maxAfterPointDigitCount}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4086} of file {\b testlib.h}.}\par
}
{\xe \v readStrictReals\:InStream}
{\xe \v InStream\:readStrictReals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > InStream::readStrictReals (int  {\i size}, double  {\i minv}, double  {\i maxv}, int  {\i minAfterPointDigitCount}, int  {\i maxAfterPointDigitCount}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4126} of file {\b testlib.h}.}\par
}
{\xe \v readString\:InStream}
{\xe \v InStream\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readString ()}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4280} of file {\b testlib.h}.}\par
}
{\xe \v readString\:InStream}
{\xe \v InStream\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readString (const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4318} of file {\b testlib.h}.}\par
}
{\xe \v readString\:InStream}
{\xe \v InStream\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readString (const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4330} of file {\b testlib.h}.}\par
}
{\xe \v readStrings\:InStream}
{\xe \v InStream\:readStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readStrings (int  {\i size}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4324} of file {\b testlib.h}.}\par
}
{\xe \v readStrings\:InStream}
{\xe \v InStream\:readStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readStrings (int  {\i size}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4336} of file {\b testlib.h}.}\par
}
{\xe \v readStrings\:InStream}
{\xe \v InStream\:readStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readStrings (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4285} of file {\b testlib.h}.}\par
}
{\xe \v readStringTo\:InStream}
{\xe \v InStream\:readStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readStringTo (std::string &  {\i result})}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4250} of file {\b testlib.h}.}\par
}
{\xe \v readStringTo\:InStream}
{\xe \v InStream\:readStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readStringTo (std::string &  {\i result}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4289} of file {\b testlib.h}.}\par
}
{\xe \v readStringTo\:InStream}
{\xe \v InStream\:readStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readStringTo (std::string &  {\i result}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4314} of file {\b testlib.h}.}\par
}
{\xe \v readToken\:InStream}
{\xe \v InStream\:readToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readToken ()}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3412} of file {\b testlib.h}.}\par
}
{\xe \v readToken\:InStream}
{\xe \v InStream\:readToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readToken (const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3507} of file {\b testlib.h}.}\par
}
{\xe \v readToken\:InStream}
{\xe \v InStream\:readToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readToken (const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3522} of file {\b testlib.h}.}\par
}
{\xe \v readTokens\:InStream}
{\xe \v InStream\:readTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readTokens (int  {\i size}, const {\b pattern} &  {\i p}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3512} of file {\b testlib.h}.}\par
}
{\xe \v readTokens\:InStream}
{\xe \v InStream\:readTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readTokens (int  {\i size}, const std::string &  {\i ptrn}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3527} of file {\b testlib.h}.}\par
}
{\xe \v readTokens\:InStream}
{\xe \v InStream\:readTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readTokens (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3518} of file {\b testlib.h}.}\par
}
{\xe \v readTokenTo\:InStream}
{\xe \v InStream\:readTokenTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readTokenTo (std::string &  {\i result})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3416} of file {\b testlib.h}.}\par
}
{\xe \v readTokenTo\:InStream}
{\xe \v InStream\:readTokenTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readTokenTo (std::string &  {\i result}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3552} of file {\b testlib.h}.}\par
}
{\xe \v readTokenTo\:InStream}
{\xe \v InStream\:readTokenTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readTokenTo (std::string &  {\i result}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3556} of file {\b testlib.h}.}\par
}
{\xe \v readUnsignedLong\:InStream}
{\xe \v InStream\:readUnsignedLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long InStream::readUnsignedLong ()}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3854} of file {\b testlib.h}.}\par
}
{\xe \v readUnsignedLong\:InStream}
{\xe \v InStream\:readUnsignedLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long InStream::readUnsignedLong (unsigned long long  {\i minv}, unsigned long long  {\i maxv}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3906} of file {\b testlib.h}.}\par
}
{\xe \v readUnsignedLongs\:InStream}
{\xe \v InStream\:readUnsignedLongs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< unsigned long long > InStream::readUnsignedLongs (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3947} of file {\b testlib.h}.}\par
}
{\xe \v readUnsignedLongs\:InStream}
{\xe \v InStream\:readUnsignedLongs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< unsigned long long > InStream::readUnsignedLongs (int  {\i size}, unsigned long long  {\i minv}, unsigned long long  {\i maxv}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3940} of file {\b testlib.h}.}\par
}
{\xe \v readWord\:InStream}
{\xe \v InStream\:readWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readWord ()}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3374} of file {\b testlib.h}.}\par
}
{\xe \v readWord\:InStream}
{\xe \v InStream\:readWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readWord (const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3457} of file {\b testlib.h}.}\par
}
{\xe \v readWord\:InStream}
{\xe \v InStream\:readWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::readWord (const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3495} of file {\b testlib.h}.}\par
}
{\xe \v readWords\:InStream}
{\xe \v InStream\:readWords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readWords (int  {\i size}, const {\b pattern} &  {\i p}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3485} of file {\b testlib.h}.}\par
}
{\xe \v readWords\:InStream}
{\xe \v InStream\:readWords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readWords (int  {\i size}, const std::string &  {\i ptrn}, const std::string &  {\i variablesName} = {\f2 ""}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3500} of file {\b testlib.h}.}\par
}
{\xe \v readWords\:InStream}
{\xe \v InStream\:readWords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > InStream::readWords (int  {\i size}, int  {\i indexBase} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3491} of file {\b testlib.h}.}\par
}
{\xe \v readWordTo\:InStream}
{\xe \v InStream\:readWordTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readWordTo (std::string &  {\i result})}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3379} of file {\b testlib.h}.}\par
}
{\xe \v readWordTo\:InStream}
{\xe \v InStream\:readWordTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readWordTo (std::string &  {\i result}, const {\b pattern} &  {\i p}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3534} of file {\b testlib.h}.}\par
}
{\xe \v readWordTo\:InStream}
{\xe \v InStream\:readWordTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::readWordTo (std::string &  {\i result}, const std::string &  {\i ptrn}, const std::string &  {\i variableName} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3548} of file {\b testlib.h}.}\par
}
{\xe \v reset\:InStream}
{\xe \v InStream\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::reset (std::FILE *  {\i file} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3247} of file {\b testlib.h}.}\par
}
{\xe \v seekEof\:InStream}
{\xe \v InStream\:seekEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::seekEof ()}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4161} of file {\b testlib.h}.}\par
}
{\xe \v seekEoln\:InStream}
{\xe \v InStream\:seekEoln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::seekEoln ()}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4233} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:InStream}
{\xe \v InStream\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::setTestCase (int  {\i testCase})}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2865} of file {\b testlib.h}.}\par
}
{\xe \v skipBlanks\:InStream}
{\xe \v InStream\:skipBlanks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::skipBlanks ()}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3369} of file {\b testlib.h}.}\par
}
{\xe \v skipBom\:InStream}
{\xe \v InStream\:skipBom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::skipBom ()}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3316} of file {\b testlib.h}.}\par
}
{\xe \v skipChar\:InStream}
{\xe \v InStream\:skipChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::skipChar ()}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3365} of file {\b testlib.h}.}\par
}
{\xe \v textColor\:InStream}
{\xe \v InStream\:textColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::textColor ({\b WORD}  {\i color}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2924} of file {\b testlib.h}.}\par
}
{\xe \v unreadChar\:InStream}
{\xe \v InStream\:unreadChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::unreadChar (char  {\i c})}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3361} of file {\b testlib.h}.}\par
}
{\xe \v xmlSafeWrite\:InStream}
{\xe \v InStream\:xmlSafeWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InStream::xmlSafeWrite (std::FILE *  {\i file}, const char *  {\i msg})}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3208} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _tmpReadToken\:InStream}
{\xe \v InStream\:_tmpReadToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::_tmpReadToken}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2017} of file {\b testlib.h}.}\par
}
{\xe \v CLOSE_BRACKET\:InStream}
{\xe \v InStream\:CLOSE_BRACKET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char InStream::CLOSE_BRACKET = char(17){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2346} of file {\b testlib.h}.}\par
}
{\xe \v lastLine\:InStream}
{\xe \v InStream\:lastLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::lastLine}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2008} of file {\b testlib.h}.}\par
}
{\xe \v LightCyan\:InStream}
{\xe \v InStream\:LightCyan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b WORD} InStream::LightCyan = 0x0b{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2350} of file {\b testlib.h}.}\par
}
{\xe \v LightGray\:InStream}
{\xe \v InStream\:LightGray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b WORD} InStream::LightGray = 0x07{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2348} of file {\b testlib.h}.}\par
}
{\xe \v LightGreen\:InStream}
{\xe \v InStream\:LightGreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b WORD} InStream::LightGreen = 0x0a{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2351} of file {\b testlib.h}.}\par
}
{\xe \v LightRed\:InStream}
{\xe \v InStream\:LightRed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b WORD} InStream::LightRed = 0x0c{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2349} of file {\b testlib.h}.}\par
}
{\xe \v LightYellow\:InStream}
{\xe \v InStream\:LightYellow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b WORD} InStream::LightYellow = 0x0e{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2352} of file {\b testlib.h}.}\par
}
{\xe \v maxFileSize\:InStream}
{\xe \v InStream\:maxFileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t InStream::maxFileSize}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2020} of file {\b testlib.h}.}\par
}
{\xe \v maxMessageLength\:InStream}
{\xe \v InStream\:maxMessageLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t InStream::maxMessageLength}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2022} of file {\b testlib.h}.}\par
}
{\xe \v maxTokenLength\:InStream}
{\xe \v InStream\:maxTokenLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t InStream::maxTokenLength}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2021} of file {\b testlib.h}.}\par
}
{\xe \v mode\:InStream}
{\xe \v InStream\:mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TMode} InStream::mode}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2011} of file {\b testlib.h}.}\par
}
{\xe \v name\:InStream}
{\xe \v InStream\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string InStream::name}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2010} of file {\b testlib.h}.}\par
}
{\xe \v NO_INDEX\:InStream}
{\xe \v InStream\:NO_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int InStream::NO_INDEX = INT_MAX{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2344} of file {\b testlib.h}.}\par
}
{\xe \v OPEN_BRACKET\:InStream}
{\xe \v InStream\:OPEN_BRACKET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char InStream::OPEN_BRACKET = char(11){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2345} of file {\b testlib.h}.}\par
}
{\xe \v opened\:InStream}
{\xe \v InStream\:opened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::opened}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2012} of file {\b testlib.h}.}\par
}
{\xe \v reader\:InStream}
{\xe \v InStream\:reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InputStreamReader}* InStream::reader}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2007} of file {\b testlib.h}.}\par
}
{\xe \v readManyIteration\:InStream}
{\xe \v InStream\:readManyIteration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::readManyIteration}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2019} of file {\b testlib.h}.}\par
}
{\xe \v stdfile\:InStream}
{\xe \v InStream\:stdfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::stdfile}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2013} of file {\b testlib.h}.}\par
}
{\xe \v strict\:InStream}
{\xe \v InStream\:strict}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InStream::strict}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2014} of file {\b testlib.h}.}\par
}
{\xe \v wordReserveSize\:InStream}
{\xe \v InStream\:wordReserveSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InStream::wordReserveSize}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2016} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pattern Class Reference\par \pard\plain 
{\tc\tcl2 \v pattern}
{\xe \v pattern}
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pattern} (std::string s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b next} ({\b random_t} &{\b rnd}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matches} (const std::string &s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b src} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 713} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v pattern\:pattern}
{\xe \v pattern\:pattern}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pattern::pattern (std::string  {\i s})}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1524} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v matches\:pattern}
{\xe \v pattern\:matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool pattern::matches (const std::string &  {\i s}) const}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1294} of file {\b testlib.h}.}\par
}
{\xe \v next\:pattern}
{\xe \v pattern\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string pattern::next ({\b random_t} &  {\i rnd}) const}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1369} of file {\b testlib.h}.}\par
}
{\xe \v src\:pattern}
{\xe \v pattern\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string pattern::src () const}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1344} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
random_t Class Reference\par \pard\plain 
{\tc\tcl2 \v random_t}
{\xe \v random_t}
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b random_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSeed} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSeed} (long long _seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b next} (const std::string &ptrn)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b next} (int {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b next} (unsigned int {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b next} (long long {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b next} (unsigned long long {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b next} (long {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b next} (unsigned long {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b next} (int from, int to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b next} (unsigned int from, unsigned int to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b next} (long long from, long long to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b next} (unsigned long long from, unsigned long long to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b next} (long from, long to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b next} (unsigned long from, unsigned long to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b next} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b next} (double {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b next} (double from, double to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > Container::value_type {\b any} (const Container &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iter > Iter::value_type {\b any} (const Iter &begin, const Iter &end)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b next} (const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wnext} (int {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b wnext} (long long {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b wnext} (double {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b wnext} (int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b wnext} (unsigned int {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b wnext} (unsigned long long {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b wnext} (long {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b wnext} (unsigned long {\b n}, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wnext} (int from, int to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wnext} (unsigned int from, unsigned int to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long long {\b wnext} (long long from, long long to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b wnext} (unsigned long long from, unsigned long long to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b wnext} (long from, long to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b wnext} (unsigned long from, unsigned long to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b wnext} (double from, double to, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > Container::value_type {\b wany} (const Container &c, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iter > Iter::value_type {\b wany} (const Iter &begin, const Iter &end, int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename E > std::vector< E > {\b perm} (T size, E first)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::vector< T > {\b perm} (T size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::vector< T > {\b distinct} (int size, T from, T to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::vector< T > {\b distinct} (int size, T upper)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::vector< T > {\b partition} (int size, T sum, T min_part)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::vector< T > {\b partition} (int size, T sum)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b version} = -1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 749} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v random_t\:random_t}
{\xe \v random_t\:random_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
random_t::random_t (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 778} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v any\:random_t}
{\xe \v random_t\:any}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Container > Container::value_type random_t::any (const Container &  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 936} of file {\b testlib.h}.}\par
}
{\xe \v any\:random_t}
{\xe \v random_t\:any}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iter > Iter::value_type random_t::any (const Iter &  {\i begin}, const Iter &  {\i end}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 947} of file {\b testlib.h}.}\par
}
{\xe \v distinct\:random_t}
{\xe \v random_t\:distinct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > random_t::distinct (int  {\i size}, T  {\i from}, T  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1184} of file {\b testlib.h}.}\par
}
{\xe \v distinct\:random_t}
{\xe \v random_t\:distinct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > random_t::distinct (int  {\i size}, T  {\i upper}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1222} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::next (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 914} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string random_t::next (const char *  {\i format},   {\i ...}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 960} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string random_t::next (const std::string &  {\i ptrn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 806} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::next (double  {\i from}, double  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 928} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::next (double  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 921} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::next (int  {\i from}, int  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 880} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::next (int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 821} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long random_t::next (long  {\i from}, long  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 902} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long random_t::next (long long  {\i from}, long long  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 890} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long random_t::next (long long  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 846} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long random_t::next (long  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 868} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int random_t::next (unsigned int  {\i from}, unsigned int  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 885} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int random_t::next (unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 839} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long random_t::next (unsigned long  {\i from}, unsigned long  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 907} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long random_t::next (unsigned long long  {\i from}, unsigned long long  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 895} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long random_t::next (unsigned long long  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 861} of file {\b testlib.h}.}\par
}
{\xe \v next\:random_t}
{\xe \v random_t\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long random_t::next (unsigned long  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 873} of file {\b testlib.h}.}\par
}
{\xe \v partition\:random_t}
{\xe \v random_t\:partition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > random_t::partition (int  {\i size}, T  {\i sum}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1282} of file {\b testlib.h}.}\par
}
{\xe \v partition\:random_t}
{\xe \v random_t\:partition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > random_t::partition (int  {\i size}, T  {\i sum}, T  {\i min_part}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1238} of file {\b testlib.h}.}\par
}
{\xe \v perm\:random_t}
{\xe \v random_t\:perm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > random_t::perm (T  {\i size}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1178} of file {\b testlib.h}.}\par
}
{\xe \v perm\:random_t}
{\xe \v random_t\:perm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > std::vector< E > random_t::perm (T  {\i size}, E  {\i first}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1161} of file {\b testlib.h}.}\par
}
{\xe \v setSeed\:random_t}
{\xe \v random_t\:setSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void random_t::setSeed (int  {\i argc}, char *  {\i argv}[]){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 783} of file {\b testlib.h}.}\par
}
{\xe \v setSeed\:random_t}
{\xe \v random_t\:setSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void random_t::setSeed (long long  {\i _seed}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 798} of file {\b testlib.h}.}\par
}
{\xe \v wany\:random_t}
{\xe \v random_t\:wany}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Container > Container::value_type random_t::wany (const Container &  {\i c}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1138} of file {\b testlib.h}.}\par
}
{\xe \v wany\:random_t}
{\xe \v random_t\:wany}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iter > Iter::value_type random_t::wany (const Iter &  {\i begin}, const Iter &  {\i end}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1149} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::wnext (double  {\i from}, double  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1130} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::wnext (double  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1027} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::wnext (int  {\i from}, int  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1087} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::wnext (int  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 973} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double random_t::wnext (int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1054} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long random_t::wnext (long  {\i from}, long  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1116} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long random_t::wnext (long long  {\i from}, long long  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1101} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long long random_t::wnext (long long  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1000} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long random_t::wnext (long  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1074} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::wnext (unsigned int  {\i from}, unsigned int  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1094} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int random_t::wnext (unsigned int  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1059} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long random_t::wnext (unsigned long  {\i from}, unsigned long  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1123} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long random_t::wnext (unsigned long long  {\i from}, unsigned long long  {\i to}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1108} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long random_t::wnext (unsigned long long  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1066} of file {\b testlib.h}.}\par
}
{\xe \v wnext\:random_t}
{\xe \v random_t\:wnext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long random_t::wnext (unsigned long  {\i n}, int  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1079} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v version\:random_t}
{\xe \v random_t\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int random_t::version = -1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 775} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StringInputStreamReader Class Reference\par \pard\plain 
{\tc\tcl2 \v StringInputStreamReader}
{\xe \v StringInputStreamReader}
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\par
{
{\f2 #include <testlib.h>}}\par
Inheritance diagram for StringInputStreamReader:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string_input_stream_reader.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringInputStreamReader} (const std::string &content)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestCase} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b getReadChars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b curChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nextChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skipChar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unreadChar} (int c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b eof} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b InputStreamReader}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~InputStreamReader} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1692} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StringInputStreamReader\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:StringInputStreamReader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringInputStreamReader::StringInputStreamReader (const std::string &  {\i content}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1698} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v close\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void StringInputStreamReader::close (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1749} of file {\b testlib.h}.}\par
}
{\xe \v curChar\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:curChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StringInputStreamReader::curChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1710} of file {\b testlib.h}.}\par
}
{\xe \v eof\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:eof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool StringInputStreamReader::eof (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1745} of file {\b testlib.h}.}\par
}
{\xe \v getLine\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:getLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StringInputStreamReader::getLine (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1741} of file {\b testlib.h}.}\par
}
{\xe \v getName\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string StringInputStreamReader::getName (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1737} of file {\b testlib.h}.}\par
}
{\xe \v getReadChars\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:getReadChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > StringInputStreamReader::getReadChars (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1706} of file {\b testlib.h}.}\par
}
{\xe \v nextChar\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:nextChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StringInputStreamReader::nextChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1717} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void StringInputStreamReader::setTestCase (int ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1702} of file {\b testlib.h}.}\par
}
{\xe \v skipChar\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:skipChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void StringInputStreamReader::skipChar (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1725} of file {\b testlib.h}.}\par
}
{\xe \v unreadChar\:StringInputStreamReader}
{\xe \v StringInputStreamReader\:unreadChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void StringInputStreamReader::unreadChar (int  {\i c}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b InputStreamReader} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 1729} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TestlibFinalizeGuard Struct Reference\par \pard\plain 
{\tc\tcl2 \v TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard}
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestlibFinalizeGuard} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TestlibFinalizeGuard} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quitCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readEofCount}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b alive} = true\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b registered} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 2770} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TestlibFinalizeGuard\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:TestlibFinalizeGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TestlibFinalizeGuard::TestlibFinalizeGuard (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2776} of file {\b testlib.h}.}\par
}
{\xe \v ~TestlibFinalizeGuard\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:~TestlibFinalizeGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TestlibFinalizeGuard::~TestlibFinalizeGuard (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2780} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v alive\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:alive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TestlibFinalizeGuard::alive = true{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2771} of file {\b testlib.h}.}\par
}
{\xe \v quitCount\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:quitCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TestlibFinalizeGuard::quitCount}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2774} of file {\b testlib.h}.}\par
}
{\xe \v readEofCount\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:readEofCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TestlibFinalizeGuard::readEofCount}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2774} of file {\b testlib.h}.}\par
}
{\xe \v registered\:TestlibFinalizeGuard}
{\xe \v TestlibFinalizeGuard\:registered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TestlibFinalizeGuard::registered = false{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2772} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Validator Class Reference\par \pard\plain 
{\tc\tcl2 \v Validator}
{\xe \v Validator}
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Validator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testset} () {\b const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b group} () {\b const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testOverviewLogFileName} () {\b const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testMarkupFileName} () {\b const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testCase} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testCaseFileName} () {\b const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setTestset} ({\b const} {\b char} *{\b const} {\b testset})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setGroup} ({\b const} {\b char} *{\b const} {\b group})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setTestOverviewLogFileName} ({\b const} {\b char} *{\b const} {\b testOverviewLogFileName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setTestMarkupFileName} ({\b const} {\b char} *{\b const} {\b testMarkupFileName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setTestCase} ({\b int} {\b testCase})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setTestCaseFileName} ({\b const} {\b char} *{\b const} {\b testCaseFileName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b prepVariableName} ({\b const} std::string &{\b variableName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ignoreMinBound} ({\b const} std::string &{\b variableName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ignoreMaxBound} ({\b const} std::string &{\b variableName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addBoundsHit} ({\b const} std::string &{\b variableName}, {\b ValidatorBoundsHit} {\b boundsHit})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addVariable} ({\b const} std::string &{\b variableName})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getVariablesLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b typename} {\b T} > {\b void} {\b adjustConstantBounds} ({\b const} std::string &{\b variableName}, {\b T} {\b lower}, {\b T} {\b upper})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getBoundsHitLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getConstantBoundsLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getFeaturesLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b writeTestOverviewLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b writeTestMarkup} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b writeTestCase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addFeature} ({\b const} std::string &{\b feature})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b feature} ({\b const} std::string &feature)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 2432} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Validator\:Validator}
{\xe \v Validator\:Validator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Validator::Validator (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2468} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addBoundsHit\:Validator}
{\xe \v Validator\:addBoundsHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::addBoundsHit ({\b const} std::string &  {\i variableName}, {\b ValidatorBoundsHit}  {\i boundsHit}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2547} of file {\b testlib.h}.}\par
}
{\xe \v addFeature\:Validator}
{\xe \v Validator\:addFeature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::addFeature ({\b const} std::string &  {\i feature}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2746} of file {\b testlib.h}.}\par
}
{\xe \v addVariable\:Validator}
{\xe \v Validator\:addVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::addVariable ({\b const} std::string &  {\i variableName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2556} of file {\b testlib.h}.}\par
}
{\xe \v adjustConstantBounds\:Validator}
{\xe \v Validator\:adjustConstantBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b T} > {\b void} Validator::adjustConstantBounds ({\b const} std::string &  {\i variableName}, {\b T}  {\i lower}, {\b T}  {\i upper}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2572} of file {\b testlib.h}.}\par
}
{\xe \v feature\:Validator}
{\xe \v Validator\:feature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::feature ({\b const} std::string &  {\i feature}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2755} of file {\b testlib.h}.}\par
}
{\xe \v getBoundsHitLog\:Validator}
{\xe \v Validator\:getBoundsHitLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::getBoundsHitLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2581} of file {\b testlib.h}.}\par
}
{\xe \v getConstantBoundsLog\:Validator}
{\xe \v Validator\:getConstantBoundsLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::getConstantBoundsLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2596} of file {\b testlib.h}.}\par
}
{\xe \v getFeaturesLog\:Validator}
{\xe \v Validator\:getFeaturesLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::getFeaturesLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2617} of file {\b testlib.h}.}\par
}
{\xe \v getVariablesLog\:Validator}
{\xe \v Validator\:getVariablesLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::getVariablesLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2564} of file {\b testlib.h}.}\par
}
{\xe \v group\:Validator}
{\xe \v Validator\:group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::group () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2481} of file {\b testlib.h}.}\par
}
{\xe \v ignoreMaxBound\:Validator}
{\xe \v Validator\:ignoreMaxBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} Validator::ignoreMaxBound ({\b const} std::string &  {\i variableName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2543} of file {\b testlib.h}.}\par
}
{\xe \v ignoreMinBound\:Validator}
{\xe \v Validator\:ignoreMinBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} Validator::ignoreMinBound ({\b const} std::string &  {\i variableName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2539} of file {\b testlib.h}.}\par
}
{\xe \v initialize\:Validator}
{\xe \v Validator\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2471} of file {\b testlib.h}.}\par
}
{\xe \v prepVariableName\:Validator}
{\xe \v Validator\:prepVariableName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::prepVariableName ({\b const} std::string &  {\i variableName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2527} of file {\b testlib.h}.}\par
}
{\xe \v setGroup\:Validator}
{\xe \v Validator\:setGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setGroup ({\b const} {\b char} *{\b const}  {\i group}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2507} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:Validator}
{\xe \v Validator\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setTestCase ({\b int}  {\i testCase}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2519} of file {\b testlib.h}.}\par
}
{\xe \v setTestCaseFileName\:Validator}
{\xe \v Validator\:setTestCaseFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setTestCaseFileName ({\b const} {\b char} *{\b const}  {\i testCaseFileName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2523} of file {\b testlib.h}.}\par
}
{\xe \v setTestMarkupFileName\:Validator}
{\xe \v Validator\:setTestMarkupFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setTestMarkupFileName ({\b const} {\b char} *{\b const}  {\i testMarkupFileName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2515} of file {\b testlib.h}.}\par
}
{\xe \v setTestOverviewLogFileName\:Validator}
{\xe \v Validator\:setTestOverviewLogFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setTestOverviewLogFileName ({\b const} {\b char} *{\b const}  {\i testOverviewLogFileName}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2511} of file {\b testlib.h}.}\par
}
{\xe \v setTestset\:Validator}
{\xe \v Validator\:setTestset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::setTestset ({\b const} {\b char} *{\b const}  {\i testset}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2503} of file {\b testlib.h}.}\par
}
{\xe \v testCase\:Validator}
{\xe \v Validator\:testCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Validator::testCase () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2495} of file {\b testlib.h}.}\par
}
{\xe \v testCaseFileName\:Validator}
{\xe \v Validator\:testCaseFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::testCaseFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2499} of file {\b testlib.h}.}\par
}
{\xe \v testMarkupFileName\:Validator}
{\xe \v Validator\:testMarkupFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::testMarkupFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2491} of file {\b testlib.h}.}\par
}
{\xe \v testOverviewLogFileName\:Validator}
{\xe \v Validator\:testOverviewLogFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::testOverviewLogFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2487} of file {\b testlib.h}.}\par
}
{\xe \v testset\:Validator}
{\xe \v Validator\:testset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Validator::testset () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2475} of file {\b testlib.h}.}\par
}
{\xe \v writeTestCase\:Validator}
{\xe \v Validator\:writeTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::writeTestCase (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2698} of file {\b testlib.h}.}\par
}
{\xe \v writeTestMarkup\:Validator}
{\xe \v Validator\:writeTestMarkup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::writeTestMarkup (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2658} of file {\b testlib.h}.}\par
}
{\xe \v writeTestOverviewLog\:Validator}
{\xe \v Validator\:writeTestOverviewLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Validator::writeTestOverviewLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2630} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ValidatorBoundsHit Struct Reference\par \pard\plain 
{\tc\tcl2 \v ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit}
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\par
{
{\f2 #include <testlib.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ValidatorBoundsHit} (bool {\b minHit}=false, bool {\b maxHit}=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ValidatorBoundsHit} {\b merge} (const {\b ValidatorBoundsHit} &validatorBoundsHit, bool ignoreMinBound, bool ignoreMaxBound)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b minHit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b maxHit}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const double {\b EPS} = 1E-12\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 2384} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ValidatorBoundsHit\:ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit\:ValidatorBoundsHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ValidatorBoundsHit::ValidatorBoundsHit (bool  {\i minHit} = {\f2 false}, bool  {\i maxHit} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2389} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v merge\:ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit\:merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ValidatorBoundsHit} ValidatorBoundsHit::merge (const {\b ValidatorBoundsHit} &  {\i validatorBoundsHit}, bool  {\i ignoreMinBound}, bool  {\i ignoreMaxBound}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2392} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v EPS\:ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit\:EPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double ValidatorBoundsHit::EPS = 1E-12{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2385} of file {\b testlib.h}.}\par
}
{\xe \v maxHit\:ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit\:maxHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ValidatorBoundsHit::maxHit}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2387} of file {\b testlib.h}.}\par
}
{\xe \v minHit\:ValidatorBoundsHit}
{\xe \v ValidatorBoundsHit\:minHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ValidatorBoundsHit::minHit}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2386} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b testlib.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/checker.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/checker.cpp}
{\xe \v src/checker.cpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "testlib.h"}\par
{\f2 #include <bits/stdc++.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b prime} (int x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readAns} ({\b InStream} &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b n}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b has} [1010]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:checker.cpp}
{\xe \v checker.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b checker.cpp}.}\par
}
{\xe \v prime\:checker.cpp}
{\xe \v checker.cpp\:prime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool prime (int  {\i x})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b checker.cpp}.}\par
}
{\xe \v readAns\:checker.cpp}
{\xe \v checker.cpp\:readAns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int readAns ({\b InStream} &  {\i stream})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b checker.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v has\:checker.cpp}
{\xe \v checker.cpp\:has}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool has[1010]}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b checker.cpp}.}\par
}
{\xe \v n\:checker.cpp}
{\xe \v checker.cpp\:n}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int n}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b checker.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
checker.cpp\par \pard\plain 
{\tc\tcl2 \v src/checker.cpp}
{\xe \v src/checker.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "testlib.h"}\par
00002 {\cf21 #include <bits/stdc++.h>}\par
00003 \par
00004 {\cf17 using namespace }std;\par
00005 {\cf18 int} n;\par
00006 \par
00007 {\cf18 bool} has[1010];\par
00008 {\cf18 bool} prime({\cf18 int} x) \{\par
00009     {\cf19 if} (x == 1)\par
00010         {\cf19 return} {\cf17 false};\par
00011     {\cf19 for} ({\cf18 int} i = 2; i * i <= x; i++) \{\par
00012         {\cf19 if} (x % i == 0)\par
00013             {\cf19 return} {\cf17 false};\par
00014     \}\par
00015     {\cf19 return} {\cf17 true};\par
00016 \}\par
00017 {\cf18 int} readAns(InStream &stream) \{\par
00018     {\cf18 int} ans = stream.readInt(1, 1000);\par
00019     {\cf19 if} (has[ans] == 0)\par
00020         {\cf19 return} -1;\par
00021     {\cf19 if} (prime(ans) == 0)\par
00022         {\cf19 return} 0;\par
00023     {\cf19 return} 1;\par
00024 \}\par
00025 \par
00026 {\cf18 int} main({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
00027     registerTestlibCmd(argc, argv);\par
00028     {\cf18 int} n = inf.readInt();\par
00029     {\cf19 for} ({\cf18 int} i = 0; i < n; i++) \{\par
00030         {\cf18 int} x = inf.readInt();\par
00031         has[x] = 1;\par
00032     \}\par
00033     {\cf18 int} jans = readAns(ans);\par
00034     {\cf18 int} pans = readAns(ouf);\par
00035     {\cf19 if} (jans == 0)\par
00036         quitf(_fail, {\cf22 "Jury answer Incorrect, The number is not prime!!!"});\par
00037     {\cf19 if} (jans == -1)\par
00038         quitf(\par
00039             _fail,\par
00040             {\cf22 "Jury answer Incorrect, the number is not from the input array!!!"});\par
00041     {\cf19 if} (pans == 0)\par
00042         quitf(_wa, {\cf22 "participant answer Incorrect, The number is not prime."});\par
00043     {\cf19 if} (pans == -1)\par
00044         quitf(_wa,\par
00045               {\cf22 "participant answer Incorrect, the number is not from the input "}\par
00046               {\cf22 "array."});\par
00047     {\cf19 if} (!ans.seekEof())\par
00048         quitf(_fail, {\cf22 "Jury answer contain extra tokens!!!"});\par
00049     {\cf19 if} (!ouf.seekEof())\par
00050         quitf(_wa, {\cf22 "Participant answer contain extra tokens."});\par
00051     quitf(_ok, {\cf22 "Passed all tests."});\par
00052 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/defaultsol.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/defaultsol.cpp}
{\xe \v src/defaultsol.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <bits/stdc++.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ll}\~ long long\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ll} {\b fib} ({\b ll} {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ll\:defaultsol.cpp}
{\xe \v defaultsol.cpp\:ll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ll\~ long long}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b defaultsol.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fib\:defaultsol.cpp}
{\xe \v defaultsol.cpp\:fib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ll} fib ({\b ll}  {\i n})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b defaultsol.cpp}.}\par
}
{\xe \v main\:defaultsol.cpp}
{\xe \v defaultsol.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b defaultsol.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
defaultsol.cpp\par \pard\plain 
{\tc\tcl2 \v src/defaultsol.cpp}
{\xe \v src/defaultsol.cpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <bits/stdc++.h>}\par
00002 {\cf21 #define ll long long}\par
00003 \par
00004 {\cf17 using namespace }std;\par
00005 \par
00006 ll fib(ll n) \{\par
00007     {\cf19 if} (n <= 1) \{\par
00008         {\cf19 return} n;\par
00009     \}\par
00010     ll a = 0, b = 1, c;\par
00011     {\cf19 for} (ll i = 2; i <= n; i++) \{\par
00012         c = a + b;\par
00013         a = b;\par
00014         b = c;\par
00015     \}\par
00016     {\cf19 return} c;\par
00017 \}\par
00018 \par
00019 {\cf18 int} main() \{\par
00020     ll n, m;\par
00021 \par
00022     cin >> n >> m;\par
00023 \par
00024     cout << fib(n) % m << endl;\par
00025 \par
00026     {\cf19 return} 0;\par
00027 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fib.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/fib.cpp}
{\xe \v src/fib.cpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "fib.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ll} {\b fib} ({\b ll} {\b n})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fib\:fib.cpp}
{\xe \v fib.cpp\:fib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ll} fib ({\b ll}  {\i n})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b fib.cpp}.}\par
}
{\xe \v main\:fib.cpp}
{\xe \v fib.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b fib.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fib.cpp\par \pard\plain 
{\tc\tcl2 \v src/fib.cpp}
{\xe \v src/fib.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by Chaipat Jainan on 29/2/2024 AD.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "fib.h"}\par
00006 \par
00007 ll fib(ll n) \{\par
00008     {\cf19 if} (n <= 1)\par
00009         {\cf19 return} n;\par
00010 \par
00011     ll a = 0, b = 1, c;\par
00012     {\cf19 for} (ll i = 0; i < n - 1; i++) \{\par
00013         c = a + b;\par
00014         a = b;\par
00015         b = c;\par
00016     \}\par
00017 \par
00018     {\cf19 return} c;\par
00019 \}\par
00020 \par
00021 {\cf18 int} main() \{\par
00022     ll n;\par
00023     cin >> n;\par
00024     cout << fib(n) % 8 << endl;\par
00025     {\cf19 return} 0;\par
00026 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fib.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/fib.h}
{\xe \v src/fib.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b fib}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ll}\~ long long\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ll\:fib.h}
{\xe \v fib.h\:ll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ll\~ long long}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b fib.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fib.h\par \pard\plain 
{\tc\tcl2 \v src/fib.h}
{\xe \v src/fib.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by Chaipat Jainan on 29/2/2024 AD.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef COMPETITIVE_CONTEST_FIB_H}\par
00006 {\cf21 #define COMPETITIVE_CONTEST_FIB_H}\par
00007 \par
00008 {\cf21 #include <iostream>}\par
00009 \par
00010 {\cf21 #define ll long long}\par
00011 \par
00012 {\cf17 using namespace }std;\par
00013 \par
00014 {\cf17 class }fib \{\};\par
00015 \par
00016 {\cf21 #endif }{\cf20 // COMPETITIVE_CONTEST_FIB_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/generator.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/generator.cpp}
{\xe \v src/generator.cpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "generator.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:generator.cpp}
{\xe \v generator.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b generator.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
generator.cpp\par \pard\plain 
{\tc\tcl2 \v src/generator.cpp}
{\xe \v src/generator.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by Chaipat Jainan on 28/2/2024 AD.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "generator.h"}\par
00006 \par
00007 {\cf18 int} main() \{\par
00008 \par
00009     generator g = generator();\par
00010     g.gen_input_all();\par
00011     g.gen_output();\par
00012 \par
00013     {\cf19 return} 0;\par
00014 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/generator.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/generator.h}
{\xe \v src/generator.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fstream>}\par
{\f2 #include <iostream>}\par
{\f2 #include <random>}\par
{\f2 #include <string>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <vector>}\par
{\f2 #include "./officialsol.cpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b generator}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ll}\~ long long\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct stat {\b info}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ll\:generator.h}
{\xe \v generator.h\:ll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ll\~ long long}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b generator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v info\:generator.h}
{\xe \v generator.h\:info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct stat info}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b generator.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
generator.h\par \pard\plain 
{\tc\tcl2 \v src/generator.h}
{\xe \v src/generator.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by Chaipat Jainan on 28/2/2024 AD.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef COMPETITIVE_CONTEST_GENERATOR_H}\par
00006 {\cf21 #define COMPETITIVE_CONTEST_GENERATOR_H}\par
00007 \par
00008 {\cf21 #include <fstream>}\par
00009 {\cf21 #include <iostream>}\par
00010 {\cf21 #include <random>}\par
00011 {\cf21 #include <string>}\par
00012 {\cf21 #include <sys/stat.h>}\par
00013 {\cf21 #include <vector>}\par
00014 \par
00015 {\cf21 #include "./officialsol.cpp"}\par
00016 \par
00017 {\cf21 #define ll long long}\par
00018 \par
00019 {\cf17 using namespace }std;\par
00020 \par
00021 {\cf17 struct }stat info;\par
00022 \par
00023 {\cf17 class }generator \{\par
00024 \par
00025   {\cf17 private}:\par
00026     {\cf18 int} cases;\par
00027 \par
00028     {\cf17 inline} {\cf17 static} {\cf17 const} {\cf18 char} *input_folder = {\cf22 "../in/"};\par
00029     {\cf17 inline} {\cf17 static} {\cf17 const} {\cf18 char} *output_folder = {\cf22 "../out/"};\par
00030 \par
00031     {\cf17 const} {\cf18 string} output_extension = {\cf22 ".out"};\par
00032     {\cf17 const} {\cf18 string} input_extension = {\cf22 ".in"};\par
00033 \par
00034   {\cf17 public}:\par
00035     generator() : cases(0) \{\}\par
00036 \par
00037     {\cf18 void} gen_input(ll max_n = 1e14, ll max_m = 1e3) \{\par
00038         {\cf20 // Set random number generator seed for reproducibility}\par
00039         random_device rd;\par
00040         mt19937 gen(rd());\par
00041         uniform_int_distribution<ll> n_dist(1, max_n);\par
00042         uniform_int_distribution<ll> m_dist(2, max_m);\par
00043 \par
00044         {\cf20 // Generate 10 test cases}\par
00045         {\cf19 for} ({\cf18 int} i = 1; i <= 10; ++i) \{\par
00046             ll n = n_dist(gen);\par
00047             ll m = m_dist(gen);\par
00048 \par
00049             {\cf20 // Create and write to the output file}\par
00050             {\cf18 string} filename = input_folder + to_string(cases) + input_extension;\par
00051             ofstream outfile(filename);\par
00052             {\cf19 if} (!outfile.is_open()) \{\par
00053                 cerr << {\cf22 "Error: Could not open file "} << filename << endl;\par
00054                 exit(1);\par
00055             \}\par
00056             outfile << n << {\cf22 " "} << m << endl;\par
00057             outfile.close();\par
00058 \par
00059             cases++;\par
00060         \}\par
00061     \}\par
00062 \par
00063     {\cf18 void} gen_input_all() \{\par
00064         {\cf19 if} (stat(input_folder, &info) != 0) \{\par
00065             {\cf20 // create input folder}\par
00066             system({\cf22 "mkdir -p ../in"});\par
00067         \} {\cf19 else} {\cf19 if} (info.st_mode & S_IFDIR) \{\par
00068             {\cf20 // clear input folder}\par
00069             system({\cf22 "rm -rf ../in/*"});\par
00070             cout << {\cf22 "Input folder cleared!"} << endl;\par
00071         \}\par
00072 \par
00073         gen_input(1e3, 1e1);\par
00074         gen_input(1e6, 1e2);\par
00075         gen_input(1e9, 1e2);\par
00076         gen_input(1e12, 1e3);\par
00077         {\cf20 //    gen_input(cases, 1e14, 1e3);}\par
00078 \par
00079         cout << {\cf22 "Total "} << cases << {\cf22 " test cases generated!"} << endl;\par
00080     \}\par
00081 \par
00082     {\cf18 void} gen_output() \{\par
00083         {\cf20 // check output folder exists}\par
00084         {\cf19 if} (stat(output_folder, &info) != 0) \{\par
00085             {\cf20 // create output folder}\par
00086             system({\cf22 "mkdir -p ../out"});\par
00087         \} {\cf19 else} {\cf19 if} (info.st_mode & S_IFDIR) \{\par
00088             {\cf20 // clear output folder}\par
00089             system({\cf22 "rm -rf ../out/*"});\par
00090             cout << {\cf22 "Output folder cleared!"} << endl;\par
00091         \}\par
00092 \par
00093         {\cf19 for} ({\cf18 int} i = 0; i < cases; ++i) \{\par
00094             {\cf18 string} in = input_folder + to_string(i) + input_extension;\par
00095 \par
00096             ll n = 0, m = 0;\par
00097             ifstream infile(in);\par
00098 \par
00099             {\cf19 if} (!infile.is_open()) \{\par
00100                 cerr << {\cf22 "Error: Could not open file "} << in << endl;\par
00101                 exit(1);\par
00102             \} {\cf19 else} \{\par
00103                 infile >> n >> m;\par
00104             \}\par
00105 \par
00106             {\cf18 string} out = output_folder + to_string(i) + output_extension;\par
00107 \par
00108             ofstream outfile(out);\par
00109             {\cf19 if} (!outfile.is_open()) \{\par
00110                 cerr << {\cf22 "Error: Could not open file "} << out << endl;\par
00111                 exit(1);\par
00112             \}\par
00113 \par
00114             {\cf18 string} output = to_string(fib_fast(n, m));\par
00115             outfile << output << endl;\par
00116 \par
00117             outfile.close();\par
00118         \}\par
00119 \par
00120         cout << {\cf22 "Total "} << cases << {\cf22 " results generated!"} << endl;\par
00121     \}\par
00122 \};\par
00123 \par
00124 {\cf21 #endif }{\cf20 // COMPETITIVE_CONTEST_GENERATOR_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/officialsol.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/officialsol.cpp}
{\xe \v src/officialsol.cpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ll}\~ long long\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ll} {\b fib_fast} ({\b ll} {\b n}, {\b ll} m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ll\:officialsol.cpp}
{\xe \v officialsol.cpp\:ll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ll\~ long long}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b officialsol.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fib_fast\:officialsol.cpp}
{\xe \v officialsol.cpp\:fib_fast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ll} fib_fast ({\b ll}  {\i n}, {\b ll}  {\i m})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b officialsol.cpp}.}\par
}
{\xe \v main\:officialsol.cpp}
{\xe \v officialsol.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b officialsol.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
officialsol.cpp\par \pard\plain 
{\tc\tcl2 \v src/officialsol.cpp}
{\xe \v src/officialsol.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <iostream>}\par
00002 \par
00003 {\cf21 #define ll long long}\par
00004 \par
00005 ll fib_fast(ll n, ll m) \{\par
00006     {\cf19 if} (n <= 1)\par
00007         {\cf19 return} n;\par
00008 \par
00009     {\cf20 // Pisano period}\par
00010     ll remainder = 0;\par
00011 \par
00012     ll a = 0, b = 1, c;\par
00013     {\cf19 for} (ll i = 0; i < n - 1; i++) \{\par
00014         c = (a + b) % m;\par
00015         a = b;\par
00016         b = c;\par
00017         {\cf19 if} (a == 0 && b == 1) \{\par
00018             remainder = i + 1;\par
00019             {\cf19 break};\par
00020         \}\par
00021     \}\par
00022 \par
00023     ll new_n = n % remainder;\par
00024     {\cf19 if} (new_n <= 1)\par
00025         {\cf19 return} new_n;\par
00026 \par
00027     a = 0, b = 1, c = a + b;\par
00028     {\cf19 for} (ll i = 0; i < new_n - 1; i++) \{\par
00029         c = (a + b) % m;\par
00030         a = b;\par
00031         b = c;\par
00032     \}\par
00033 \par
00034     {\cf19 return} c % m;\par
00035 \}\par
00036 \par
00037 {\cf18 int} main() \{\par
00038     {\cf18 long} {\cf18 long} n, m;\par
00039     std::cin >> n >> m;\par
00040     {\cf20 // std::cout << get_fibonacci_huge_naive(n, m) << '\\n';}\par
00041     std::cout << fib_fast(n, m) << {\cf23 '\\n'};\par
00042 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/test.cpp}
{\xe \v src/test.cpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "testlib.h"}\par
{\f2 #include <bits/stdc++.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b prime} (int x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:test.cpp}
{\xe \v test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b test.cpp}.}\par
}
{\xe \v prime\:test.cpp}
{\xe \v test.cpp\:prime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool prime (int  {\i x})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b test.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test.cpp\par \pard\plain 
{\tc\tcl2 \v src/test.cpp}
{\xe \v src/test.cpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "testlib.h"}\par
00002 {\cf21 #include <bits/stdc++.h>}\par
00003 \par
00004 {\cf17 using namespace }std;\par
00005 {\cf18 bool} prime({\cf18 int} x) \{\par
00006     {\cf19 if} (x == 1)\par
00007         {\cf19 return} {\cf17 false};\par
00008     {\cf19 for} ({\cf18 int} i = 2; i * i <= x; i++) \{\par
00009         {\cf19 if} (x % i == 0)\par
00010             {\cf19 return} {\cf17 false};\par
00011     \}\par
00012     {\cf19 return} {\cf17 true};\par
00013 \}\par
00014 \par
00015 {\cf18 int} main({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
00016     registerGen(argc, argv, 1);\par
00017     {\cf18 int} min_n = atoi(argv[1]);\par
00018     {\cf18 int} max_n = atoi(argv[2]);\par
00019     {\cf18 int} n = rnd.next(min_n, max_n);\par
00020     cout << n << endl;\par
00021     vector<int> a(n);\par
00022     {\cf18 bool} has_prime = {\cf17 false};\par
00023     {\cf19 for} ({\cf18 int} i = 0; i < n; i++) \{\par
00024         a[i] = rnd.next(1, 1000);\par
00025         has_prime |= prime(a[i]);\par
00026     \}\par
00027     {\cf19 while} (!has_prime) \{\par
00028         {\cf18 int} x = rnd.next(1, 1000);\par
00029         has_prime |= prime(x);\par
00030         a[0] = x;\par
00031     \}\par
00032     shuffle(a.begin(), a.end());\par
00033     cout << a[0];\par
00034     {\cf19 for} ({\cf18 int} i = 1; i < n; i++) \{\par
00035         cout << {\cf22 " "} << a[i];\par
00036     \}\par
00037     cout << endl;\par
00038     {\cf19 return} 0;\par
00039 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/testlib.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/testlib.h}
{\xe \v src/testlib.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <climits>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <cctype>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <map>}\par
{\f2 #include <set>}\par
{\f2 #include <cmath>}\par
{\f2 #include <iterator>}\par
{\f2 #include <iostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstring>}\par
{\f2 #include <limits>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <functional>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b pattern}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b random_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputStreamReader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringInputStreamReader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FileInputStreamReader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BufferedFileInputStreamReader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ValidatorBoundsHit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ConstantBound}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ConstantBounds}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Validator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestlibFinalizeGuard}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Checker}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERSION}\~ "0.9.42-SNAPSHOT"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b random}\~ __random_deprecated\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WORD}\~ unsigned short\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LLONG_MIN}\~ (-9223372036854775807LL - 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ULLONG_MAX}\~ (18446744073709551615)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LF}\~ ((char)10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR}\~ ((char)13)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAB}\~ ((char)9)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPACE}\~ ((char)' ')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EOFC}\~ (255)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OK_EXIT_CODE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WA_EXIT_CODE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PE_EXIT_CODE}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL_EXIT_CODE}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DIRT_EXIT_CODE}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b POINTS_EXIT_CODE}\~ 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNEXPECTED_EOF_EXIT_CODE}\~ 8\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PC_BASE_EXIT_CODE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __TESTLIB_STATIC_ASSERT}(condition)\~ typedef void* __testlib_static_assert_type[(condition) ? 1 : -1]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b I64}\~ "%lld"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b U64}\~ "%llu"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NORETURN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FMT_TO_RESULT}(fmt,  cstr,  result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _pc}(exitCode)\~ ({\b TResult}({\b _partially} + (exitCode)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __testlib_readMany}(readMany,  readOne,  typeName,  space)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ensure}(cond)\~ __testlib_ensure(cond, "Condition failed: \\"" #cond "\\"")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STRINGIZE_DETAIL}(x)\~ #x\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STRINGIZE}(x)\~ {\b STRINGIZE_DETAIL}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ensure_ext}(cond)\~ __testlib_ensure(cond, "Line " STRINGIZE(__LINE__) ": Condition failed: \\"" #cond "\\"")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RAND_THROW_STATEMENT}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TMode} \{ {\b _input}
, {\b _output}
, {\b _answer}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TResult} \{ {\b _ok} = 0
, {\b _wa} = 1
, {\b _pe} = 2
, {\b _fail} = 3
, {\b _dirt} = 4
, {\b _points} = 5
, {\b _unexpected_eof} = 8
, {\b _partially} = 16
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TTestlibMode} \{ {\b _unknown}
, {\b _checker}
, {\b _validator}
, {\b _generator}
, {\b _interactor}
, {\b _scorer}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTestCase} (int testCase)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unsetTestCase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b upperCase} (std::string s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b lowerCase} (std::string s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b format} (const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b format} (const std::string fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doubleCompare} (double expected, double result, double MAX_DOUBLE_ERROR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b doubleDelta} (double expected, double result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > bool {\b isEof} (C c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > bool {\b isEoln} (C c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > bool {\b isBlanks} (C c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b trim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disableFinalizeGuard} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b resultExitCode} ({\b TResult} r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b halt} (int exitCode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quit} ({\b TResult} result, const std::string &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quit} ({\b TResult} result, const char *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b __testlib_quitp} (double points, const char *message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b __testlib_quitp} (int points, const char *message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitp} (float points, const std::string &message="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitp} (double points, const std::string &message="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitp} (long double points, const std::string &message="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitp} (int points, const std::string &message="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitpi} (const std::string &points_info, const std::string &message="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b NORETURN} void {\b quitp} (F points, const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b quitf} ({\b TResult} result, const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b quitif} (bool condition, {\b TResult} result, const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b __testlib_help} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getTestset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getGroup} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerGen} (int argc, char *argv[], int randomGeneratorVersion)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerGen} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAppesModeEncoding} (std::string {\b appesModeEncoding})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerInteraction} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerValidation} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerValidation} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFeature} (const std::string &{\b feature})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b feature} (const std::string &feature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerTestlibCmd} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerTestlib} (int argc,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ensuref} (bool cond, const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const char *{\b format},...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _RandomAccessIter > void {\b shuffle} (_RandomAccessIter __first, _RandomAccessIter __last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _RandomAccessIter > void {\b random_shuffle} (_RandomAccessIter, _RandomAccessIter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rand} () {\b RAND_THROW_STATEMENT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b srand} (unsigned int seed) {\b RAND_THROW_STATEMENT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startTest} (int test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b compress} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b englishEnding} (int x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _ForwardIterator , typename _Separator > std::string {\b join} (_ForwardIterator first, _ForwardIterator last, _Separator separator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _ForwardIterator > std::string {\b join} (_ForwardIterator first, _ForwardIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _Collection , typename _Separator > std::string {\b join} (const _Collection &collection, _Separator separator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename _Collection > std::string {\b join} (const _Collection &collection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b split} (const std::string &s, char separator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b split} (const std::string &s, const std::string &separators)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b tokenize} (const std::string &s, char separator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b tokenize} (const std::string &s, const std::string &separators)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b __testlib_expectedButFound} ({\b TResult} result, std::string expected, std::string found, const char *prepend)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b __testlib_expectedButFound} ({\b TResult} result, double expected, double found, const char *prepend)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b NORETURN} void {\b expectedButFound} ({\b TResult} result, T expected, T found, const char *prependFormat="",...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> {\b NORETURN} void {\b expectedButFound< std::string >} ({\b TResult} result, std::string expected, std::string found, const char *prependFormat,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> {\b NORETURN} void {\b expectedButFound< double >} ({\b TResult} result, double expected, double found, const char *prependFormat,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> {\b NORETURN} void {\b expectedButFound< const char * >} ({\b TResult} result, const char *expected, const char *found, const char *prependFormat,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> {\b NORETURN} void {\b expectedButFound< float >} ({\b TResult} result, float expected, float found, const char *prependFormat,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> {\b NORETURN} void {\b expectedButFound< long double >} ({\b TResult} result, long double expected, long double found, const char *prependFormat,...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b latestFeatures} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const long long {\b __TESTLIB_LONGLONG_MAX} = 9223372036854775807LL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b __TESTLIB_MAX_TEST_CASE} = 1073741823\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b __testlib_exitCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b __testlib_hasTestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b __testlib_testCase} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b outcomes} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InStream} {\b inf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InStream} {\b ouf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InStream} {\b ans}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b appesMode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b appesModeEncoding} = "windows-1251"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b resultName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b checkerName} = "untitled checker"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b random_t} {\b rnd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TTestlibMode} {\b testlibMode} = {\b _unknown}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b __testlib_points} = std::numeric_limits<float>::infinity()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const size_t {\b VALIDATOR_MAX_VARIABLE_COUNT} = 255\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Validator} {\b validator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestlibFinalizeGuard} {\b testlibFinalizeGuard}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::fstream {\b tout}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b __testlib_testset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b __testlib_group}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Checker} {\b checker}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __testlib_readMany\:testlib.h}
{\xe \v testlib.h\:__testlib_readMany}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __testlib_readMany( readMany,  readOne,  typeName,  space)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 if} (size < 0)                                                               \\\par
        quit(_fail, #readMany {\cf22 ": size should be non-negative."});                \\\par
    if (size > 100000000)                                                       \\\par
        quit(_fail, #readMany {\cf22 ": size should be at most 100000000."});           \\\par
                                                                                \\\par
    std::vector<typeName> result(size);                                         \\\par
    readManyIteration = indexBase;                                              \\\par
                                                                                \\\par
    for ({\cf18 int} i = 0; i < size; i++)                                              \\\par
    \{                                                                           \\\par
        result[i] = readOne;                                                    \\\par
        readManyIteration++;                                                    \\\par
        if (strict && space && i + 1 < size)                                              \\\par
            readSpace();                                                        \\\par
    \}                                                                           \\\par
                                                                                \\\par
    readManyIteration = NO_INDEX;                                               \\\par
    {\cf19 return} result;                                                              \\\par
}
{
Definition at line {\b 3436} of file {\b testlib.h}.}\par
}
{\xe \v __TESTLIB_STATIC_ASSERT\:testlib.h}
{\xe \v testlib.h\:__TESTLIB_STATIC_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __TESTLIB_STATIC_ASSERT( condition)\~ typedef void* __testlib_static_assert_type[(condition) ? 1 : -1]}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 299} of file {\b testlib.h}.}\par
}
{\xe \v _pc\:testlib.h}
{\xe \v testlib.h\:_pc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _pc( exitCode)\~ ({\b TResult}({\b _partially} + (exitCode)))}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1636} of file {\b testlib.h}.}\par
}
{\xe \v CR\:testlib.h}
{\xe \v testlib.h\:CR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR\~ ((char)13)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b testlib.h}.}\par
}
{\xe \v DIRT_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:DIRT_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DIRT_EXIT_CODE\~ 4}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 276} of file {\b testlib.h}.}\par
}
{\xe \v ensure\:testlib.h}
{\xe \v testlib.h\:ensure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ensure( cond)\~ __testlib_ensure(cond, "Condition failed: \\"" #cond "\\"")}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4908} of file {\b testlib.h}.}\par
}
{\xe \v ensure_ext\:testlib.h}
{\xe \v testlib.h\:ensure_ext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ensure_ext( cond)\~ __testlib_ensure(cond, "Line " STRINGIZE(__LINE__) ": Condition failed: \\"" #cond "\\"")}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4911} of file {\b testlib.h}.}\par
}
{\xe \v EOFC\:testlib.h}
{\xe \v testlib.h\:EOFC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EOFC\~ (255)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b testlib.h}.}\par
}
{\xe \v FAIL_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:FAIL_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL_EXIT_CODE\~ 3}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 268} of file {\b testlib.h}.}\par
}
{\xe \v FMT_TO_RESULT\:testlib.h}
{\xe \v testlib.h\:FMT_TO_RESULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FMT_TO_RESULT( fmt,  cstr,  result)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid             std::string result;                              \\\par
            if (__testlib_format_buffer_usage_count != 0)                                  \\\par
                __testlib_fail({\cf22 "FMT_TO_RESULT::__testlib_format_buffer_usage_count != 0"}); \\\par
            __testlib_format_buffer_usage_count++;                                         \\\par
            va_list ap;                                                                    \\\par
            va_start(ap, fmt);                                                             \\\par
            vsnprintf(__testlib_format_buffer, {\cf17 sizeof}(__testlib_format_buffer), cstr, ap); \\\par
            va_end(ap);                                                                    \\\par
            __testlib_format_buffer[{\cf17 sizeof}(__testlib_format_buffer) - 1] = 0;              \\\par
            result = std::string(__testlib_format_buffer);                                 \\\par
            __testlib_format_buffer_usage_count--;                                         \\\par
}
{
Definition at line {\b 321} of file {\b testlib.h}.}\par
}
{\xe \v I64\:testlib.h}
{\xe \v testlib.h\:I64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define I64\~ "%lld"}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 306} of file {\b testlib.h}.}\par
}
{\xe \v LF\:testlib.h}
{\xe \v testlib.h\:LF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LF\~ ((char)10)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 228} of file {\b testlib.h}.}\par
}
{\xe \v LLONG_MIN\:testlib.h}
{\xe \v testlib.h\:LLONG_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LLONG_MIN\~ (-9223372036854775807LL - 1)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b testlib.h}.}\par
}
{\xe \v NORETURN\:testlib.h}
{\xe \v testlib.h\:NORETURN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NORETURN}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 315} of file {\b testlib.h}.}\par
}
{\xe \v OK_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:OK_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OK_EXIT_CODE\~ 0}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 238} of file {\b testlib.h}.}\par
}
{\xe \v PC_BASE_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:PC_BASE_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PC_BASE_EXIT_CODE\~ 0}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b testlib.h}.}\par
}
{\xe \v PE_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:PE_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PE_EXIT_CODE\~ 2}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 258} of file {\b testlib.h}.}\par
}
{\xe \v POINTS_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:POINTS_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define POINTS_EXIT_CODE\~ 7}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 281} of file {\b testlib.h}.}\par
}
{\xe \v RAND_THROW_STATEMENT\:testlib.h}
{\xe \v testlib.h\:RAND_THROW_STATEMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RAND_THROW_STATEMENT}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4961} of file {\b testlib.h}.}\par
}
{\xe \v random\:testlib.h}
{\xe \v testlib.h\:random}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define random\~ __random_deprecated}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b testlib.h}.}\par
}
{\xe \v SPACE\:testlib.h}
{\xe \v testlib.h\:SPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPACE\~ ((char)' ')}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 231} of file {\b testlib.h}.}\par
}
{\xe \v STRINGIZE\:testlib.h}
{\xe \v testlib.h\:STRINGIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STRINGIZE( x)\~ {\b STRINGIZE_DETAIL}(x)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4910} of file {\b testlib.h}.}\par
}
{\xe \v STRINGIZE_DETAIL\:testlib.h}
{\xe \v testlib.h\:STRINGIZE_DETAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STRINGIZE_DETAIL( x)\~ #x}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4909} of file {\b testlib.h}.}\par
}
{\xe \v TAB\:testlib.h}
{\xe \v testlib.h\:TAB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAB\~ ((char)9)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b testlib.h}.}\par
}
{\xe \v U64\:testlib.h}
{\xe \v testlib.h\:U64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define U64\~ "%llu"}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b testlib.h}.}\par
}
{\xe \v ULLONG_MAX\:testlib.h}
{\xe \v testlib.h\:ULLONG_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ULLONG_MAX\~ (18446744073709551615)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b testlib.h}.}\par
}
{\xe \v UNEXPECTED_EOF_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:UNEXPECTED_EOF_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNEXPECTED_EOF_EXIT_CODE\~ 8}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b testlib.h}.}\par
}
{\xe \v VERSION\:testlib.h}
{\xe \v testlib.h\:VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERSION\~ "0.9.42-SNAPSHOT"}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b testlib.h}.}\par
}
{\xe \v WA_EXIT_CODE\:testlib.h}
{\xe \v testlib.h\:WA_EXIT_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WA_EXIT_CODE\~ 1}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b testlib.h}.}\par
}
{\xe \v WORD\:testlib.h}
{\xe \v testlib.h\:WORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WORD\~ unsigned short}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v TMode\:testlib.h}
{\xe \v testlib.h\:TMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b TMode}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _input\:testlib.h}
{\xe \v testlib.h\:_input}
{\qr _input{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\cell }{\cell }{\row }
{\xe \v _output\:testlib.h}
{\xe \v testlib.h\:_output}
{\qr _output{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\cell }{\cell }{\row }
{\xe \v _answer\:testlib.h}
{\xe \v testlib.h\:_answer}
{\qr _answer{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 1616} of file {\b testlib.h}.}\par
}
{\xe \v TResult\:testlib.h}
{\xe \v testlib.h\:TResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b TResult}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _ok\:testlib.h}
{\xe \v testlib.h\:_ok}
{\qr _ok{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\cell }{\cell }{\row }
{\xe \v _wa\:testlib.h}
{\xe \v testlib.h\:_wa}
{\qr _wa{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\cell }{\cell }{\row }
{\xe \v _pe\:testlib.h}
{\xe \v testlib.h\:_pe}
{\qr _pe{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\cell }{\cell }{\row }
{\xe \v _fail\:testlib.h}
{\xe \v testlib.h\:_fail}
{\qr _fail{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\cell }{\cell }{\row }
{\xe \v _dirt\:testlib.h}
{\xe \v testlib.h\:_dirt}
{\qr _dirt{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\cell }{\cell }{\row }
{\xe \v _points\:testlib.h}
{\xe \v testlib.h\:_points}
{\qr _points{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\cell }{\cell }{\row }
{\xe \v _unexpected_eof\:testlib.h}
{\xe \v testlib.h\:_unexpected_eof}
{\qr _unexpected_eof{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\cell }{\cell }{\row }
{\xe \v _partially\:testlib.h}
{\xe \v testlib.h\:_partially}
{\qr _partially{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 1621} of file {\b testlib.h}.}\par
}
{\xe \v TTestlibMode\:testlib.h}
{\xe \v testlib.h\:TTestlibMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b TTestlibMode}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _unknown\:testlib.h}
{\xe \v testlib.h\:_unknown}
{\qr _unknown{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\cell }{\cell }{\row }
{\xe \v _checker\:testlib.h}
{\xe \v testlib.h\:_checker}
{\qr _checker{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\cell }{\cell }{\row }
{\xe \v _validator\:testlib.h}
{\xe \v testlib.h\:_validator}
{\qr _validator{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\cell }{\cell }{\row }
{\xe \v _generator\:testlib.h}
{\xe \v testlib.h\:_generator}
{\qr _generator{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\cell }{\cell }{\row }
{\xe \v _interactor\:testlib.h}
{\xe \v testlib.h\:_interactor}
{\qr _interactor{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\cell }{\cell }{\row }
{\xe \v _scorer\:testlib.h}
{\xe \v testlib.h\:_scorer}
{\qr _scorer{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 1632} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __testlib_expectedButFound\:testlib.h}
{\xe \v testlib.h\:__testlib_expectedButFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void __testlib_expectedButFound ({\b TResult}  {\i result}, double  {\i expected}, double  {\i found}, const char *  {\i prepend})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5176} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_expectedButFound\:testlib.h}
{\xe \v testlib.h\:__testlib_expectedButFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void __testlib_expectedButFound ({\b TResult}  {\i result}, std::string  {\i expected}, std::string  {\i found}, const char *  {\i prepend})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5165} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_help\:testlib.h}
{\xe \v testlib.h\:__testlib_help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void __testlib_help ()}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4497} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_quitp\:testlib.h}
{\xe \v testlib.h\:__testlib_quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void __testlib_quitp (double  {\i points}, const char *  {\i message})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4419} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_quitp\:testlib.h}
{\xe \v testlib.h\:__testlib_quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void __testlib_quitp (int  {\i points}, const char *  {\i message})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4432} of file {\b testlib.h}.}\par
}
{\xe \v addFeature\:testlib.h}
{\xe \v testlib.h\:addFeature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addFeature (const std::string &  {\i feature})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4765} of file {\b testlib.h}.}\par
}
{\xe \v compress\:testlib.h}
{\xe \v testlib.h\:compress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string compress (const std::string &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5006} of file {\b testlib.h}.}\par
}
{\xe \v disableFinalizeGuard\:testlib.h}
{\xe \v testlib.h\:disableFinalizeGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void disableFinalizeGuard ()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2817} of file {\b testlib.h}.}\par
}
{\xe \v doubleCompare\:testlib.h}
{\xe \v testlib.h\:doubleCompare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doubleCompare (double  {\i expected}, double  {\i result}, double  {\i MAX_DOUBLE_ERROR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 482} of file {\b testlib.h}.}\par
}
{\xe \v doubleDelta\:testlib.h}
{\xe \v testlib.h\:doubleDelta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double doubleDelta (double  {\i expected}, double  {\i result}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 508} of file {\b testlib.h}.}\par
}
{\xe \v englishEnding\:testlib.h}
{\xe \v testlib.h\:englishEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string englishEnding (int  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5013} of file {\b testlib.h}.}\par
}
{\xe \v ensuref\:testlib.h}
{\xe \v testlib.h\:ensuref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ensuref (bool  {\i cond}, const char *  {\i format},   {\i ...}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4916} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound\:testlib.h}
{\xe \v testlib.h\:expectedButFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b NORETURN} void expectedButFound ({\b TResult}  {\i result}, T  {\i expected}, T  {\i found}, const char *  {\i prependFormat} = {\f2 ""},   {\i ...})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5186} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound< const char * >\:testlib.h}
{\xe \v testlib.h\:expectedButFound< const char * >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> {\b NORETURN} void {\b expectedButFound}< const char * > ({\b TResult}  {\i result}, const char *  {\i expected}, const char *  {\i found}, const char *  {\i prependFormat},   {\i ...})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5218} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound< double >\:testlib.h}
{\xe \v testlib.h\:expectedButFound< double >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> {\b NORETURN} void {\b expectedButFound}< double > ({\b TResult}  {\i result}, double  {\i expected}, double  {\i found}, const char *  {\i prependFormat},   {\i ...})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5207} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound< float >\:testlib.h}
{\xe \v testlib.h\:expectedButFound< float >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> {\b NORETURN} void {\b expectedButFound}< float > ({\b TResult}  {\i result}, float  {\i expected}, float  {\i found}, const char *  {\i prependFormat},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5229} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound< long double >\:testlib.h}
{\xe \v testlib.h\:expectedButFound< long double >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> {\b NORETURN} void {\b expectedButFound}< long double > ({\b TResult}  {\i result}, long double  {\i expected}, long double  {\i found}, const char *  {\i prependFormat},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5238} of file {\b testlib.h}.}\par
}
{\xe \v expectedButFound< std::string >\:testlib.h}
{\xe \v testlib.h\:expectedButFound< std::string >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> {\b NORETURN} void {\b expectedButFound}< std::string > ({\b TResult}  {\i result}, std::string  {\i expected}, std::string  {\i found}, const char *  {\i prependFormat},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5197} of file {\b testlib.h}.}\par
}
{\xe \v feature\:testlib.h}
{\xe \v testlib.h\:feature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void feature (const std::string &  {\i feature})}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4771} of file {\b testlib.h}.}\par
}
{\xe \v format\:testlib.h}
{\xe \v testlib.h\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string format (const char *  {\i fmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 436} of file {\b testlib.h}.}\par
}
{\xe \v format\:testlib.h}
{\xe \v testlib.h\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string format (const std::string  {\i fmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 441} of file {\b testlib.h}.}\par
}
{\xe \v getGroup\:testlib.h}
{\xe \v testlib.h\:getGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string getGroup ()}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4546} of file {\b testlib.h}.}\par
}
{\xe \v getTestset\:testlib.h}
{\xe \v testlib.h\:getTestset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string getTestset ()}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4540} of file {\b testlib.h}.}\par
}
{\xe \v halt\:testlib.h}
{\xe \v testlib.h\:halt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void halt (int  {\i exitCode})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2969} of file {\b testlib.h}.}\par
}
{\xe \v isBlanks\:testlib.h}
{\xe \v testlib.h\:isBlanks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > bool isBlanks (C  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1593} of file {\b testlib.h}.}\par
}
{\xe \v isEof\:testlib.h}
{\xe \v testlib.h\:isEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > bool isEof (C  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1583} of file {\b testlib.h}.}\par
}
{\xe \v isEoln\:testlib.h}
{\xe \v testlib.h\:isEoln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > bool isEoln (C  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1588} of file {\b testlib.h}.}\par
}
{\xe \v join\:testlib.h}
{\xe \v testlib.h\:join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _ForwardIterator > std::string join (_ForwardIterator  {\i first}, _ForwardIterator  {\i last})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5047} of file {\b testlib.h}.}\par
}
{\xe \v join\:testlib.h}
{\xe \v testlib.h\:join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _ForwardIterator , typename _Separator > std::string join (_ForwardIterator  {\i first}, _ForwardIterator  {\i last}, _Separator  {\i separator})}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5030} of file {\b testlib.h}.}\par
}
{\xe \v join\:testlib.h}
{\xe \v testlib.h\:join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _Collection > std::string join (const _Collection &  {\i collection})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5063} of file {\b testlib.h}.}\par
}
{\xe \v join\:testlib.h}
{\xe \v testlib.h\:join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _Collection , typename _Separator > std::string join (const _Collection &  {\i collection}, _Separator  {\i separator})}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5055} of file {\b testlib.h}.}\par
}
{\xe \v lowerCase\:testlib.h}
{\xe \v testlib.h\:lowerCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string lowerCase (std::string  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 426} of file {\b testlib.h}.}\par
}
{\xe \v quit\:testlib.h}
{\xe \v testlib.h\:quit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quit ({\b TResult}  {\i result}, const char *  {\i msg})}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4415} of file {\b testlib.h}.}\par
}
{\xe \v quit\:testlib.h}
{\xe \v testlib.h\:quit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quit ({\b TResult}  {\i result}, const std::string &  {\i msg})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4411} of file {\b testlib.h}.}\par
}
{\xe \v quitf\:testlib.h}
{\xe \v testlib.h\:quitf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitf ({\b TResult}  {\i result}, const char *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4482} of file {\b testlib.h}.}\par
}
{\xe \v quitif\:testlib.h}
{\xe \v testlib.h\:quitif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void quitif (bool  {\i condition}, {\b TResult}  {\i result}, const char *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4490} of file {\b testlib.h}.}\par
}
{\xe \v quitp\:testlib.h}
{\xe \v testlib.h\:quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitp (double  {\i points}, const std::string &  {\i message} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4449} of file {\b testlib.h}.}\par
}
{\xe \v quitp\:testlib.h}
{\xe \v testlib.h\:quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename F > {\b NORETURN} void quitp (F  {\i points}, const char *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4474} of file {\b testlib.h}.}\par
}
{\xe \v quitp\:testlib.h}
{\xe \v testlib.h\:quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitp (float  {\i points}, const std::string &  {\i message} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4445} of file {\b testlib.h}.}\par
}
{\xe \v quitp\:testlib.h}
{\xe \v testlib.h\:quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitp (int  {\i points}, const std::string &  {\i message} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4457} of file {\b testlib.h}.}\par
}
{\xe \v quitp\:testlib.h}
{\xe \v testlib.h\:quitp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitp (long double  {\i points}, const std::string &  {\i message} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4453} of file {\b testlib.h}.}\par
}
{\xe \v quitpi\:testlib.h}
{\xe \v testlib.h\:quitpi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void quitpi (const std::string &  {\i points_info}, const std::string &  {\i message} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4461} of file {\b testlib.h}.}\par
}
{\xe \v rand\:testlib.h}
{\xe \v testlib.h\:rand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rand ()}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4971} of file {\b testlib.h}.}\par
}
{\xe \v random_shuffle\:testlib.h}
{\xe \v testlib.h\:random_shuffle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _RandomAccessIter > void random_shuffle (_RandomAccessIter , _RandomAccessIter )}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4954} of file {\b testlib.h}.}\par
}
{\xe \v registerGen\:testlib.h}
{\xe \v testlib.h\:registerGen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerGen (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4605} of file {\b testlib.h}.}\par
}
{\xe \v registerGen\:testlib.h}
{\xe \v testlib.h\:registerGen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerGen (int  {\i argc}, char *  {\i argv}[], int  {\i randomGeneratorVersion})}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4566} of file {\b testlib.h}.}\par
}
{\xe \v registerInteraction\:testlib.h}
{\xe \v testlib.h\:registerInteraction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerInteraction (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4638} of file {\b testlib.h}.}\par
}
{\xe \v registerTestlib\:testlib.h}
{\xe \v testlib.h\:registerTestlib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerTestlib (int  {\i argc},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4876} of file {\b testlib.h}.}\par
}
{\xe \v registerTestlibCmd\:testlib.h}
{\xe \v testlib.h\:registerTestlibCmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerTestlibCmd (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4812} of file {\b testlib.h}.}\par
}
{\xe \v registerValidation\:testlib.h}
{\xe \v testlib.h\:registerValidation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerValidation ()}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4691} of file {\b testlib.h}.}\par
}
{\xe \v registerValidation\:testlib.h}
{\xe \v testlib.h\:registerValidation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void registerValidation (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4705} of file {\b testlib.h}.}\par
}
{\xe \v resultExitCode\:testlib.h}
{\xe \v testlib.h\:resultExitCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int resultExitCode ({\b TResult}  {\i r})}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2900} of file {\b testlib.h}.}\par
}
{\xe \v setAppesModeEncoding\:testlib.h}
{\xe \v testlib.h\:setAppesModeEncoding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setAppesModeEncoding (std::string  {\i appesModeEncoding})}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4614} of file {\b testlib.h}.}\par
}
{\xe \v setName\:testlib.h}
{\xe \v testlib.h\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setName (const char *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4930} of file {\b testlib.h}.}\par
}
{\xe \v setTestCase\:testlib.h}
{\xe \v testlib.h\:setTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setTestCase (int  {\i testCase})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2878} of file {\b testlib.h}.}\par
}
{\xe \v shuffle\:testlib.h}
{\xe \v testlib.h\:shuffle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename _RandomAccessIter > void shuffle (_RandomAccessIter  {\i __first}, _RandomAccessIter  {\i __last})}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4943} of file {\b testlib.h}.}\par
}
{\xe \v split\:testlib.h}
{\xe \v testlib.h\:split}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > split (const std::string &  {\i s}, char  {\i separator})}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits string s by character separator returning exactly k+1 items, where k is the number of separator occurrences. \par
}{
Definition at line {\b 5074} of file {\b testlib.h}.}\par
}
{\xe \v split\:testlib.h}
{\xe \v testlib.h\:split}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > split (const std::string &  {\i s}, const std::string &  {\i separators})}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits string s by character separators returning exactly k+1 items, where k is the number of separator occurrences. \par
}{
Definition at line {\b 5094} of file {\b testlib.h}.}\par
}
{\xe \v srand\:testlib.h}
{\xe \v testlib.h\:srand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void srand (unsigned int  {\i seed})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4989} of file {\b testlib.h}.}\par
}
{\xe \v startTest\:testlib.h}
{\xe \v testlib.h\:startTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void startTest (int  {\i test})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4997} of file {\b testlib.h}.}\par
}
{\xe \v tokenize\:testlib.h}
{\xe \v testlib.h\:tokenize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > tokenize (const std::string &  {\i s}, char  {\i separator})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits string s by character separator returning non-empty items. \par
}{
Definition at line {\b 5120} of file {\b testlib.h}.}\par
}
{\xe \v tokenize\:testlib.h}
{\xe \v testlib.h\:tokenize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > tokenize (const std::string &  {\i s}, const std::string &  {\i separators})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits string s by character separators returning non-empty items. \par
}{
Definition at line {\b 5141} of file {\b testlib.h}.}\par
}
{\xe \v trim\:testlib.h}
{\xe \v testlib.h\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string trim (const std::string &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1597} of file {\b testlib.h}.}\par
}
{\xe \v unsetTestCase\:testlib.h}
{\xe \v testlib.h\:unsetTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void unsetTestCase ()}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 343} of file {\b testlib.h}.}\par
}
{\xe \v upperCase\:testlib.h}
{\xe \v testlib.h\:upperCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string upperCase (std::string  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b testlib.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __testlib_exitCode\:testlib.h}
{\xe \v testlib.h\:__testlib_exitCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __testlib_exitCode}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_group\:testlib.h}
{\xe \v testlib.h\:__testlib_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string __testlib_group}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4544} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_hasTestCase\:testlib.h}
{\xe \v testlib.h\:__testlib_hasTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool __testlib_hasTestCase}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 338} of file {\b testlib.h}.}\par
}
{\xe \v __TESTLIB_LONGLONG_MAX\:testlib.h}
{\xe \v testlib.h\:__TESTLIB_LONGLONG_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const long long __TESTLIB_LONGLONG_MAX = 9223372036854775807LL}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 333} of file {\b testlib.h}.}\par
}
{\xe \v __TESTLIB_MAX_TEST_CASE\:testlib.h}
{\xe \v testlib.h\:__TESTLIB_MAX_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int __TESTLIB_MAX_TEST_CASE = 1073741823}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_points\:testlib.h}
{\xe \v testlib.h\:__testlib_points}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double __testlib_points = std::numeric_limits<float>::infinity()}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2380} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_testCase\:testlib.h}
{\xe \v testlib.h\:__testlib_testCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __testlib_testCase = -1}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 339} of file {\b testlib.h}.}\par
}
{\xe \v __testlib_testset\:testlib.h}
{\xe \v testlib.h\:__testlib_testset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string __testlib_testset}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4538} of file {\b testlib.h}.}\par
}
{\xe \v ans\:testlib.h}
{\xe \v testlib.h\:ans}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InStream} ans}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2373} of file {\b testlib.h}.}\par
}
{\xe \v appesMode\:testlib.h}
{\xe \v testlib.h\:appesMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool appesMode}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2374} of file {\b testlib.h}.}\par
}
{\xe \v appesModeEncoding\:testlib.h}
{\xe \v testlib.h\:appesModeEncoding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string appesModeEncoding = "windows-1251"}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2375} of file {\b testlib.h}.}\par
}
{\xe \v checker\:testlib.h}
{\xe \v testlib.h\:checker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
class {\b Checker} checker}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v checkerName\:testlib.h}
{\xe \v testlib.h\:checkerName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string checkerName = "untitled checker"}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2377} of file {\b testlib.h}.}\par
}
{\xe \v inf\:testlib.h}
{\xe \v testlib.h\:inf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InStream} inf}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2371} of file {\b testlib.h}.}\par
}
{\xe \v latestFeatures\:testlib.h}
{\xe \v testlib.h\:latestFeatures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* latestFeatures[]}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b testlib.h}.}\par
}
{\xe \v ouf\:testlib.h}
{\xe \v testlib.h\:ouf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InStream} ouf}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2372} of file {\b testlib.h}.}\par
}
{\xe \v outcomes\:testlib.h}
{\xe \v testlib.h\:outcomes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string outcomes[]}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
        {\cf22 "accepted"},\par
        {\cf22 "wrong-answer"},\par
        {\cf22 "presentation-error"},\par
        {\cf22 "fail"},\par
        {\cf22 "fail"},\par
\par
        {\cf22 "points"},\par
\par
\par
\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "unexpected-eof"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "reserved"},\par
        {\cf22 "partially-correct"}\par
\}\par
}
{
Definition at line {\b 1639} of file {\b testlib.h}.}\par
}
{\xe \v resultName\:testlib.h}
{\xe \v testlib.h\:resultName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string resultName}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2376} of file {\b testlib.h}.}\par
}
{\xe \v rnd\:testlib.h}
{\xe \v testlib.h\:rnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b random_t} rnd}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2378} of file {\b testlib.h}.}\par
}
{\xe \v testlibFinalizeGuard\:testlib.h}
{\xe \v testlib.h\:testlibFinalizeGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestlibFinalizeGuard} testlibFinalizeGuard{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v testlibMode\:testlib.h}
{\xe \v testlib.h\:testlibMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TTestlibMode} testlibMode = {\b _unknown}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2379} of file {\b testlib.h}.}\par
}
{\xe \v tout\:testlib.h}
{\xe \v testlib.h\:tout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::fstream tout}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2823} of file {\b testlib.h}.}\par
}
{\xe \v validator\:testlib.h}
{\xe \v testlib.h\:validator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
class {\b Validator} validator}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VALIDATOR_MAX_VARIABLE_COUNT\:testlib.h}
{\xe \v testlib.h\:VALIDATOR_MAX_VARIABLE_COUNT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t VALIDATOR_MAX_VARIABLE_COUNT = 255}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2382} of file {\b testlib.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
testlib.h\par \pard\plain 
{\tc\tcl2 \v src/testlib.h}
{\xe \v src/testlib.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * It is strictly recommended to include "testlib.h" before any other include}\par
00003 {\cf20  * in your code. In this case testlib overrides compiler specific "random()".}\par
00004 {\cf20  *}\par
00005 {\cf20  * If you can't compile your code and compiler outputs something about}\par
00006 {\cf20  * ambiguous call of "random_shuffle", "rand" or "srand" it means that}\par
00007 {\cf20  * you shouldn't use them. Use "shuffle", and "rnd.next()" instead of them}\par
00008 {\cf20  * because these calls produce stable result for any C++ compiler. Read}\par
00009 {\cf20  * sample generator sources for clarification.}\par
00010 {\cf20  *}\par
00011 {\cf20  * Please read the documentation for class "random_t" and use "rnd" instance in}\par
00012 {\cf20  * generators. Probably, these sample calls will be useful for you:}\par
00013 {\cf20  *              rnd.next(); rnd.next(100); rnd.next(1, 2);}\par
00014 {\cf20  *              rnd.next(3.14); rnd.next("[a-z]\{1,100\}").}\par
00015 {\cf20  *}\par
00016 {\cf20  * Also read about wnext() to generate off-center random distribution.}\par
00017 {\cf20  *}\par
00018 {\cf20  * See https://github.com/MikeMirzayanov/testlib/ to get latest version or bug tracker.}\par
00019 {\cf20  */}\par
00020 \par
00021 {\cf21 #ifndef _TESTLIB_H_}\par
00022 {\cf21 #define _TESTLIB_H_}\par
00023 \par
00024 {\cf20 /*}\par
00025 {\cf20  * Copyright (c) 2005-2024}\par
00026 {\cf20  */}\par
00027 \par
00028 {\cf21 #define VERSION "0.9.42-SNAPSHOT"}\par
00029 \par
00030 {\cf20 /*}\par
00031 {\cf20  * Mike Mirzayanov}\par
00032 {\cf20  *}\par
00033 {\cf20  * This material is provided "as is", with absolutely no warranty expressed}\par
00034 {\cf20  * or implied. Any use is at your own risk.}\par
00035 {\cf20  *}\par
00036 {\cf20  * Permission to use or copy this software for any purpose is hereby granted}\par
00037 {\cf20  * without fee, provided the above notices are retained on all copies.}\par
00038 {\cf20  * Permission to modify the code and to distribute modified code is granted,}\par
00039 {\cf20  * provided the above notices are retained, and a notice that the code was}\par
00040 {\cf20  * modified is included with the above copyright notice.}\par
00041 {\cf20  *}\par
00042 {\cf20  */}\par
00043 \par
00044 {\cf20 /* NOTE: This file contains testlib library for C++.}\par
00045 {\cf20  *}\par
00046 {\cf20  *   Check, using testlib running format:}\par
00047 {\cf20  *     check.exe <Input_File> <Output_File> <Answer_File> [<Result_File> [-appes]],}\par
00048 {\cf20  *   If result file is specified it will contain results.}\par
00049 {\cf20  *}\par
00050 {\cf20  *   Validator, using testlib running format:}\par
00051 {\cf20  *     validator.exe < input.txt,}\par
00052 {\cf20  *   It will return non-zero exit code and writes message to standard output.}\par
00053 {\cf20  *}\par
00054 {\cf20  *   Generator, using testlib running format:}\par
00055 {\cf20  *     gen.exe [parameter-1] [parameter-2] [... paramerter-n]}\par
00056 {\cf20  *   You can write generated test(s) into standard output or into the file(s).}\par
00057 {\cf20  *}\par
00058 {\cf20  *   Interactor, using testlib running format:}\par
00059 {\cf20  *     interactor.exe <Input_File> <Output_File> [<Answer_File> [<Result_File> [-appes]]],}\par
00060 {\cf20  *   Reads test from inf (mapped to args[1]), writes result to tout (mapped to argv[2],}\par
00061 {\cf20  *   can be judged by checker later), reads program output from ouf (mapped to stdin),}\par
00062 {\cf20  *   writes output to program via stdout (use cout, printf, etc).}\par
00063 {\cf20  */}\par
00064 \par
00065 {\cf17 const} {\cf18 char} *latestFeatures[] = \{\par
00066         {\cf22 "Added ConstantBoundsLog, VariablesLog to validator testOverviewLogFile"},\par
00067         {\cf22 "Use setAppesModeEncoding to change xml encoding from windows-1251 to other"},\par
00068         {\cf22 "rnd.any/wany use distance/advance instead of -/+: now they support sets/multisets"},\par
00069         {\cf22 "Use syntax `int t = inf.readInt(1, 3, \\"~t\\");` to skip the lower bound check. Tildes can be used on either side or both: ~t, t~, ~t~"},\par
00070         {\cf22 "Supported EJUDGE support in registerTestlibCmd"},\par
00071         {\cf22 "Supported '--testMarkupFileName fn' and '--testCase tc/--testCaseFileName fn' for validators"},\par
00072         {\cf22 "Added opt defaults via opt<T>(key/index, default_val); check unused opts when using has_opt or default opt (turn off this check with suppressEnsureNoUnusedOpt())."},\par
00073         {\cf22 "For checker added --group and --testset command line params (like for validator), use checker.group() or checker.testset() to get values"},\par
00074         {\cf22 "Added quitpi(points_info, message) function to return with _points exit code 7 and given points_info"},\par
00075         {\cf22 "rnd.partition(size, sum[, min_part=1]) returns random (unsorted) partition which is a representation of the given `sum` as a sum of `size` positive integers (or >=min_part if specified)"},\par
00076         {\cf22 "rnd.distinct(size, n) and rnd.distinct(size, from, to)"},\par
00077         {\cf22 "opt<bool>(\\"some_missing_key\\") returns false now"},\par
00078         {\cf22 "has_opt(key)"},\par
00079         {\cf22 "Abort validator on validator.testset()/validator.group() if registered without using command line"},\par
00080         {\cf22 "Print integer range violations in a human readable way like `violates the range [1, 10^9]`"},\par
00081         {\cf22 "Opts supported: use them like n = opt<int>(\\"n\\"), in a command line you can use an exponential notation"},\par
00082         {\cf22 "Reformatted"},\par
00083         {\cf22 "Use setTestCase(i) or unsetTestCase() to support test cases (you can use it in any type of program: generator, interactor, validator or checker)"},\par
00084         {\cf22 "Fixed issue #87: readStrictDouble accepts \\"-0.00\\""},\par
00085         {\cf22 "Fixed issue #83: added InStream::quitif(condition, ...)"},\par
00086         {\cf22 "Fixed issue #79: fixed missed guard against repeated header include"},\par
00087         {\cf22 "Fixed issue #80: fixed UB in case of huge quitf message"},\par
00088         {\cf22 "Fixed issue #84: added readXs(size, indexBase = 1)"},\par
00089         {\cf22 "Fixed stringstream repeated usage issue"},\par
00090         {\cf22 "Fixed compilation in g++ (for std=c++03)"},\par
00091         {\cf22 "Batch of println functions (support collections, iterator ranges)"},\par
00092         {\cf22 "Introduced rnd.perm(size, first = 0) to generate a `first`-indexed permutation"},\par
00093         {\cf22 "Allow any whitespace in readInts-like functions for non-validators"},\par
00094         {\cf22 "Ignore 4+ command line arguments ifdef EJUDGE"},\par
00095         {\cf22 "Speed up of vtos"},\par
00096         {\cf22 "Show line number in validators in case of incorrect format"},\par
00097         {\cf22 "Truncate huge checker/validator/interactor message"},\par
00098         {\cf22 "Fixed issue with readTokenTo of very long tokens, now aborts with _pe/_fail depending of a stream type"},\par
00099         {\cf22 "Introduced InStream::ensure/ensuref checking a condition, returns wa/fail depending of a stream type"},\par
00100         {\cf22 "Fixed compilation in VS 2015+"},\par
00101         {\cf22 "Introduced space-separated read functions: readWords/readTokens, multilines read functions: readStrings/readLines"},\par
00102         {\cf22 "Introduced space-separated read functions: readInts/readIntegers/readLongs/readUnsignedLongs/readDoubles/readReals/readStrictDoubles/readStrictReals"},\par
00103         {\cf22 "Introduced split/tokenize functions to separate string by given char"},\par
00104         {\cf22 "Introduced InStream::readUnsignedLong and InStream::readLong with unsigned long long parameters"},\par
00105         {\cf22 "Supported --testOverviewLogFileName for validator: bounds hits + features"},\par
00106         {\cf22 "Fixed UB (sequence points) in random_t"},\par
00107         {\cf22 "POINTS_EXIT_CODE returned back to 7 (instead of 0)"},\par
00108         {\cf22 "Removed disable buffers for interactive problems, because it works unexpectedly in wine"},\par
00109         {\cf22 "InStream over string: constructor of InStream from base InStream to inherit policies and std::string"},\par
00110         {\cf22 "Added expectedButFound quit function, examples: expectedButFound(_wa, 10, 20), expectedButFound(_fail, ja, pa, \\"[n=%d,m=%d]\\", n, m)"},\par
00111         {\cf22 "Fixed incorrect interval parsing in patterns"},\par
00112         {\cf22 "Use registerGen(argc, argv, 1) to develop new generator, use registerGen(argc, argv, 0) to compile old generators (originally created for testlib under 0.8.7)"},\par
00113         {\cf22 "Introduced disableFinalizeGuard() to switch off finalization checkings"},\par
00114         {\cf22 "Use join() functions to format a range of items as a single string (separated by spaces or other separators)"},\par
00115         {\cf22 "Use -DENABLE_UNEXPECTED_EOF to enable special exit code (by default, 8) in case of unexpected eof. It is good idea to use it in interactors"},\par
00116         {\cf22 "Use -DUSE_RND_AS_BEFORE_087 to compile in compatibility mode with random behavior of versions before 0.8.7"},\par
00117         {\cf22 "Fixed bug with nan in stringToDouble"},\par
00118         {\cf22 "Fixed issue around overloads for size_t on x64"},\par
00119         {\cf22 "Added attribute 'points' to the XML output in case of result=_points"},\par
00120         {\cf22 "Exit codes can be customized via macros, e.g. -DPE_EXIT_CODE=14"},\par
00121         {\cf22 "Introduced InStream function readWordTo/readTokenTo/readStringTo/readLineTo for faster reading"},\par
00122         {\cf22 "Introduced global functions: format(), englishEnding(), upperCase(), lowerCase(), compress()"},\par
00123         {\cf22 "Manual buffer in InStreams, some IO speed improvements"},\par
00124         {\cf22 "Introduced quitif(bool, const char* pattern, ...) which delegates to quitf() in case of first argument is true"},\par
00125         {\cf22 "Introduced guard against missed quitf() in checker or readEof() in validators"},\par
00126         {\cf22 "Supported readStrictReal/readStrictDouble - to use in validators to check strictly float numbers"},\par
00127         {\cf22 "Supported registerInteraction(argc, argv)"},\par
00128         {\cf22 "Print checker message to the stderr instead of stdout"},\par
00129         {\cf22 "Supported TResult _points to output calculated score, use quitp(...) functions"},\par
00130         {\cf22 "Fixed to be compilable on Mac"},\par
00131         {\cf22 "PC_BASE_EXIT_CODE=50 in case of defined TESTSYS"},\par
00132         {\cf22 "Fixed issues 19-21, added __attribute__ format printf"},\par
00133         {\cf22 "Some bug fixes"},\par
00134         {\cf22 "ouf.readInt(1, 100) and similar calls return WA"},\par
00135         {\cf22 "Modified random_t to avoid integer overflow"},\par
00136         {\cf22 "Truncated checker output [patch by Stepan Gatilov]"},\par
00137         {\cf22 "Renamed class random -> class random_t"},\par
00138         {\cf22 "Supported name parameter for read-and-validation methods, like readInt(1, 2, \\"n\\")"},\par
00139         {\cf22 "Fixed bug in readDouble()"},\par
00140         {\cf22 "Improved ensuref(), fixed nextLine to work in case of EOF, added startTest()"},\par
00141         {\cf22 "Supported \\"partially correct\\", example: quitf(_pc(13), \\"result=%d\\", result)"},\par
00142         {\cf22 "Added shuffle(begin, end), use it instead of random_shuffle(begin, end)"},\par
00143         {\cf22 "Added readLine(const string& ptrn), fixed the logic of readLine() in the validation mode"},\par
00144         {\cf22 "Package extended with samples of generators and validators"},\par
00145         {\cf22 "Written the documentation for classes and public methods in testlib.h"},\par
00146         {\cf22 "Implemented random routine to support generators, use registerGen() to switch it on"},\par
00147         {\cf22 "Implemented strict mode to validate tests, use registerValidation() to switch it on"},\par
00148         {\cf22 "Now ncmp.cpp and wcmp.cpp are return WA if answer is suffix or prefix of the output"},\par
00149         {\cf22 "Added InStream::readLong() and removed InStream::readLongint()"},\par
00150         {\cf22 "Now no footer added to each report by default (use directive FOOTER to switch on)"},\par
00151         {\cf22 "Now every checker has a name, use setName(const char* format, ...) to set it"},\par
00152         {\cf22 "Now it is compatible with TTS (by Kittens Computing)"},\par
00153         {\cf22 "Added \\'ensure(condition, message = \\"\\")\\' feature, it works like assert()"},\par
00154         {\cf22 "Fixed compatibility with MS C++ 7.1"},\par
00155         {\cf22 "Added footer with exit code information"},\par
00156         {\cf22 "Added compatibility with EJUDGE (compile with EJUDGE directive)"},\par
00157         {\cf22 "Added compatibility with Contester (compile with CONTESTER directive)"}\par
00158 \};\par
00159 \par
00160 {\cf21 #ifdef _MSC_VER}\par
00161 {\cf21 #define _CRT_SECURE_NO_DEPRECATE}\par
00162 {\cf21 #define _CRT_SECURE_NO_WARNINGS}\par
00163 {\cf21 #define _CRT_NO_VA_START_VALIDATION}\par
00164 {\cf21 #endif}\par
00165 \par
00166 {\cf20 /* Overrides random() for Borland C++. */}\par
00167 {\cf21 #define random __random_deprecated}\par
00168 {\cf21 #include <stdlib.h>}\par
00169 {\cf21 #include <cstdlib>}\par
00170 {\cf21 #include <climits>}\par
00171 {\cf21 #include <algorithm>}\par
00172 {\cf21 #undef random}\par
00173 \par
00174 {\cf21 #include <cstdio>}\par
00175 {\cf21 #include <cctype>}\par
00176 {\cf21 #include <string>}\par
00177 {\cf21 #include <vector>}\par
00178 {\cf21 #include <map>}\par
00179 {\cf21 #include <set>}\par
00180 {\cf21 #include <cmath>}\par
00181 {\cf21 #include <iterator>}\par
00182 {\cf21 #include <iostream>}\par
00183 {\cf21 #include <sstream>}\par
00184 {\cf21 #include <fstream>}\par
00185 {\cf21 #include <cstring>}\par
00186 {\cf21 #include <limits>}\par
00187 {\cf21 #include <stdarg.h>}\par
00188 {\cf21 #include <fcntl.h>}\par
00189 {\cf21 #include <functional>}\par
00190 {\cf21 #include <cstdint>}\par
00191 \par
00192 {\cf21 #ifdef TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT}\par
00193 {\cf21 #   include <exception>}\par
00194 {\cf21 #endif}\par
00195 \par
00196 {\cf21 #if (_WIN32 || __WIN32__ || __WIN32 || _WIN64 || __WIN64__ || __WIN64 || WINNT || __WINNT || __WINNT__ || __CYGWIN__)}\par
00197 {\cf21 #   if !defined(_MSC_VER) || _MSC_VER > 1400}\par
00198 {\cf21 #       define NOMINMAX 1}\par
00199 {\cf21 #       include <windows.h>}\par
00200 {\cf21 #   else}\par
00201 {\cf21 #       define WORD unsigned short}\par
00202 {\cf21 #       include <unistd.h>}\par
00203 {\cf21 #   endif}\par
00204 {\cf21 #   include <io.h>}\par
00205 {\cf21 #   define ON_WINDOWS}\par
00206 {\cf21 #   if defined(_MSC_VER) && _MSC_VER > 1400}\par
00207 {\cf21 #       pragma warning( disable : 4127 )}\par
00208 {\cf21 #       pragma warning( disable : 4146 )}\par
00209 {\cf21 #       pragma warning( disable : 4458 )}\par
00210 {\cf21 #   endif}\par
00211 {\cf21 #else}\par
00212 {\cf21 #   define WORD unsigned short}\par
00213 {\cf21 #   include <unistd.h>}\par
00214 {\cf21 #endif}\par
00215 \par
00216 {\cf21 #if defined(FOR_WINDOWS) && defined(FOR_LINUX)}\par
00217 {\cf21 #error Only one target system is allowed}\par
00218 {\cf21 #endif}\par
00219 \par
00220 {\cf21 #ifndef LLONG_MIN}\par
00221 {\cf21 #define LLONG_MIN   (-9223372036854775807LL - 1)}\par
00222 {\cf21 #endif}\par
00223 \par
00224 {\cf21 #ifndef ULLONG_MAX}\par
00225 {\cf21 #define ULLONG_MAX   (18446744073709551615)}\par
00226 {\cf21 #endif}\par
00227 \par
00228 {\cf21 #define LF ((char)10)}\par
00229 {\cf21 #define CR ((char)13)}\par
00230 {\cf21 #define TAB ((char)9)}\par
00231 {\cf21 #define SPACE ((char)' ')}\par
00232 {\cf21 #define EOFC (255)}\par
00233 \par
00234 {\cf21 #ifndef OK_EXIT_CODE}\par
00235 {\cf21 #   ifdef CONTESTER}\par
00236 {\cf21 #       define OK_EXIT_CODE 0xAC}\par
00237 {\cf21 #   else}\par
00238 {\cf21 #       define OK_EXIT_CODE 0}\par
00239 {\cf21 #   endif}\par
00240 {\cf21 #endif}\par
00241 \par
00242 {\cf21 #ifndef WA_EXIT_CODE}\par
00243 {\cf21 #   ifdef EJUDGE}\par
00244 {\cf21 #       define WA_EXIT_CODE 5}\par
00245 {\cf21 #   elif defined(CONTESTER)}\par
00246 {\cf21 #       define WA_EXIT_CODE 0xAB}\par
00247 {\cf21 #   else}\par
00248 {\cf21 #       define WA_EXIT_CODE 1}\par
00249 {\cf21 #   endif}\par
00250 {\cf21 #endif}\par
00251 \par
00252 {\cf21 #ifndef PE_EXIT_CODE}\par
00253 {\cf21 #   ifdef EJUDGE}\par
00254 {\cf21 #       define PE_EXIT_CODE 4}\par
00255 {\cf21 #   elif defined(CONTESTER)}\par
00256 {\cf21 #       define PE_EXIT_CODE 0xAA}\par
00257 {\cf21 #   else}\par
00258 {\cf21 #       define PE_EXIT_CODE 2}\par
00259 {\cf21 #   endif}\par
00260 {\cf21 #endif}\par
00261 \par
00262 {\cf21 #ifndef FAIL_EXIT_CODE}\par
00263 {\cf21 #   ifdef EJUDGE}\par
00264 {\cf21 #       define FAIL_EXIT_CODE 6}\par
00265 {\cf21 #   elif defined(CONTESTER)}\par
00266 {\cf21 #       define FAIL_EXIT_CODE 0xA3}\par
00267 {\cf21 #   else}\par
00268 {\cf21 #       define FAIL_EXIT_CODE 3}\par
00269 {\cf21 #   endif}\par
00270 {\cf21 #endif}\par
00271 \par
00272 {\cf21 #ifndef DIRT_EXIT_CODE}\par
00273 {\cf21 #   ifdef EJUDGE}\par
00274 {\cf21 #       define DIRT_EXIT_CODE 6}\par
00275 {\cf21 #   else}\par
00276 {\cf21 #       define DIRT_EXIT_CODE 4}\par
00277 {\cf21 #   endif}\par
00278 {\cf21 #endif}\par
00279 \par
00280 {\cf21 #ifndef POINTS_EXIT_CODE}\par
00281 {\cf21 #   define POINTS_EXIT_CODE 7}\par
00282 {\cf21 #endif}\par
00283 \par
00284 {\cf21 #ifndef UNEXPECTED_EOF_EXIT_CODE}\par
00285 {\cf21 #   define UNEXPECTED_EOF_EXIT_CODE 8}\par
00286 {\cf21 #endif}\par
00287 \par
00288 {\cf21 #ifndef PC_BASE_EXIT_CODE}\par
00289 {\cf21 #   ifdef TESTSYS}\par
00290 {\cf21 #       define PC_BASE_EXIT_CODE 50}\par
00291 {\cf21 #   else}\par
00292 {\cf21 #       define PC_BASE_EXIT_CODE 0}\par
00293 {\cf21 #   endif}\par
00294 {\cf21 #endif}\par
00295 \par
00296 {\cf21 #ifdef __GNUC__}\par
00297 {\cf21 #    define __TESTLIB_STATIC_ASSERT(condition) typedef void* __testlib_static_assert_type[(condition) ? 1 : -1] __attribute__((unused))}\par
00298 {\cf21 #else}\par
00299 {\cf21 #    define __TESTLIB_STATIC_ASSERT(condition) typedef void* __testlib_static_assert_type[(condition) ? 1 : -1]}\par
00300 {\cf21 #endif}\par
00301 \par
00302 {\cf21 #ifdef ON_WINDOWS}\par
00303 {\cf21 #define I64 "%I64d"}\par
00304 {\cf21 #define U64 "%I64u"}\par
00305 {\cf21 #else}\par
00306 {\cf21 #define I64 "%lld"}\par
00307 {\cf21 #define U64 "%llu"}\par
00308 {\cf21 #endif}\par
00309 \par
00310 {\cf21 #ifdef _MSC_VER}\par
00311 {\cf21 #   define NORETURN __declspec(noreturn)}\par
00312 {\cf21 #elif defined __GNUC__}\par
00313 {\cf21 #   define NORETURN __attribute__ ((noreturn))}\par
00314 {\cf21 #else}\par
00315 {\cf21 #   define NORETURN}\par
00316 {\cf21 #endif}\par
00317 \par
00318 {\cf17 static} {\cf18 char} __testlib_format_buffer[16777216];\par
00319 {\cf17 static} {\cf18 int} __testlib_format_buffer_usage_count = 0;\par
00320 \par
00321 {\cf21 #define FMT_TO_RESULT(fmt, cstr, result)  std::string result;                              \\}\par
00322 {\cf21             if (__testlib_format_buffer_usage_count != 0)                                  \\}\par
00323 {\cf21                 __testlib_fail("FMT_TO_RESULT::__testlib_format_buffer_usage_count != 0"); \\}\par
00324 {\cf21             __testlib_format_buffer_usage_count++;                                         \\}\par
00325 {\cf21             va_list ap;                                                                    \\}\par
00326 {\cf21             va_start(ap, fmt);                                                             \\}\par
00327 {\cf21             vsnprintf(__testlib_format_buffer, sizeof(__testlib_format_buffer), cstr, ap); \\}\par
00328 {\cf21             va_end(ap);                                                                    \\}\par
00329 {\cf21             __testlib_format_buffer[sizeof(__testlib_format_buffer) - 1] = 0;              \\}\par
00330 {\cf21             result = std::string(__testlib_format_buffer);                                 \\}\par
00331 {\cf21             __testlib_format_buffer_usage_count--;                                         \\}\par
00332 {\cf21 }\par
00333 {\cf17 const} {\cf18 long} {\cf18 long} __TESTLIB_LONGLONG_MAX = 9223372036854775807LL;\par
00334 {\cf17 const} {\cf18 int} __TESTLIB_MAX_TEST_CASE = 1073741823;\par
00335 \par
00336 {\cf18 int} __testlib_exitCode;\par
00337 \par
00338 {\cf18 bool} __testlib_hasTestCase;\par
00339 {\cf18 int} __testlib_testCase = -1;\par
00340 \par
00341 {\cf18 void} setTestCase({\cf18 int} testCase);\par
00342 \par
00343 {\cf18 void} unsetTestCase() \{\par
00344     __testlib_hasTestCase = {\cf17 false};\par
00345     __testlib_testCase = -1;\par
00346 \}\par
00347 \par
00348 NORETURN {\cf17 static} {\cf18 void} __testlib_fail({\cf17 const} std::string &message);\par
00349 \par
00350 {\cf17 template}<{\cf17 typename} T>\par
00351 {\cf21 #ifdef __GNUC__}\par
00352 __attribute__(({\cf17 const}))\par
00353 {\cf21 #endif}\par
00354 {\cf17 static} {\cf17 inline} T __testlib_abs({\cf17 const} T &x) \{\par
00355     {\cf19 return} x > 0 ? x : -x;\par
00356 \}\par
00357 \par
00358 {\cf17 template}<{\cf17 typename} T>\par
00359 {\cf21 #ifdef __GNUC__}\par
00360 __attribute__(({\cf17 const}))\par
00361 {\cf21 #endif}\par
00362 {\cf17 static} {\cf17 inline} T __testlib_min({\cf17 const} T &a, {\cf17 const} T &b) \{\par
00363     {\cf19 return} a < b ? a : b;\par
00364 \}\par
00365 \par
00366 {\cf17 template}<{\cf17 typename} T>\par
00367 {\cf21 #ifdef __GNUC__}\par
00368 __attribute__(({\cf17 const}))\par
00369 {\cf21 #endif}\par
00370 {\cf17 static} {\cf17 inline} T __testlib_max({\cf17 const} T &a, {\cf17 const} T &b) \{\par
00371     {\cf19 return} a > b ? a : b;\par
00372 \}\par
00373 \par
00374 {\cf17 template}<{\cf17 typename} T>\par
00375 {\cf21 #ifdef __GNUC__}\par
00376 __attribute__(({\cf17 const}))\par
00377 {\cf21 #endif}\par
00378 {\cf17 static} {\cf17 inline} T __testlib_crop(T value, T a, T b) \{\par
00379     {\cf19 return} __testlib_min(__testlib_max(value, a), --b);\par
00380 \}\par
00381 \par
00382 {\cf21 #ifdef __GNUC__}\par
00383 __attribute__(({\cf17 const}))\par
00384 {\cf21 #endif}\par
00385 {\cf17 static} {\cf17 inline} {\cf18 double} __testlib_crop({\cf18 double} value, {\cf18 double} a, {\cf18 double} b) \{\par
00386     value = __testlib_min(__testlib_max(value, a), b);\par
00387     {\cf19 if} (value >= b)\par
00388         value = std::nexttoward(b, a);\par
00389     {\cf19 return} value;\par
00390 \}\par
00391 \par
00392 {\cf17 static} {\cf18 bool} __testlib_prelimIsNaN({\cf18 double} r) \{\par
00393     {\cf17 volatile} {\cf18 double} ra = r;\par
00394 {\cf21 #ifndef __BORLANDC__}\par
00395     {\cf19 return} ((ra != ra) == {\cf17 true}) && ((ra == ra) == {\cf17 false}) && ((1.0 > ra) == {\cf17 false}) && ((1.0 < ra) == {\cf17 false});\par
00396 {\cf21 #else}\par
00397     {\cf19 return} std::_isnan(ra);\par
00398 {\cf21 #endif}\par
00399 \}\par
00400 \par
00401 {\cf21 #ifdef __GNUC__}\par
00402 __attribute__(({\cf17 const}))\par
00403 {\cf21 #endif}\par
00404 {\cf17 static} std::string removeDoubleTrailingZeroes(std::string value) \{\par
00405     {\cf19 while} (!value.empty() && value[value.length() - 1] == {\cf23 '0'} && value.find({\cf23 '.'}) != std::string::npos)\par
00406         value = value.substr(0, value.length() - 1);\par
00407     {\cf19 if} (!value.empty() && value[value.length() - 1] == {\cf23 '.'})\par
00408         {\cf19 return} value + {\cf23 '0'};\par
00409     {\cf19 else}\par
00410         {\cf19 return} value;\par
00411 \}\par
00412 \par
00413 {\cf21 #ifdef __GNUC__}\par
00414 __attribute__(({\cf17 const}))\par
00415 {\cf21 #endif}\par
00416 {\cf17 inline} std::string upperCase(std::string s) \{\par
00417     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
00418         {\cf19 if} ({\cf23 'a'} <= s[i] && s[i] <= {\cf23 'z'})\par
00419             s[i] = char(s[i] - {\cf23 'a'} + {\cf23 'A'});\par
00420     {\cf19 return} s;\par
00421 \}\par
00422 \par
00423 {\cf21 #ifdef __GNUC__}\par
00424 __attribute__(({\cf17 const}))\par
00425 {\cf21 #endif}\par
00426 {\cf17 inline} std::string lowerCase(std::string s) \{\par
00427     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
00428         {\cf19 if} ({\cf23 'A'} <= s[i] && s[i] <= {\cf23 'Z'})\par
00429             s[i] = char(s[i] - {\cf23 'A'} + {\cf23 'a'});\par
00430     {\cf19 return} s;\par
00431 \}\par
00432 \par
00433 {\cf21 #ifdef __GNUC__}\par
00434 __attribute__ ((format (printf, 1, 2)))\par
00435 {\cf21 #endif}\par
00436 std::string format({\cf17 const} {\cf18 char} *fmt, ...) \{\par
00437     FMT_TO_RESULT(fmt, fmt, result);\par
00438     {\cf19 return} result;\par
00439 \}\par
00440 \par
00441 std::string format({\cf17 const} std::string fmt, ...) \{\par
00442     FMT_TO_RESULT(fmt, fmt.c_str(), result);\par
00443     {\cf19 return} result;\par
00444 \}\par
00445 \par
00446 {\cf21 #ifdef __GNUC__}\par
00447 __attribute__(({\cf17 const}))\par
00448 {\cf21 #endif}\par
00449 {\cf17 static} std::string __testlib_part({\cf17 const} std::string &s);\par
00450 \par
00451 {\cf17 static} {\cf18 bool} __testlib_isNaN({\cf18 double} r) \{\par
00452     __TESTLIB_STATIC_ASSERT({\cf17 sizeof}({\cf18 double}) == {\cf17 sizeof}({\cf18 long} {\cf18 long}));\par
00453     {\cf17 volatile} {\cf18 double} ra = r;\par
00454     {\cf18 long} {\cf18 long} llr1, llr2;\par
00455     std::memcpy(({\cf18 void} *) &llr1, ({\cf18 void} *) &ra, {\cf17 sizeof}({\cf18 double}));\par
00456     ra = -ra;\par
00457     std::memcpy(({\cf18 void} *) &llr2, ({\cf18 void} *) &ra, {\cf17 sizeof}({\cf18 double}));\par
00458     {\cf18 long} {\cf18 long} llnan = 0xFFF8000000000000LL;\par
00459     {\cf19 return} __testlib_prelimIsNaN(r) || llnan == llr1 || llnan == llr2;\par
00460 \}\par
00461 \par
00462 {\cf17 static} {\cf18 double} __testlib_nan() \{\par
00463     __TESTLIB_STATIC_ASSERT({\cf17 sizeof}({\cf18 double}) == {\cf17 sizeof}({\cf18 long} {\cf18 long}));\par
00464 {\cf21 #ifndef NAN}\par
00465     {\cf18 long} {\cf18 long} llnan = 0xFFF8000000000000LL;\par
00466     {\cf18 double} nan;\par
00467     std::memcpy(&nan, &llnan, {\cf17 sizeof}({\cf18 double}));\par
00468     {\cf19 return} nan;\par
00469 {\cf21 #else}\par
00470     {\cf19 return} NAN;\par
00471 {\cf21 #endif}\par
00472 \}\par
00473 \par
00474 {\cf17 static} {\cf18 bool} __testlib_isInfinite({\cf18 double} r) \{\par
00475     {\cf17 volatile} {\cf18 double} ra = r;\par
00476     {\cf19 return} (ra > 1E300 || ra < -1E300);\par
00477 \}\par
00478 \par
00479 {\cf21 #ifdef __GNUC__}\par
00480 __attribute__(({\cf17 const}))\par
00481 {\cf21 #endif}\par
00482 {\cf17 inline} {\cf18 bool} doubleCompare({\cf18 double} expected, {\cf18 double} result, {\cf18 double} MAX_DOUBLE_ERROR) \{\par
00483     MAX_DOUBLE_ERROR += 1E-15;\par
00484     {\cf19 if} (__testlib_isNaN(expected)) \{\par
00485         {\cf19 return} __testlib_isNaN(result);\par
00486     \} {\cf19 else} {\cf19 if} (__testlib_isInfinite(expected)) \{\par
00487         {\cf19 if} (expected > 0) \{\par
00488             {\cf19 return} result > 0 && __testlib_isInfinite(result);\par
00489         \} {\cf19 else} \{\par
00490             {\cf19 return} result < 0 && __testlib_isInfinite(result);\par
00491         \}\par
00492     \} {\cf19 else} {\cf19 if} (__testlib_isNaN(result) || __testlib_isInfinite(result)) \{\par
00493         {\cf19 return} {\cf17 false};\par
00494     \} {\cf19 else} {\cf19 if} (__testlib_abs(result - expected) <= MAX_DOUBLE_ERROR) \{\par
00495         {\cf19 return} {\cf17 true};\par
00496     \} {\cf19 else} \{\par
00497         {\cf18 double} minv = __testlib_min(expected * (1.0 - MAX_DOUBLE_ERROR),\par
00498                                     expected * (1.0 + MAX_DOUBLE_ERROR));\par
00499         {\cf18 double} maxv = __testlib_max(expected * (1.0 - MAX_DOUBLE_ERROR),\par
00500                                     expected * (1.0 + MAX_DOUBLE_ERROR));\par
00501         {\cf19 return} result >= minv && result <= maxv;\par
00502     \}\par
00503 \}\par
00504 \par
00505 {\cf21 #ifdef __GNUC__}\par
00506 __attribute__(({\cf17 const}))\par
00507 {\cf21 #endif}\par
00508 {\cf17 inline} {\cf18 double} doubleDelta({\cf18 double} expected, {\cf18 double} result) \{\par
00509     {\cf18 double} absolute = __testlib_abs(result - expected);\par
00510 \par
00511     {\cf19 if} (__testlib_abs(expected) > 1E-9) \{\par
00512         {\cf18 double} relative = __testlib_abs(absolute / expected);\par
00513         {\cf19 return} __testlib_min(absolute, relative);\par
00514     \} {\cf19 else}\par
00515         {\cf19 return} absolute;\par
00516 \}\par
00517 \par
00519 {\cf17 static} {\cf18 void} __testlib_set_binary(std::FILE *file) \{\par
00520     {\cf19 if} (NULL != file) \{\par
00521 {\cf21 #ifdef ON_WINDOWS}\par
00522 {\cf21 #   ifdef _O_BINARY}\par
00523         {\cf19 if} (stdin == file)\par
00524 {\cf21 #       ifdef STDIN_FILENO}\par
00525                 {\cf19 return} void(_setmode(STDIN_FILENO, _O_BINARY));\par
00526 {\cf21 #       else}\par
00527                 {\cf19 return} void(_setmode(_fileno(stdin), _O_BINARY));\par
00528 {\cf21 #       endif}\par
00529         {\cf19 if} (stdout == file)\par
00530 {\cf21 #       ifdef STDOUT_FILENO}\par
00531                 {\cf19 return} void(_setmode(STDOUT_FILENO, _O_BINARY));\par
00532 {\cf21 #       else}\par
00533                 {\cf19 return} void(_setmode(_fileno(stdout), _O_BINARY));\par
00534 {\cf21 #       endif}\par
00535         {\cf19 if} (stderr == file)\par
00536 {\cf21 #       ifdef STDERR_FILENO}\par
00537                 {\cf19 return} void(_setmode(STDERR_FILENO, _O_BINARY));\par
00538 {\cf21 #       else}\par
00539                 {\cf19 return} void(_setmode(_fileno(stderr), _O_BINARY));\par
00540 {\cf21 #       endif}\par
00541 {\cf21 #   elif O_BINARY}\par
00542         {\cf19 if} (stdin == file)\par
00543 {\cf21 #       ifdef STDIN_FILENO}\par
00544                 {\cf19 return} void(setmode(STDIN_FILENO, O_BINARY));\par
00545 {\cf21 #       else}\par
00546                 {\cf19 return} void(setmode(fileno(stdin), O_BINARY));\par
00547 {\cf21 #       endif}\par
00548         {\cf19 if} (stdout == file)\par
00549 {\cf21 #       ifdef STDOUT_FILENO}\par
00550                 {\cf19 return} void(setmode(STDOUT_FILENO, O_BINARY));\par
00551 {\cf21 #       else}\par
00552                 {\cf19 return} void(setmode(fileno(stdout), O_BINARY));\par
00553 {\cf21 #       endif}\par
00554         {\cf19 if} (stderr == file)\par
00555 {\cf21 #       ifdef STDERR_FILENO}\par
00556                 {\cf19 return} void(setmode(STDERR_FILENO, O_BINARY));\par
00557 {\cf21 #       else}\par
00558                 {\cf19 return} void(setmode(fileno(stderr), O_BINARY));\par
00559 {\cf21 #       endif}\par
00560 {\cf21 #   endif}\par
00561 {\cf21 #endif}\par
00562     \}\par
00563 \}\par
00564 \par
00565 {\cf21 #if __cplusplus > 199711L || defined(_MSC_VER)}\par
00566 {\cf17 template}<{\cf17 typename} T>\par
00567 {\cf21 #ifdef __GNUC__}\par
00568 __attribute__(({\cf17 const}))\par
00569 {\cf21 #endif}\par
00570 {\cf17 static} std::string vtos({\cf17 const} T &t, std::true_type) \{\par
00571     {\cf19 if} (t == 0)\par
00572         {\cf19 return} {\cf22 "0"};\par
00573     {\cf19 else} \{\par
00574         T n(t);\par
00575         {\cf18 bool} negative = n < 0;\par
00576         std::string s;\par
00577         {\cf19 while} (n != 0) \{\par
00578             T digit = n % 10;\par
00579             {\cf19 if} (digit < 0)\par
00580                 digit = -digit;\par
00581             s += char({\cf23 '0'} + digit);\par
00582             n /= 10;\par
00583         \}\par
00584         std::reverse(s.begin(), s.end());\par
00585         {\cf19 return} negative ? {\cf22 "-"} + s : s;\par
00586     \}\par
00587 \}\par
00588 \par
00589 {\cf17 template}<{\cf17 typename} T>\par
00590 {\cf17 static} std::string vtos({\cf17 const} T &t, std::false_type) \{\par
00591     std::string s;\par
00592     {\cf17 static} std::stringstream ss;\par
00593     ss.str(std::string());\par
00594     ss.clear();\par
00595     ss << t;\par
00596     ss >> s;\par
00597     {\cf19 return} s;\par
00598 \}\par
00599 \par
00600 {\cf17 template}<{\cf17 typename} T>\par
00601 {\cf17 static} std::string vtos({\cf17 const} T &t) \{\par
00602     {\cf19 return} vtos(t, std::is_integral<T>());\par
00603 \}\par
00604 \par
00605 {\cf20 /* signed case. */}\par
00606 {\cf17 template}<{\cf17 typename} T>\par
00607 {\cf17 static} std::string toHumanReadableString({\cf17 const} T &n, std::false_type) \{\par
00608     {\cf19 if} (n == 0)\par
00609         {\cf19 return} vtos(n);\par
00610     {\cf18 int} trailingZeroCount = 0;\par
00611     T n_ = n;\par
00612     {\cf19 while} (n_ % 10 == 0)\par
00613         n_ /= 10, trailingZeroCount++;\par
00614     {\cf19 if} (trailingZeroCount >= 7) \{\par
00615         {\cf19 if} (n_ == 1)\par
00616             {\cf19 return} {\cf22 "10^"} + vtos(trailingZeroCount);\par
00617         {\cf19 else} {\cf19 if} (n_ == -1)\par
00618             {\cf19 return} {\cf22 "-10^"} + vtos(trailingZeroCount);\par
00619         {\cf19 else}\par
00620             {\cf19 return} vtos(n_) + {\cf22 "*10^"} + vtos(trailingZeroCount);\par
00621     \} {\cf19 else}\par
00622         {\cf19 return} vtos(n);\par
00623 \}\par
00624 \par
00625 {\cf20 /* unsigned case. */}\par
00626 {\cf17 template}<{\cf17 typename} T>\par
00627 {\cf17 static} std::string toHumanReadableString({\cf17 const} T &n, std::true_type) \{\par
00628     {\cf19 if} (n == 0)\par
00629         {\cf19 return} vtos(n);\par
00630     {\cf18 int} trailingZeroCount = 0;\par
00631     T n_ = n;\par
00632     {\cf19 while} (n_ % 10 == 0)\par
00633         n_ /= 10, trailingZeroCount++;\par
00634     {\cf19 if} (trailingZeroCount >= 7) \{\par
00635         {\cf19 if} (n_ == 1)\par
00636             {\cf19 return} {\cf22 "10^"} + vtos(trailingZeroCount);\par
00637         {\cf19 else}\par
00638             {\cf19 return} vtos(n_) + {\cf22 "*10^"} + vtos(trailingZeroCount);\par
00639     \} {\cf19 else}\par
00640         {\cf19 return} vtos(n);\par
00641 \}\par
00642 \par
00643 {\cf17 template}<{\cf17 typename} T>\par
00644 {\cf17 static} std::string toHumanReadableString({\cf17 const} T &n) \{\par
00645     {\cf19 return} toHumanReadableString(n, std::is_unsigned<T>());\par
00646 \}\par
00647 {\cf21 #else}\par
00648 {\cf17 template}<{\cf17 typename} T>\par
00649 {\cf17 static} std::string vtos({\cf17 const} T& t)\par
00650 \{\par
00651     std::string s;\par
00652     {\cf17 static} std::stringstream ss;\par
00653     ss.str(std::string());\par
00654     ss.clear();\par
00655     ss << t;\par
00656     ss >> s;\par
00657     {\cf19 return} s;\par
00658 \}\par
00659 \par
00660 {\cf17 template}<{\cf17 typename} T>\par
00661 {\cf17 static} std::string toHumanReadableString({\cf17 const} T &n) \{\par
00662     {\cf19 return} vtos(n);\par
00663 \}\par
00664 {\cf21 #endif}\par
00665 \par
00666 {\cf17 template}<{\cf17 typename} T>\par
00667 {\cf17 static} std::string toString({\cf17 const} T &t) \{\par
00668     {\cf19 return} vtos(t);\par
00669 \}\par
00670 \par
00671 {\cf21 #if __cplusplus > 199711L || defined(_MSC_VER)}\par
00672 {\cf20 /* opts */}\par
00673 {\cf18 void} prepareOpts({\cf18 int} argc, {\cf18 char}* argv[]);\par
00674 {\cf21 #endif}\par
00675 \par
00676 {\cf20 /*}\par
00677 {\cf20  * Very simple regex-like pattern.}\par
00678 {\cf20  * It used for two purposes: validation and generation.}\par
00679 {\cf20  *}\par
00680 {\cf20  * For example, pattern("[a-z]\{1,5\}").next(rnd) will return}\par
00681 {\cf20  * random string from lowercase latin letters with length}\par
00682 {\cf20  * from 1 to 5. It is easier to call rnd.next("[a-z]\{1,5\}")}\par
00683 {\cf20  * for the same effect.}\par
00684 {\cf20  *}\par
00685 {\cf20  * Another samples:}\par
00686 {\cf20  * "mike|john" will generate (match) "mike" or "john";}\par
00687 {\cf20  * "-?[1-9][0-9]\{0,3\}" will generate (match) non-zero integers from -9999 to 9999;}\par
00688 {\cf20  * "id-([ac]|b\{2\})" will generate (match) "id-a", "id-bb", "id-c";}\par
00689 {\cf20  * "[^0-9]*" will match sequences (empty or non-empty) without digits, you can't}\par
00690 {\cf20  * use it for generations.}\par
00691 {\cf20  *}\par
00692 {\cf20  * You can't use pattern for generation if it contains meta-symbol '*'. Also it}\par
00693 {\cf20  * is not recommended to use it for char-sets with meta-symbol '^' like [^a-z].}\par
00694 {\cf20  *}\par
00695 {\cf20  * For matching very simple greedy algorithm is used. For example, pattern}\par
00696 {\cf20  * "[0-9]?1" will not match "1", because of greedy nature of matching.}\par
00697 {\cf20  * Alternations (meta-symbols "|") are processed with brute-force algorithm, so}\par
00698 {\cf20  * do not use many alternations in one expression.}\par
00699 {\cf20  *}\par
00700 {\cf20  * If you want to use one expression many times it is better to compile it into}\par
00701 {\cf20  * a single pattern like "pattern p("[a-z]+")". Later you can use}\par
00702 {\cf20  * "p.matches(std::string s)" or "p.next(random_t& rd)" to check matching or generate}\par
00703 {\cf20  * new string by pattern.}\par
00704 {\cf20  *}\par
00705 {\cf20  * Simpler way to read token and check it for pattern matching is "inf.readToken("[a-z]+")".}\par
00706 {\cf20  *}\par
00707 {\cf20  * All spaces are ignored in regex, unless escaped with \\. For example, ouf.readLine("NO SOLUTION")}\par
00708 {\cf20  * will expect "NOSOLUTION", the correct call should be ouf.readLine("NO\\\\ SOLUTION") or}\par
00709 {\cf20  * ouf.readLine(R"(NO\\ SOLUTION)") if you prefer raw string literals from C++11.}\par
00710 {\cf20  */}\par
00711 {\cf17 class }random_t;\par
00712 \par
00713 {\cf17 class }pattern \{\par
00714 {\cf17 public}:\par
00715     {\cf20 /* Create pattern instance by string. */}\par
00716     pattern(std::string s);\par
00717 \par
00718     {\cf20 /* Generate new string by pattern and given random_t. */}\par
00719     std::string next(random_t &rnd) {\cf17 const};\par
00720 \par
00721     {\cf20 /* Checks if given string match the pattern. */}\par
00722     {\cf18 bool} matches({\cf17 const} std::string &s) {\cf17 const};\par
00723 \par
00724     {\cf20 /* Returns source string of the pattern. */}\par
00725     std::string src() {\cf17 const};\par
00726 \par
00727 {\cf17 private}:\par
00728     {\cf18 bool} matches({\cf17 const} std::string &s, {\cf18 size_t} pos) {\cf17 const};\par
00729 \par
00730     std::string s;\par
00731     std::vector<pattern> children;\par
00732     std::vector<char> chars;\par
00733     {\cf18 int} from;\par
00734     {\cf18 int} to;\par
00735 \};\par
00736 \par
00737 {\cf20 /*}\par
00738 {\cf20  * Use random_t instances to generate random values. It is preferred}\par
00739 {\cf20  * way to use randoms instead of rand() function or self-written}\par
00740 {\cf20  * randoms.}\par
00741 {\cf20  *}\par
00742 {\cf20  * Testlib defines global variable "rnd" of random_t class.}\par
00743 {\cf20  * Use registerGen(argc, argv, 1) to setup random_t seed be command}\par
00744 {\cf20  * line (to use latest random generator version).}\par
00745 {\cf20  *}\par
00746 {\cf20  * Random generates uniformly distributed values if another strategy is}\par
00747 {\cf20  * not specified explicitly.}\par
00748 {\cf20  */}\par
00749 {\cf17 class }random_t \{\par
00750 {\cf17 private}:\par
00751     {\cf18 unsigned} {\cf18 long} {\cf18 long} seed;\par
00752     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} multiplier;\par
00753     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} addend;\par
00754     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} mask;\par
00755     {\cf17 static} {\cf17 const} {\cf18 int} lim;\par
00756 \par
00757     {\cf18 long} {\cf18 long} nextBits({\cf18 int} bits) \{\par
00758         {\cf19 if} (bits <= 48) \{\par
00759             seed = (seed * multiplier + addend) & mask;\par
00760             {\cf19 return} ({\cf18 long} {\cf18 long}) (seed >> (48 - bits));\par
00761         \} {\cf19 else} \{\par
00762             {\cf19 if} (bits > 63)\par
00763                 __testlib_fail({\cf22 "random_t::nextBits(int bits): n must be less than 64"});\par
00764 \par
00765             {\cf18 int} lowerBitCount = (random_t::version == 0 ? 31 : 32);\par
00766 \par
00767             {\cf18 long} {\cf18 long} left = (nextBits(31) << 32);\par
00768             {\cf18 long} {\cf18 long} right = nextBits(lowerBitCount);\par
00769 \par
00770             {\cf19 return} left ^ right;\par
00771         \}\par
00772     \}\par
00773 \par
00774 {\cf17 public}:\par
00775     {\cf17 static} {\cf18 int} version;\par
00776 \par
00777     {\cf20 /* New random_t with fixed seed. */}\par
00778     random_t()\par
00779             : seed(3905348978240129619LL) \{\par
00780     \}\par
00781 \par
00782     {\cf20 /* Sets seed by command line. */}\par
00783     {\cf18 void} setSeed({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
00784         random_t p;\par
00785 \par
00786         seed = 3905348978240129619LL;\par
00787         {\cf19 for} ({\cf18 int} i = 1; i < argc; i++) \{\par
00788             std::size_t le = std::strlen(argv[i]);\par
00789             {\cf19 for} (std::size_t j = 0; j < le; j++)\par
00790                 seed = seed * multiplier + ({\cf18 unsigned} {\cf18 int}) (argv[i][j]) + addend;\par
00791             seed += multiplier / addend;\par
00792         \}\par
00793 \par
00794         seed = seed & mask;\par
00795     \}\par
00796 \par
00797     {\cf20 /* Sets seed by given value. */}\par
00798     {\cf18 void} setSeed({\cf18 long} {\cf18 long} _seed) \{\par
00799         seed = ({\cf18 unsigned} {\cf18 long} long) _seed;\par
00800         seed = (seed ^ multiplier) & mask;\par
00801     \}\par
00802 \par
00803 {\cf21 #ifndef __BORLANDC__}\par
00804 \par
00805     {\cf20 /* Random string value by given pattern (see pattern documentation). */}\par
00806     std::string next({\cf17 const} std::string &ptrn) \{\par
00807         pattern p(ptrn);\par
00808         {\cf19 return} p.next(*{\cf17 this});\par
00809     \}\par
00810 \par
00811 {\cf21 #else}\par
00812     {\cf20 /* Random string value by given pattern (see pattern documentation). */}\par
00813     std::string next(std::string ptrn)\par
00814     \{\par
00815         pattern p(ptrn);\par
00816         {\cf19 return} p.next(*{\cf17 this});\par
00817     \}\par
00818 {\cf21 #endif}\par
00819 \par
00820     {\cf20 /* Random value in range [0, n-1]. */}\par
00821     {\cf18 int} next({\cf18 int} n) \{\par
00822         {\cf19 if} (n <= 0)\par
00823             __testlib_fail({\cf22 "random_t::next(int n): n must be positive"});\par
00824 \par
00825         {\cf19 if} ((n & -n) == n)  {\cf20 // n is a power of 2}\par
00826             {\cf19 return} ({\cf18 int}) ((n * ({\cf18 long} long) nextBits(31)) >> 31);\par
00827 \par
00828         {\cf17 const} {\cf18 long} {\cf18 long} limit = INT_MAX / n * n;\par
00829 \par
00830         {\cf18 long} {\cf18 long} bits;\par
00831         {\cf19 do} \{\par
00832             bits = nextBits(31);\par
00833         \} {\cf19 while} (bits >= limit);\par
00834 \par
00835         {\cf19 return} int(bits % n);\par
00836     \}\par
00837 \par
00838     {\cf20 /* Random value in range [0, n-1]. */}\par
00839     {\cf18 unsigned} {\cf18 int} next({\cf18 unsigned} {\cf18 int} n) \{\par
00840         {\cf19 if} (n >= INT_MAX)\par
00841             __testlib_fail({\cf22 "random_t::next(unsigned int n): n must be less INT_MAX"});\par
00842         {\cf19 return} ({\cf18 unsigned} {\cf18 int}) next({\cf18 int}(n));\par
00843     \}\par
00844 \par
00845     {\cf20 /* Random value in range [0, n-1]. */}\par
00846     {\cf18 long} {\cf18 long} next({\cf18 long} {\cf18 long} n) \{\par
00847         {\cf19 if} (n <= 0)\par
00848             __testlib_fail({\cf22 "random_t::next(long long n): n must be positive"});\par
00849 \par
00850         {\cf17 const} {\cf18 long} {\cf18 long} limit = __TESTLIB_LONGLONG_MAX / n * n;\par
00851 \par
00852         {\cf18 long} {\cf18 long} bits;\par
00853         {\cf19 do} \{\par
00854             bits = nextBits(63);\par
00855         \} {\cf19 while} (bits >= limit);\par
00856 \par
00857         {\cf19 return} bits % n;\par
00858     \}\par
00859 \par
00860     {\cf20 /* Random value in range [0, n-1]. */}\par
00861     {\cf18 unsigned} {\cf18 long} {\cf18 long} next({\cf18 unsigned} {\cf18 long} {\cf18 long} n) \{\par
00862         {\cf19 if} (n >= ({\cf18 unsigned} {\cf18 long} {\cf18 long}) (__TESTLIB_LONGLONG_MAX))\par
00863             __testlib_fail({\cf22 "random_t::next(unsigned long long n): n must be less LONGLONG_MAX"});\par
00864         {\cf19 return} ({\cf18 unsigned} {\cf18 long} {\cf18 long}) next(({\cf18 long} {\cf18 long}) (n));\par
00865     \}\par
00866 \par
00867     {\cf20 /* Random value in range [0, n-1]. */}\par
00868     {\cf18 long} next({\cf18 long} n) \{\par
00869         {\cf19 return} ({\cf18 long}) next(({\cf18 long} {\cf18 long}) (n));\par
00870     \}\par
00871 \par
00872     {\cf20 /* Random value in range [0, n-1]. */}\par
00873     {\cf18 unsigned} {\cf18 long} next({\cf18 unsigned} {\cf18 long} n) \{\par
00874         {\cf19 if} (n >= ({\cf18 unsigned} {\cf18 long}) (LONG_MAX))\par
00875             __testlib_fail({\cf22 "random_t::next(unsigned long n): n must be less LONG_MAX"});\par
00876         {\cf19 return} ({\cf18 unsigned} {\cf18 long}) next(({\cf18 unsigned} {\cf18 long} {\cf18 long}) (n));\par
00877     \}\par
00878 \par
00879     {\cf20 /* Returns random value in range [from,to]. */}\par
00880     {\cf18 int} next({\cf18 int} from, {\cf18 int} to) \{\par
00881         {\cf19 return} int(next(({\cf18 long} {\cf18 long}) to - from + 1) + from);\par
00882     \}\par
00883 \par
00884     {\cf20 /* Returns random value in range [from,to]. */}\par
00885     {\cf18 unsigned} {\cf18 int} next({\cf18 unsigned} {\cf18 int} from, {\cf18 unsigned} {\cf18 int} to) \{\par
00886         {\cf19 return} ({\cf18 unsigned} {\cf18 int}) (next(({\cf18 long} {\cf18 long}) to - from + 1) + from);\par
00887     \}\par
00888 \par
00889     {\cf20 /* Returns random value in range [from,to]. */}\par
00890     {\cf18 long} {\cf18 long} next({\cf18 long} {\cf18 long} from, {\cf18 long} {\cf18 long} to) \{\par
00891         {\cf19 return} next(to - from + 1) + from;\par
00892     \}\par
00893 \par
00894     {\cf20 /* Returns random value in range [from,to]. */}\par
00895     {\cf18 unsigned} {\cf18 long} {\cf18 long} next({\cf18 unsigned} {\cf18 long} {\cf18 long} from, {\cf18 unsigned} {\cf18 long} {\cf18 long} to) \{\par
00896         {\cf19 if} (from > to)\par
00897             __testlib_fail({\cf22 "random_t::next(unsigned long long from, unsigned long long to): from can't not exceed to"});\par
00898         {\cf19 return} next(to - from + 1) + from;\par
00899     \}\par
00900 \par
00901     {\cf20 /* Returns random value in range [from,to]. */}\par
00902     {\cf18 long} next({\cf18 long} from, {\cf18 long} to) \{\par
00903         {\cf19 return} next(to - from + 1) + from;\par
00904     \}\par
00905 \par
00906     {\cf20 /* Returns random value in range [from,to]. */}\par
00907     {\cf18 unsigned} {\cf18 long} next({\cf18 unsigned} {\cf18 long} from, {\cf18 unsigned} {\cf18 long} to) \{\par
00908         {\cf19 if} (from > to)\par
00909             __testlib_fail({\cf22 "random_t::next(unsigned long from, unsigned long to): from can't not exceed to"});\par
00910         {\cf19 return} next(to - from + 1) + from;\par
00911     \}\par
00912 \par
00913     {\cf20 /* Random double value in range [0, 1). */}\par
00914     {\cf18 double} next() \{\par
00915         {\cf18 long} {\cf18 long} left = (({\cf18 long} long) (nextBits(26)) << 27);\par
00916         {\cf18 long} {\cf18 long} right = nextBits(27);\par
00917         {\cf19 return} __testlib_crop(({\cf18 double}) (left + right) / ({\cf18 double}) (1LL << 53), 0.0, 1.0);\par
00918     \}\par
00919 \par
00920     {\cf20 /* Random double value in range [0, n). */}\par
00921     {\cf18 double} next({\cf18 double} n) \{\par
00922         {\cf19 if} (n <= 0.0)\par
00923             __testlib_fail({\cf22 "random_t::next(double): n should be positive"});\par
00924         {\cf19 return} __testlib_crop(n * next(), 0.0, n);\par
00925     \}\par
00926 \par
00927     {\cf20 /* Random double value in range [from, to). */}\par
00928     {\cf18 double} next({\cf18 double} from, {\cf18 double} to) \{\par
00929         {\cf19 if} (from >= to)\par
00930             __testlib_fail({\cf22 "random_t::next(double from, double to): from should be strictly less than to"});\par
00931         {\cf19 return} next(to - from) + from;\par
00932     \}\par
00933 \par
00934     {\cf20 /* Returns random element from container. */}\par
00935     {\cf17 template}<{\cf17 typename} Container>\par
00936     {\cf17 typename} Container::value_type any({\cf17 const} Container &c) \{\par
00937         {\cf18 int} size = int(c.size());\par
00938         {\cf19 if} (size <= 0)\par
00939             __testlib_fail({\cf22 "random_t::any(const Container& c): c.size() must be positive"});\par
00940         {\cf17 typename} Container::const_iterator it = c.begin();\par
00941         std::advance(it, next(size));\par
00942         {\cf19 return} *it;\par
00943     \}\par
00944 \par
00945     {\cf20 /* Returns random element from iterator range. */}\par
00946     {\cf17 template}<{\cf17 typename} Iter>\par
00947     {\cf17 typename} Iter::value_type any({\cf17 const} Iter &begin, {\cf17 const} Iter &end) \{\par
00948         {\cf18 int} size = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::distance(begin, end));\par
00949         {\cf19 if} (size <= 0)\par
00950             __testlib_fail({\cf22 "random_t::any(const Iter& begin, const Iter& end): range must have positive length"});\par
00951         Iter it = begin;\par
00952         std::advance(it, next(size));\par
00953         {\cf19 return} *it;\par
00954     \}\par
00955 \par
00956     {\cf20 /* Random string value by given pattern (see pattern documentation). */}\par
00957 {\cf21 #ifdef __GNUC__}\par
00958     __attribute__ ((format (printf, 2, 3)))\par
00959 {\cf21 #endif}\par
00960     std::string next({\cf17 const} {\cf18 char} *format, ...) \{\par
00961         FMT_TO_RESULT(format, format, ptrn);\par
00962         {\cf19 return} next(ptrn);\par
00963     \}\par
00964 \par
00965     {\cf20 /*}\par
00966 {\cf20      * Weighted next. If type == 0 than it is usual "next()".}\par
00967 {\cf20      *}\par
00968 {\cf20      * If type = 1, than it returns "max(next(), next())"}\par
00969 {\cf20      * (the number of "max" functions equals to "type").}\par
00970 {\cf20      *}\par
00971 {\cf20      * If type < 0, than "max" function replaces with "min".}\par
00972 {\cf20      */}\par
00973     {\cf18 int} wnext({\cf18 int} n, {\cf18 int} type) \{\par
00974         {\cf19 if} (n <= 0)\par
00975             __testlib_fail({\cf22 "random_t::wnext(int n, int type): n must be positive"});\par
00976 \par
00977         {\cf19 if} (abs(type) < random_t::lim) \{\par
00978             {\cf18 int} result = next(n);\par
00979 \par
00980             {\cf19 for} ({\cf18 int} i = 0; i < +type; i++)\par
00981                 result = __testlib_max(result, next(n));\par
00982 \par
00983             {\cf19 for} ({\cf18 int} i = 0; i < -type; i++)\par
00984                 result = __testlib_min(result, next(n));\par
00985 \par
00986             {\cf19 return} result;\par
00987         \} {\cf19 else} \{\par
00988             {\cf18 double} p;\par
00989 \par
00990             {\cf19 if} (type > 0)\par
00991                 p = std::pow(next() + 0.0, 1.0 / (type + 1));\par
00992             {\cf19 else}\par
00993                 p = 1 - std::pow(next() + 0.0, 1.0 / (-type + 1));\par
00994 \par
00995             {\cf19 return} __testlib_crop(({\cf18 int}) ({\cf18 double}(n) * p), 0, n);\par
00996         \}\par
00997     \}\par
00998 \par
00999     {\cf20 /* See wnext(int, int). It uses the same algorithms. */}\par
01000     {\cf18 long} {\cf18 long} wnext({\cf18 long} {\cf18 long} n, {\cf18 int} type) \{\par
01001         {\cf19 if} (n <= 0)\par
01002             __testlib_fail({\cf22 "random_t::wnext(long long n, int type): n must be positive"});\par
01003 \par
01004         {\cf19 if} (abs(type) < random_t::lim) \{\par
01005             {\cf18 long} {\cf18 long} result = next(n);\par
01006 \par
01007             {\cf19 for} ({\cf18 int} i = 0; i < +type; i++)\par
01008                 result = __testlib_max(result, next(n));\par
01009 \par
01010             {\cf19 for} ({\cf18 int} i = 0; i < -type; i++)\par
01011                 result = __testlib_min(result, next(n));\par
01012 \par
01013             {\cf19 return} result;\par
01014         \} {\cf19 else} \{\par
01015             {\cf18 double} p;\par
01016 \par
01017             {\cf19 if} (type > 0)\par
01018                 p = std::pow(next() + 0.0, 1.0 / (type + 1));\par
01019             {\cf19 else}\par
01020                 p = 1 - std::pow(next() + 0.0, 1.0 / (-type + 1));\par
01021 \par
01022             {\cf19 return} __testlib_crop(({\cf18 long} {\cf18 long}) ({\cf18 double}(n) * p), 0LL, n);\par
01023         \}\par
01024     \}\par
01025 \par
01026     {\cf20 /* Returns value in [0, n). See wnext(int, int). It uses the same algorithms. */}\par
01027     {\cf18 double} wnext({\cf18 double} n, {\cf18 int} type) \{\par
01028         {\cf19 if} (n <= 0)\par
01029             __testlib_fail({\cf22 "random_t::wnext(double n, int type): n must be positive"});\par
01030 \par
01031         {\cf19 if} (abs(type) < random_t::lim) \{\par
01032             {\cf18 double} result = next();\par
01033 \par
01034             {\cf19 for} ({\cf18 int} i = 0; i < +type; i++)\par
01035                 result = __testlib_max(result, next());\par
01036 \par
01037             {\cf19 for} ({\cf18 int} i = 0; i < -type; i++)\par
01038                 result = __testlib_min(result, next());\par
01039 \par
01040             {\cf19 return} n * result;\par
01041         \} {\cf19 else} \{\par
01042             {\cf18 double} p;\par
01043 \par
01044             {\cf19 if} (type > 0)\par
01045                 p = std::pow(next() + 0.0, 1.0 / (type + 1));\par
01046             {\cf19 else}\par
01047                 p = 1 - std::pow(next() + 0.0, 1.0 / (-type + 1));\par
01048 \par
01049             {\cf19 return} __testlib_crop(n * p, 0.0, n);\par
01050         \}\par
01051     \}\par
01052 \par
01053     {\cf20 /* Returns value in [0, 1). See wnext(int, int). It uses the same algorithms. */}\par
01054     {\cf18 double} wnext({\cf18 int} type) \{\par
01055         {\cf19 return} wnext(1.0, type);\par
01056     \}\par
01057 \par
01058     {\cf20 /* See wnext(int, int). It uses the same algorithms. */}\par
01059     {\cf18 unsigned} {\cf18 int} wnext({\cf18 unsigned} {\cf18 int} n, {\cf18 int} type) \{\par
01060         {\cf19 if} (n >= INT_MAX)\par
01061             __testlib_fail({\cf22 "random_t::wnext(unsigned int n, int type): n must be less INT_MAX"});\par
01062         {\cf19 return} ({\cf18 unsigned} {\cf18 int}) wnext({\cf18 int}(n), type);\par
01063     \}\par
01064 \par
01065     {\cf20 /* See wnext(int, int). It uses the same algorithms. */}\par
01066     {\cf18 unsigned} {\cf18 long} {\cf18 long} wnext({\cf18 unsigned} {\cf18 long} {\cf18 long} n, {\cf18 int} type) \{\par
01067         {\cf19 if} (n >= ({\cf18 unsigned} {\cf18 long} {\cf18 long}) (__TESTLIB_LONGLONG_MAX))\par
01068             __testlib_fail({\cf22 "random_t::wnext(unsigned long long n, int type): n must be less LONGLONG_MAX"});\par
01069 \par
01070         {\cf19 return} ({\cf18 unsigned} {\cf18 long} {\cf18 long}) wnext(({\cf18 long} {\cf18 long}) (n), type);\par
01071     \}\par
01072 \par
01073     {\cf20 /* See wnext(int, int). It uses the same algorithms. */}\par
01074     {\cf18 long} wnext({\cf18 long} n, {\cf18 int} type) \{\par
01075         {\cf19 return} ({\cf18 long}) wnext(({\cf18 long} {\cf18 long}) (n), type);\par
01076     \}\par
01077 \par
01078     {\cf20 /* See wnext(int, int). It uses the same algorithms. */}\par
01079     {\cf18 unsigned} {\cf18 long} wnext({\cf18 unsigned} {\cf18 long} n, {\cf18 int} type) \{\par
01080         {\cf19 if} (n >= ({\cf18 unsigned} {\cf18 long}) (LONG_MAX))\par
01081             __testlib_fail({\cf22 "random_t::wnext(unsigned long n, int type): n must be less LONG_MAX"});\par
01082 \par
01083         {\cf19 return} ({\cf18 unsigned} {\cf18 long}) wnext(({\cf18 unsigned} {\cf18 long} {\cf18 long}) (n), type);\par
01084     \}\par
01085 \par
01086     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01087     {\cf18 int} wnext({\cf18 int} from, {\cf18 int} to, {\cf18 int} type) \{\par
01088         {\cf19 if} (from > to)\par
01089             __testlib_fail({\cf22 "random_t::wnext(int from, int to, int type): from can't not exceed to"});\par
01090         {\cf19 return} wnext(to - from + 1, type) + from;\par
01091     \}\par
01092 \par
01093     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01094     {\cf18 int} wnext({\cf18 unsigned} {\cf18 int} from, {\cf18 unsigned} {\cf18 int} to, {\cf18 int} type) \{\par
01095         {\cf19 if} (from > to)\par
01096             __testlib_fail({\cf22 "random_t::wnext(unsigned int from, unsigned int to, int type): from can't not exceed to"});\par
01097         {\cf19 return} int(wnext(to - from + 1, type) + from);\par
01098     \}\par
01099 \par
01100     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01101     {\cf18 long} {\cf18 long} wnext({\cf18 long} {\cf18 long} from, {\cf18 long} {\cf18 long} to, {\cf18 int} type) \{\par
01102         {\cf19 if} (from > to)\par
01103             __testlib_fail({\cf22 "random_t::wnext(long long from, long long to, int type): from can't not exceed to"});\par
01104         {\cf19 return} wnext(to - from + 1, type) + from;\par
01105     \}\par
01106 \par
01107     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01108     {\cf18 unsigned} {\cf18 long} {\cf18 long} wnext({\cf18 unsigned} {\cf18 long} {\cf18 long} from, {\cf18 unsigned} {\cf18 long} {\cf18 long} to, {\cf18 int} type) \{\par
01109         {\cf19 if} (from > to)\par
01110             __testlib_fail(\par
01111                     {\cf22 "random_t::wnext(unsigned long long from, unsigned long long to, int type): from can't not exceed to"});\par
01112         {\cf19 return} wnext(to - from + 1, type) + from;\par
01113     \}\par
01114 \par
01115     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01116     {\cf18 long} wnext({\cf18 long} from, {\cf18 long} to, {\cf18 int} type) \{\par
01117         {\cf19 if} (from > to)\par
01118             __testlib_fail({\cf22 "random_t::wnext(long from, long to, int type): from can't not exceed to"});\par
01119         {\cf19 return} wnext(to - from + 1, type) + from;\par
01120     \}\par
01121 \par
01122     {\cf20 /* Returns weighted random value in range [from, to]. */}\par
01123     {\cf18 unsigned} {\cf18 long} wnext({\cf18 unsigned} {\cf18 long} from, {\cf18 unsigned} {\cf18 long} to, {\cf18 int} type) \{\par
01124         {\cf19 if} (from > to)\par
01125             __testlib_fail({\cf22 "random_t::wnext(unsigned long from, unsigned long to, int type): from can't not exceed to"});\par
01126         {\cf19 return} wnext(to - from + 1, type) + from;\par
01127     \}\par
01128 \par
01129     {\cf20 /* Returns weighted random double value in range [from, to). */}\par
01130     {\cf18 double} wnext({\cf18 double} from, {\cf18 double} to, {\cf18 int} type) \{\par
01131         {\cf19 if} (from >= to)\par
01132             __testlib_fail({\cf22 "random_t::wnext(double from, double to, int type): from should be strictly less than to"});\par
01133         {\cf19 return} wnext(to - from, type) + from;\par
01134     \}\par
01135 \par
01136     {\cf20 /* Returns weighted random element from container. */}\par
01137     {\cf17 template}<{\cf17 typename} Container>\par
01138     {\cf17 typename} Container::value_type wany({\cf17 const} Container &c, {\cf18 int} type) \{\par
01139         {\cf18 int} size = int(c.size());\par
01140         {\cf19 if} (size <= 0)\par
01141             __testlib_fail({\cf22 "random_t::wany(const Container& c, int type): c.size() must be positive"});\par
01142         {\cf17 typename} Container::const_iterator it = c.begin();\par
01143         std::advance(it, wnext(size, type));\par
01144         {\cf19 return} *it;\par
01145     \}\par
01146 \par
01147     {\cf20 /* Returns weighted random element from iterator range. */}\par
01148     {\cf17 template}<{\cf17 typename} Iter>\par
01149     {\cf17 typename} Iter::value_type wany({\cf17 const} Iter &begin, {\cf17 const} Iter &end, {\cf18 int} type) \{\par
01150         {\cf18 int} size = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::distance(begin, end));\par
01151         {\cf19 if} (size <= 0)\par
01152             __testlib_fail(\par
01153                     {\cf22 "random_t::any(const Iter& begin, const Iter& end, int type): range must have positive length"});\par
01154         Iter it = begin;\par
01155         std::advance(it, wnext(size, type));\par
01156         {\cf19 return} *it;\par
01157     \}\par
01158 \par
01159     {\cf20 /* Returns random permutation of the given size (values are between `first` and `first`+size-1)*/}\par
01160     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} E>\par
01161     std::vector<E> perm(T size, E first) \{\par
01162         {\cf19 if} (size < 0)\par
01163             __testlib_fail({\cf22 "random_t::perm(T size, E first = 0): size must non-negative"});\par
01164         {\cf19 else} {\cf19 if} (size == 0)\par
01165             {\cf19 return} std::vector<E>();\par
01166         std::vector<E> p(size);\par
01167         E current = first;\par
01168         {\cf19 for} (T i = 0; i < size; i++)\par
01169             p[i] = current++;\par
01170         {\cf19 if} (size > 1)\par
01171             {\cf19 for} (T i = 1; i < size; i++)\par
01172                 std::swap(p[i], p[next(i + 1)]);\par
01173         {\cf19 return} p;\par
01174     \}\par
01175 \par
01176     {\cf20 /* Returns random permutation of the given size (values are between 0 and size-1)*/}\par
01177     {\cf17 template}<{\cf17 typename} T>\par
01178     std::vector<T> perm(T size) \{\par
01179         {\cf19 return} perm(size, T(0));\par
01180     \}\par
01181 \par
01182     {\cf20 /* Returns `size` unordered (unsorted) distinct numbers between `from` and `to`. */}\par
01183     {\cf17 template}<{\cf17 typename} T>\par
01184     std::vector<T> distinct({\cf18 int} size, T from, T to) \{\par
01185         std::vector<T> result;\par
01186         {\cf19 if} (size == 0)\par
01187             {\cf19 return} result;\par
01188 \par
01189         {\cf19 if} (from > to)\par
01190             __testlib_fail({\cf22 "random_t::distinct expected from <= to"});\par
01191 \par
01192         {\cf19 if} (size < 0)\par
01193             __testlib_fail({\cf22 "random_t::distinct expected size >= 0"});\par
01194 \par
01195         uint64_t n = to - from + 1;\par
01196         {\cf19 if} (uint64_t(size) > n)\par
01197             __testlib_fail({\cf22 "random_t::distinct expected size <= to - from + 1"});\par
01198 \par
01199         {\cf18 double} expected = 0.0;\par
01200         {\cf19 for} ({\cf18 int} i = 1; i <= size; i++)\par
01201             expected += {\cf18 double}(n) / double(n - i + 1);\par
01202 \par
01203         {\cf19 if} (expected < {\cf18 double}(n)) \{\par
01204             std::set<T> vals;\par
01205             {\cf19 while} ({\cf18 int}(vals.size()) < size) \{\par
01206                 T x = T(next(from, to));\par
01207                 {\cf19 if} (vals.insert(x).second)\par
01208                     result.push_back(x);\par
01209             \}\par
01210         \} {\cf19 else} \{\par
01211             {\cf19 if} (n > 1000000000)\par
01212                 __testlib_fail({\cf22 "random_t::distinct here expected to - from + 1 <= 1000000000"});\par
01213             std::vector<T> p(perm({\cf18 int}(n), from));\par
01214             result.insert(result.end(), p.begin(), p.begin() + size);\par
01215         \}\par
01216 \par
01217         {\cf19 return} result;\par
01218     \}\par
01219 \par
01220     {\cf20 /* Returns `size` unordered (unsorted) distinct numbers between `0` and `upper`-1. */}\par
01221     {\cf17 template}<{\cf17 typename} T>\par
01222     std::vector<T> distinct({\cf18 int} size, T upper) \{\par
01223         {\cf19 if} (size < 0)\par
01224             __testlib_fail({\cf22 "random_t::distinct expected size >= 0"});\par
01225         {\cf19 if} (size == 0)\par
01226             {\cf19 return} std::vector<T>();\par
01227 \par
01228         {\cf19 if} (upper <= 0)\par
01229             __testlib_fail({\cf22 "random_t::distinct expected upper > 0"});\par
01230         {\cf19 if} (size > upper)\par
01231             __testlib_fail({\cf22 "random_t::distinct expected size <= upper"});\par
01232 \par
01233         {\cf19 return} distinct(size, T(0), upper - 1);\par
01234     \}\par
01235 \par
01236     {\cf20 /* Returns random (unsorted) partition which is a representation of sum as a sum of integers not less than min_part. */}\par
01237     {\cf17 template}<{\cf17 typename} T>\par
01238     std::vector<T> partition({\cf18 int} size, T sum, T min_part) \{\par
01239         {\cf19 if} (size < 0)\par
01240             __testlib_fail({\cf22 "random_t::partition: size < 0"});\par
01241         {\cf19 if} (size == 0 && sum != 0)\par
01242             __testlib_fail({\cf22 "random_t::partition: size == 0 && sum != 0"});\par
01243         {\cf19 if} (min_part * size > sum)\par
01244             __testlib_fail({\cf22 "random_t::partition: min_part * size > sum"});\par
01245         {\cf19 if} (size == 0 && sum == 0)\par
01246             {\cf19 return} std::vector<T>();\par
01247 \par
01248         T sum_ = sum;\par
01249         sum -= min_part * size;\par
01250 \par
01251         std::vector<T> septums(size);\par
01252         std::vector<T> d = distinct(size - 1, T(1), T(sum + size - 1));\par
01253         {\cf19 for} ({\cf18 int} i = 0; i + 1 < size; i++)\par
01254             septums[i + 1] = d[i];\par
01255         sort(septums.begin(), septums.end());\par
01256 \par
01257         std::vector<T> result(size);\par
01258         {\cf19 for} ({\cf18 int} i = 0; i + 1 < size; i++)\par
01259             result[i] = septums[i + 1] - septums[i] - 1;\par
01260         result[size - 1] = sum + size - 1 - septums.back();\par
01261 \par
01262         {\cf19 for} (std::size_t i = 0; i < result.size(); i++)\par
01263             result[i] += min_part;\par
01264 \par
01265         T result_sum = 0;\par
01266         {\cf19 for} (std::size_t i = 0; i < result.size(); i++)\par
01267             result_sum += result[i];\par
01268         {\cf19 if} (result_sum != sum_)\par
01269             __testlib_fail({\cf22 "random_t::partition: partition sum is expected to be the given sum"});\par
01270 \par
01271         {\cf19 if} (*std::min_element(result.begin(), result.end()) < min_part)\par
01272             __testlib_fail({\cf22 "random_t::partition: partition min is expected to be no less than the given min_part"});\par
01273 \par
01274         {\cf19 if} ({\cf18 int}(result.size()) != size || result.size() != ({\cf18 size_t}) size)\par
01275             __testlib_fail({\cf22 "random_t::partition: partition size is expected to be equal to the given size"});\par
01276 \par
01277         {\cf19 return} result;\par
01278     \}\par
01279 \par
01280     {\cf20 /* Returns random (unsorted) partition which is a representation of sum as a sum of positive integers. */}\par
01281     {\cf17 template}<{\cf17 typename} T>\par
01282     std::vector<T> partition({\cf18 int} size, T sum) \{\par
01283         {\cf19 return} partition(size, sum, T(1));\par
01284     \}\par
01285 \};\par
01286 \par
01287 {\cf17 const} {\cf18 int} random_t::lim = 25;\par
01288 {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} random_t::multiplier = 0x5DEECE66DLL;\par
01289 {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} random_t::addend = 0xBLL;\par
01290 {\cf17 const} {\cf18 unsigned} {\cf18 long} {\cf18 long} random_t::mask = (1LL << 48) - 1;\par
01291 {\cf18 int} random_t::version = -1;\par
01292 \par
01293 {\cf20 /* Pattern implementation */}\par
01294 {\cf18 bool} pattern::matches({\cf17 const} std::string &s){\cf17  const }\{\par
01295     {\cf19 return} matches(s, 0);\par
01296 \}\par
01297 \par
01298 {\cf17 static} {\cf18 bool} __pattern_isSlash({\cf17 const} std::string &s, {\cf18 size_t} pos) \{\par
01299     {\cf19 return} s[pos] == {\cf23 '\\\\'};\par
01300 \}\par
01301 \par
01302 {\cf21 #ifdef __GNUC__}\par
01303 __attribute__((pure))\par
01304 {\cf21 #endif}\par
01305 {\cf17 static} {\cf18 bool} __pattern_isCommandChar({\cf17 const} std::string &s, {\cf18 size_t} pos, {\cf18 char} value) \{\par
01306     {\cf19 if} (pos >= s.length())\par
01307         {\cf19 return} {\cf17 false};\par
01308 \par
01309     {\cf18 int} slashes = 0;\par
01310 \par
01311     {\cf18 int} before = int(pos) - 1;\par
01312     {\cf19 while} (before >= 0 && s[before] == {\cf23 '\\\\'})\par
01313         before--, slashes++;\par
01314 \par
01315     {\cf19 return} slashes % 2 == 0 && s[pos] == value;\par
01316 \}\par
01317 \par
01318 {\cf17 static} {\cf18 char} __pattern_getChar({\cf17 const} std::string &s, {\cf18 size_t} &pos) \{\par
01319     {\cf19 if} (__pattern_isSlash(s, pos))\par
01320         pos += 2;\par
01321     {\cf19 else}\par
01322         pos++;\par
01323 \par
01324     {\cf19 return} s[pos - 1];\par
01325 \}\par
01326 \par
01327 {\cf21 #ifdef __GNUC__}\par
01328 __attribute__((pure))\par
01329 {\cf21 #endif}\par
01330 {\cf17 static} {\cf18 int} __pattern_greedyMatch({\cf17 const} std::string &s, {\cf18 size_t} pos, {\cf17 const} std::vector<char> chars) \{\par
01331     {\cf18 int} result = 0;\par
01332 \par
01333     {\cf19 while} (pos < s.length()) \{\par
01334         {\cf18 char} c = s[pos++];\par
01335         {\cf19 if} (!std::binary_search(chars.begin(), chars.end(), c))\par
01336             {\cf19 break};\par
01337         {\cf19 else}\par
01338             result++;\par
01339     \}\par
01340 \par
01341     {\cf19 return} result;\par
01342 \}\par
01343 \par
01344 std::string pattern::src(){\cf17  const }\{\par
01345     {\cf19 return} s;\par
01346 \}\par
01347 \par
01348 {\cf18 bool} pattern::matches({\cf17 const} std::string &s, {\cf18 size_t} pos){\cf17  const }\{\par
01349     std::string result;\par
01350 \par
01351     {\cf19 if} (to > 0) \{\par
01352         {\cf18 int} size = __pattern_greedyMatch(s, pos, chars);\par
01353         {\cf19 if} (size < from)\par
01354             {\cf19 return} {\cf17 false};\par
01355         {\cf19 if} (size > to)\par
01356             size = to;\par
01357         pos += size;\par
01358     \}\par
01359 \par
01360     {\cf19 if} (children.size() > 0) \{\par
01361         {\cf19 for} ({\cf18 size_t} child = 0; child < children.size(); child++)\par
01362             {\cf19 if} (children[child].matches(s, pos))\par
01363                 {\cf19 return} {\cf17 true};\par
01364         {\cf19 return} {\cf17 false};\par
01365     \} {\cf19 else}\par
01366         {\cf19 return} pos == s.length();\par
01367 \}\par
01368 \par
01369 std::string pattern::next(random_t &rnd){\cf17  const }\{\par
01370     std::string result;\par
01371     result.reserve(20);\par
01372 \par
01373     {\cf19 if} (to == INT_MAX)\par
01374         __testlib_fail({\cf22 "pattern::next(random_t& rnd): can't process character '*' for generation"});\par
01375 \par
01376     {\cf19 if} (to > 0) \{\par
01377         {\cf18 int} count = rnd.next(to - from + 1) + from;\par
01378         {\cf19 for} ({\cf18 int} i = 0; i < count; i++)\par
01379             result += chars[rnd.next({\cf18 int}(chars.size()))];\par
01380     \}\par
01381 \par
01382     {\cf19 if} (children.size() > 0) \{\par
01383         {\cf18 int} child = rnd.next({\cf18 int}(children.size()));\par
01384         result += children[child].next(rnd);\par
01385     \}\par
01386 \par
01387     {\cf19 return} result;\par
01388 \}\par
01389 \par
01390 {\cf17 static} {\cf18 void} __pattern_scanCounts({\cf17 const} std::string &s, {\cf18 size_t} &pos, {\cf18 int} &from, {\cf18 int} &to) \{\par
01391     {\cf19 if} (pos >= s.length()) \{\par
01392         from = to = 1;\par
01393         {\cf19 return};\par
01394     \}\par
01395 \par
01396     {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '\{'})) \{\par
01397         std::vector<std::string> parts;\par
01398         std::string part;\par
01399 \par
01400         pos++;\par
01401 \par
01402         {\cf19 while} (pos < s.length() && !__pattern_isCommandChar(s, pos, {\cf23 '\}'})) \{\par
01403             {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 ','}))\par
01404                 parts.push_back(part), part = {\cf22 ""}, pos++;\par
01405             {\cf19 else}\par
01406                 part += __pattern_getChar(s, pos);\par
01407         \}\par
01408 \par
01409         {\cf19 if} (part != {\cf22 ""})\par
01410             parts.push_back(part);\par
01411 \par
01412         {\cf19 if} (!__pattern_isCommandChar(s, pos, {\cf23 '\}'}))\par
01413             __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01414 \par
01415         pos++;\par
01416 \par
01417         {\cf19 if} (parts.size() < 1 || parts.size() > 2)\par
01418             __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01419 \par
01420         std::vector<int> numbers;\par
01421 \par
01422         {\cf19 for} ({\cf18 size_t} i = 0; i < parts.size(); i++) \{\par
01423             {\cf19 if} (parts[i].length() == 0)\par
01424                 __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01425             {\cf18 int} number;\par
01426             {\cf19 if} (std::sscanf(parts[i].c_str(), {\cf22 "%d"}, &number) != 1)\par
01427                 __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01428             numbers.push_back(number);\par
01429         \}\par
01430 \par
01431         {\cf19 if} (numbers.size() == 1)\par
01432             from = to = numbers[0];\par
01433         {\cf19 else}\par
01434             from = numbers[0], to = numbers[1];\par
01435 \par
01436         {\cf19 if} (from > to)\par
01437             __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01438     \} {\cf19 else} \{\par
01439         {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '?'})) \{\par
01440             from = 0, to = 1, pos++;\par
01441             {\cf19 return};\par
01442         \}\par
01443 \par
01444         {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '*'})) \{\par
01445             from = 0, to = INT_MAX, pos++;\par
01446             {\cf19 return};\par
01447         \}\par
01448 \par
01449         {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '+'})) \{\par
01450             from = 1, to = INT_MAX, pos++;\par
01451             {\cf19 return};\par
01452         \}\par
01453 \par
01454         from = to = 1;\par
01455     \}\par
01456 \}\par
01457 \par
01458 {\cf17 static} std::vector<char> __pattern_scanCharSet({\cf17 const} std::string &s, {\cf18 size_t} &pos) \{\par
01459     {\cf19 if} (pos >= s.length())\par
01460         __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01461 \par
01462     std::vector<char> result;\par
01463 \par
01464     {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '['})) \{\par
01465         pos++;\par
01466         {\cf18 bool} negative = __pattern_isCommandChar(s, pos, {\cf23 '^'});\par
01467         {\cf19 if} (negative)\par
01468             pos++;\par
01469 \par
01470         {\cf18 char} prev = 0;\par
01471 \par
01472         {\cf19 while} (pos < s.length() && !__pattern_isCommandChar(s, pos, {\cf23 ']'})) \{\par
01473             {\cf19 if} (__pattern_isCommandChar(s, pos, {\cf23 '-'}) && prev != 0) \{\par
01474                 pos++;\par
01475 \par
01476                 {\cf19 if} (pos + 1 == s.length() || __pattern_isCommandChar(s, pos, {\cf23 ']'})) \{\par
01477                     result.push_back(prev);\par
01478                     prev = {\cf23 '-'};\par
01479                     {\cf19 continue};\par
01480                 \}\par
01481 \par
01482                 {\cf18 char} next = __pattern_getChar(s, pos);\par
01483                 {\cf19 if} (prev > next)\par
01484                     __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01485 \par
01486                 {\cf19 for} ({\cf18 char} c = prev; c != next; c++)\par
01487                     result.push_back(c);\par
01488                 result.push_back(next);\par
01489 \par
01490                 prev = 0;\par
01491             \} {\cf19 else} \{\par
01492                 {\cf19 if} (prev != 0)\par
01493                     result.push_back(prev);\par
01494                 prev = __pattern_getChar(s, pos);\par
01495             \}\par
01496         \}\par
01497 \par
01498         {\cf19 if} (prev != 0)\par
01499             result.push_back(prev);\par
01500 \par
01501         {\cf19 if} (!__pattern_isCommandChar(s, pos, {\cf23 ']'}))\par
01502             __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01503 \par
01504         pos++;\par
01505 \par
01506         {\cf19 if} (negative) \{\par
01507             std::sort(result.begin(), result.end());\par
01508             std::vector<char> actuals;\par
01509             {\cf19 for} ({\cf18 int} code = 0; code < 255; code++) \{\par
01510                 {\cf18 char} c = char(code);\par
01511                 {\cf19 if} (!std::binary_search(result.begin(), result.end(), c))\par
01512                     actuals.push_back(c);\par
01513             \}\par
01514             result = actuals;\par
01515         \}\par
01516 \par
01517         std::sort(result.begin(), result.end());\par
01518     \} {\cf19 else}\par
01519         result.push_back(__pattern_getChar(s, pos));\par
01520 \par
01521     {\cf19 return} result;\par
01522 \}\par
01523 \par
01524 pattern::pattern(std::string s) : s(s), from(0), to(0) \{\par
01525     std::string t;\par
01526     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
01527         {\cf19 if} (!__pattern_isCommandChar(s, i, {\cf23 ' '}))\par
01528             t += s[i];\par
01529     s = t;\par
01530 \par
01531     {\cf18 int} opened = 0;\par
01532     {\cf18 int} firstClose = -1;\par
01533     std::vector<int> seps;\par
01534 \par
01535     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++) \{\par
01536         {\cf19 if} (__pattern_isCommandChar(s, i, {\cf23 '('})) \{\par
01537             opened++;\par
01538             {\cf19 continue};\par
01539         \}\par
01540 \par
01541         {\cf19 if} (__pattern_isCommandChar(s, i, {\cf23 ')'})) \{\par
01542             opened--;\par
01543             {\cf19 if} (opened == 0 && firstClose == -1)\par
01544                 firstClose = int(i);\par
01545             {\cf19 continue};\par
01546         \}\par
01547 \par
01548         {\cf19 if} (opened < 0)\par
01549             __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01550 \par
01551         {\cf19 if} (__pattern_isCommandChar(s, i, {\cf23 '|'}) && opened == 0)\par
01552             seps.push_back({\cf18 int}(i));\par
01553     \}\par
01554 \par
01555     {\cf19 if} (opened != 0)\par
01556         __testlib_fail({\cf22 "pattern: Illegal pattern (or part) \\""} + s + {\cf22 "\\""});\par
01557 \par
01558     {\cf19 if} (seps.size() == 0 && firstClose + 1 == ({\cf18 int}) s.length()\par
01559         && __pattern_isCommandChar(s, 0, {\cf23 '('}) && __pattern_isCommandChar(s, s.length() - 1, {\cf23 ')'})) \{\par
01560         children.push_back(pattern(s.substr(1, s.length() - 2)));\par
01561     \} {\cf19 else} \{\par
01562         {\cf19 if} (seps.size() > 0) \{\par
01563             seps.push_back({\cf18 int}(s.length()));\par
01564             {\cf18 int} last = 0;\par
01565 \par
01566             {\cf19 for} ({\cf18 size_t} i = 0; i < seps.size(); i++) \{\par
01567                 children.push_back(pattern(s.substr(last, seps[i] - last)));\par
01568                 last = seps[i] + 1;\par
01569             \}\par
01570         \} {\cf19 else} \{\par
01571             {\cf18 size_t} pos = 0;\par
01572             chars = __pattern_scanCharSet(s, pos);\par
01573             __pattern_scanCounts(s, pos, from, to);\par
01574             {\cf19 if} (pos < s.length())\par
01575                 children.push_back(pattern(s.substr(pos)));\par
01576         \}\par
01577     \}\par
01578 \}\par
01579 \par
01580 {\cf20 /* End of pattern implementation */}\par
01581 \par
01582 {\cf17 template}<{\cf17 typename} C>\par
01583 {\cf17 inline} {\cf18 bool} isEof(C c) \{\par
01584     {\cf19 return} c == EOFC;\par
01585 \}\par
01586 \par
01587 {\cf17 template}<{\cf17 typename} C>\par
01588 {\cf17 inline} {\cf18 bool} isEoln(C c) \{\par
01589     {\cf19 return} (c == LF || c == CR);\par
01590 \}\par
01591 \par
01592 {\cf17 template}<{\cf17 typename} C>\par
01593 {\cf17 inline} {\cf18 bool} isBlanks(C c) \{\par
01594     {\cf19 return} (c == LF || c == CR || c == SPACE || c == TAB);\par
01595 \}\par
01596 \par
01597 {\cf17 inline} std::string trim({\cf17 const} std::string &s) \{\par
01598     {\cf19 if} (s.empty())\par
01599         {\cf19 return} s;\par
01600 \par
01601     {\cf18 int} left = 0;\par
01602     {\cf19 while} (left < {\cf18 int}(s.length()) && isBlanks(s[left]))\par
01603         left++;\par
01604     {\cf19 if} (left >= {\cf18 int}(s.length()))\par
01605         {\cf19 return} {\cf22 ""};\par
01606 \par
01607     {\cf18 int} right = int(s.length()) - 1;\par
01608     {\cf19 while} (right >= 0 && isBlanks(s[right]))\par
01609         right--;\par
01610     {\cf19 if} (right < 0)\par
01611         {\cf19 return} {\cf22 ""};\par
01612 \par
01613     {\cf19 return} s.substr(left, right - left + 1);\par
01614 \}\par
01615 \par
01616 {\cf17 enum} TMode \{\par
01617     _input, _output, _answer\par
01618 \};\par
01619 \par
01620 {\cf20 /* Outcomes 6-15 are reserved for future use. */}\par
01621 {\cf17 enum} TResult \{\par
01622     _ok = 0,\par
01623     _wa = 1,\par
01624     _pe = 2,\par
01625     _fail = 3,\par
01626     _dirt = 4,\par
01627     _points = 5,\par
01628     _unexpected_eof = 8,\par
01629     _partially = 16\par
01630 \};\par
01631 \par
01632 {\cf17 enum} TTestlibMode \{\par
01633     _unknown, _checker, _validator, _generator, _interactor, _scorer\par
01634 \};\par
01635 \par
01636 {\cf21 #define _pc(exitCode) (TResult(_partially + (exitCode)))}\par
01637 \par
01638 {\cf20 /* Outcomes 6-15 are reserved for future use. */}\par
01639 {\cf17 const} std::string outcomes[] = \{\par
01640         {\cf22 "accepted"},\par
01641         {\cf22 "wrong-answer"},\par
01642         {\cf22 "presentation-error"},\par
01643         {\cf22 "fail"},\par
01644         {\cf22 "fail"},\par
01645 {\cf21 #ifndef PCMS2}\par
01646         {\cf22 "points"},\par
01647 {\cf21 #else}\par
01648         {\cf22 "relative-scoring"},\par
01649 {\cf21 #endif}\par
01650         {\cf22 "reserved"},\par
01651         {\cf22 "reserved"},\par
01652         {\cf22 "unexpected-eof"},\par
01653         {\cf22 "reserved"},\par
01654         {\cf22 "reserved"},\par
01655         {\cf22 "reserved"},\par
01656         {\cf22 "reserved"},\par
01657         {\cf22 "reserved"},\par
01658         {\cf22 "reserved"},\par
01659         {\cf22 "reserved"},\par
01660         {\cf22 "partially-correct"}\par
01661 \};\par
01662 \par
01663 {\cf17 class }InputStreamReader \{\par
01664 {\cf17 public}:\par
01665     {\cf17 virtual} {\cf18 void} setTestCase({\cf18 int} testCase) = 0;\par
01666 \par
01667     {\cf17 virtual} std::vector<int> getReadChars() = 0;\par
01668     \par
01669     {\cf17 virtual} {\cf18 int} curChar() = 0;\par
01670 \par
01671     {\cf17 virtual} {\cf18 int} nextChar() = 0;\par
01672 \par
01673     {\cf17 virtual} {\cf18 void} skipChar() = 0;\par
01674 \par
01675     {\cf17 virtual} {\cf18 void} unreadChar({\cf18 int} c) = 0;\par
01676 \par
01677     {\cf17 virtual} std::string getName() = 0;\par
01678 \par
01679     {\cf17 virtual} {\cf18 bool} eof() = 0;\par
01680 \par
01681     {\cf17 virtual} {\cf18 void} close() = 0;\par
01682 \par
01683     {\cf17 virtual} {\cf18 int} getLine() = 0;\par
01684 \par
01685     {\cf17 virtual} ~InputStreamReader() = 0;\par
01686 \};\par
01687 \par
01688 InputStreamReader::~InputStreamReader() \{\par
01689     {\cf20 // No operations.}\par
01690 \}\par
01691 \par
01692 {\cf17 class }StringInputStreamReader : {\cf17 public} InputStreamReader \{\par
01693 {\cf17 private}:\par
01694     std::string s;\par
01695     {\cf18 size_t} pos;\par
01696 \par
01697 {\cf17 public}:\par
01698     StringInputStreamReader({\cf17 const} std::string &content) : s(content), pos(0) \{\par
01699         {\cf20 // No operations.}\par
01700     \}\par
01701 \par
01702     {\cf18 void} setTestCase({\cf18 int}) \{\par
01703         __testlib_fail({\cf22 "setTestCase not implemented in StringInputStreamReader"});\par
01704     \}\par
01705 \par
01706     std::vector<int> getReadChars() \{\par
01707         __testlib_fail({\cf22 "getReadChars not implemented in StringInputStreamReader"});\par
01708     \}\par
01709     \par
01710     {\cf18 int} curChar() \{\par
01711         {\cf19 if} (pos >= s.length())\par
01712             {\cf19 return} EOFC;\par
01713         {\cf19 else}\par
01714             {\cf19 return} s[pos];\par
01715     \}\par
01716 \par
01717     {\cf18 int} nextChar() \{\par
01718         {\cf19 if} (pos >= s.length()) \{\par
01719             pos++;\par
01720             {\cf19 return} EOFC;\par
01721         \} {\cf19 else}\par
01722             {\cf19 return} s[pos++];\par
01723     \}\par
01724 \par
01725     {\cf18 void} skipChar() \{\par
01726         pos++;\par
01727     \}\par
01728 \par
01729     {\cf18 void} unreadChar({\cf18 int} c) \{\par
01730         {\cf19 if} (pos == 0)\par
01731             __testlib_fail({\cf22 "StringInputStreamReader::unreadChar(int): pos == 0."});\par
01732         pos--;\par
01733         {\cf19 if} (pos < s.length())\par
01734             s[pos] = char(c);\par
01735     \}\par
01736 \par
01737     std::string getName() \{\par
01738         {\cf19 return} __testlib_part(s);\par
01739     \}\par
01740 \par
01741     {\cf18 int} getLine() \{\par
01742         {\cf19 return} -1;\par
01743     \}\par
01744 \par
01745     {\cf18 bool} eof() \{\par
01746         {\cf19 return} pos >= s.length();\par
01747     \}\par
01748 \par
01749     {\cf18 void} close() \{\par
01750         {\cf20 // No operations.}\par
01751     \}\par
01752 \};\par
01753 \par
01754 {\cf17 class }FileInputStreamReader : {\cf17 public} InputStreamReader \{\par
01755 {\cf17 private}:\par
01756     std::FILE *file;\par
01757     std::string name;\par
01758     {\cf18 int} line;\par
01759     std::vector<int> undoChars;\par
01760     std::vector<int> readChars;\par
01761     std::vector<int> undoReadChars;\par
01762 \par
01763     {\cf17 inline} {\cf18 int} postprocessGetc({\cf18 int} getcResult) \{\par
01764         {\cf19 if} (getcResult != EOF)\par
01765             {\cf19 return} getcResult;\par
01766         {\cf19 else}\par
01767             {\cf19 return} EOFC;\par
01768     \}\par
01769 \par
01770     {\cf18 int} getc(FILE *file) \{\par
01771         {\cf18 int} c;\par
01772         {\cf18 int} rc;\par
01773 \par
01774         {\cf19 if} (undoChars.empty()) \{\par
01775             c = rc = ::getc(file);\par
01776         \} {\cf19 else} \{\par
01777             c = undoChars.back();\par
01778             undoChars.pop_back();\par
01779             rc = undoReadChars.back();\par
01780             undoReadChars.pop_back();\par
01781         \}\par
01782 \par
01783         {\cf19 if} (c == LF)\par
01784             line++;\par
01785 \par
01786         readChars.push_back(rc);\par
01787         {\cf19 return} c;\par
01788     \}\par
01789 \par
01790     {\cf18 int} ungetc({\cf18 int} c{\cf20 /*, FILE* file*/}) \{\par
01791         {\cf19 if} (!readChars.empty()) \{\par
01792             undoReadChars.push_back(readChars.back());\par
01793             readChars.pop_back();\par
01794         \}\par
01795         {\cf19 if} (c == LF)\par
01796             line--;\par
01797         undoChars.push_back(c);\par
01798         {\cf19 return} c;\par
01799     \}\par
01800 \par
01801 {\cf17 public}:\par
01802     FileInputStreamReader(std::FILE *file, {\cf17 const} std::string &name) : file(file), name(name), line(1) \{\par
01803         {\cf20 // No operations.}\par
01804     \}\par
01805 \par
01806     {\cf18 void} setTestCase({\cf18 int} testCase) \{\par
01807         {\cf19 if} (testCase < 0 || testCase > __TESTLIB_MAX_TEST_CASE)\par
01808             __testlib_fail(format({\cf22 "testCase expected fit in [1,%d], but %d doesn't"}, __TESTLIB_MAX_TEST_CASE, testCase));\par
01809         readChars.push_back(testCase + 256);\par
01810     \}\par
01811 \par
01812     std::vector<int> getReadChars() \{\par
01813         {\cf19 return} readChars;\par
01814     \}\par
01815 \par
01816     {\cf18 int} curChar() \{\par
01817         {\cf19 if} (feof(file))\par
01818             {\cf19 return} EOFC;\par
01819         {\cf19 else} \{\par
01820             {\cf18 int} c = getc(file);\par
01821             ungetc(c{\cf20 /*, file*/});\par
01822             {\cf19 return} postprocessGetc(c);\par
01823         \}\par
01824     \}\par
01825 \par
01826     {\cf18 int} nextChar() \{\par
01827         {\cf19 if} (feof(file))\par
01828             {\cf19 return} EOFC;\par
01829         {\cf19 else}\par
01830             {\cf19 return} postprocessGetc(getc(file));\par
01831     \}\par
01832 \par
01833     {\cf18 void} skipChar() \{\par
01834         getc(file);\par
01835     \}\par
01836 \par
01837     {\cf18 void} unreadChar({\cf18 int} c) \{\par
01838         ungetc(c{\cf20 /*, file*/});\par
01839     \}\par
01840 \par
01841     std::string getName() \{\par
01842         {\cf19 return} name;\par
01843     \}\par
01844 \par
01845     {\cf18 int} getLine() \{\par
01846         {\cf19 return} line;\par
01847     \}\par
01848 \par
01849     {\cf18 bool} eof() \{\par
01850         {\cf19 if} (NULL == file || feof(file))\par
01851             {\cf19 return} {\cf17 true};\par
01852         {\cf19 else} \{\par
01853             {\cf18 int} c = nextChar();\par
01854             {\cf19 if} (c == EOFC || (c == EOF && feof(file)))\par
01855                 {\cf19 return} {\cf17 true};\par
01856             unreadChar(c);\par
01857             {\cf19 return} {\cf17 false};\par
01858         \}\par
01859     \}\par
01860 \par
01861     {\cf18 void} close() \{\par
01862         {\cf19 if} (NULL != file) \{\par
01863             fclose(file);\par
01864             file = NULL;\par
01865         \}\par
01866     \}\par
01867 \};\par
01868 \par
01869 {\cf17 class }BufferedFileInputStreamReader : {\cf17 public} InputStreamReader \{\par
01870 {\cf17 private}:\par
01871     {\cf17 static} {\cf17 const} {\cf18 size_t} BUFFER_SIZE;\par
01872     {\cf17 static} {\cf17 const} {\cf18 size_t} MAX_UNREAD_COUNT;\par
01873 \par
01874     std::FILE *file;\par
01875     std::string name;\par
01876     {\cf18 int} line;\par
01877 \par
01878     {\cf18 char} *buffer;\par
01879     {\cf18 bool} *isEof;\par
01880     {\cf18 int} bufferPos;\par
01881     {\cf18 size_t} bufferSize;\par
01882 \par
01883     {\cf18 bool} refill() \{\par
01884         {\cf19 if} (NULL == file)\par
01885             __testlib_fail({\cf22 "BufferedFileInputStreamReader: file == NULL ("} + getName() + {\cf22 ")"});\par
01886 \par
01887         {\cf19 if} (bufferPos >= {\cf18 int}(bufferSize)) \{\par
01888             {\cf18 size_t} readSize = fread(\par
01889                     buffer + MAX_UNREAD_COUNT,\par
01890                     1,\par
01891                     BUFFER_SIZE - MAX_UNREAD_COUNT,\par
01892                     file\par
01893             );\par
01894 \par
01895             {\cf19 if} (readSize < BUFFER_SIZE - MAX_UNREAD_COUNT\par
01896                 && ferror(file))\par
01897                 __testlib_fail({\cf22 "BufferedFileInputStreamReader: unable to read ("} + getName() + {\cf22 ")"});\par
01898 \par
01899             bufferSize = MAX_UNREAD_COUNT + readSize;\par
01900             bufferPos = int(MAX_UNREAD_COUNT);\par
01901             std::memset(isEof + MAX_UNREAD_COUNT, 0, {\cf17 sizeof}(isEof[0]) * readSize);\par
01902 \par
01903             {\cf19 return} readSize > 0;\par
01904         \} {\cf19 else}\par
01905             {\cf19 return} {\cf17 true};\par
01906     \}\par
01907 \par
01908     {\cf18 char} increment() \{\par
01909         {\cf18 char} c;\par
01910         {\cf19 if} ((c = buffer[bufferPos++]) == LF)\par
01911             line++;\par
01912         {\cf19 return} c;\par
01913     \}\par
01914 \par
01915 {\cf17 public}:\par
01916     BufferedFileInputStreamReader(std::FILE *file, {\cf17 const} std::string &name) : file(file), name(name), line(1) \{\par
01917         buffer = {\cf17 new} {\cf18 char}[BUFFER_SIZE];\par
01918         isEof = {\cf17 new} {\cf18 bool}[BUFFER_SIZE];\par
01919         bufferSize = MAX_UNREAD_COUNT;\par
01920         bufferPos = int(MAX_UNREAD_COUNT);\par
01921     \}\par
01922 \par
01923     ~BufferedFileInputStreamReader() \{\par
01924         {\cf19 if} (NULL != buffer) \{\par
01925             {\cf17 delete}[] buffer;\par
01926             buffer = NULL;\par
01927         \}\par
01928         {\cf19 if} (NULL != isEof) \{\par
01929             {\cf17 delete}[] isEof;\par
01930             isEof = NULL;\par
01931         \}\par
01932     \}\par
01933 \par
01934     {\cf18 void} setTestCase({\cf18 int}) \{\par
01935         __testlib_fail({\cf22 "setTestCase not implemented in BufferedFileInputStreamReader"});\par
01936     \}\par
01937 \par
01938     std::vector<int> getReadChars() \{\par
01939         __testlib_fail({\cf22 "getReadChars not implemented in BufferedFileInputStreamReader"});\par
01940     \}\par
01941     \par
01942     {\cf18 int} curChar() \{\par
01943         {\cf19 if} (!refill())\par
01944             {\cf19 return} EOFC;\par
01945 \par
01946         {\cf19 return} isEof[bufferPos] ? EOFC : buffer[bufferPos];\par
01947     \}\par
01948 \par
01949     {\cf18 int} nextChar() \{\par
01950         {\cf19 if} (!refill())\par
01951             {\cf19 return} EOFC;\par
01952 \par
01953         {\cf19 return} isEof[bufferPos] ? EOFC : increment();\par
01954     \}\par
01955 \par
01956     {\cf18 void} skipChar() \{\par
01957         increment();\par
01958     \}\par
01959 \par
01960     {\cf18 void} unreadChar({\cf18 int} c) \{\par
01961         bufferPos--;\par
01962         {\cf19 if} (bufferPos < 0)\par
01963             __testlib_fail({\cf22 "BufferedFileInputStreamReader::unreadChar(int): bufferPos < 0"});\par
01964         isEof[bufferPos] = (c == EOFC);\par
01965         buffer[bufferPos] = char(c);\par
01966         {\cf19 if} (c == LF)\par
01967             line--;\par
01968     \}\par
01969 \par
01970     std::string getName() \{\par
01971         {\cf19 return} name;\par
01972     \}\par
01973 \par
01974     {\cf18 int} getLine() \{\par
01975         {\cf19 return} line;\par
01976     \}\par
01977 \par
01978     {\cf18 bool} eof() \{\par
01979         {\cf19 return} !refill() || EOFC == curChar();\par
01980     \}\par
01981 \par
01982     {\cf18 void} close() \{\par
01983         {\cf19 if} (NULL != file) \{\par
01984             fclose(file);\par
01985             file = NULL;\par
01986         \}\par
01987     \}\par
01988 \};\par
01989 \par
01990 {\cf17 const} {\cf18 size_t} BufferedFileInputStreamReader::BUFFER_SIZE = 2000000;\par
01991 {\cf17 const} {\cf18 size_t} BufferedFileInputStreamReader::MAX_UNREAD_COUNT = BufferedFileInputStreamReader::BUFFER_SIZE / 2;\par
01992 \par
01993 {\cf20 /*}\par
01994 {\cf20  * Streams to be used for reading data in checkers or validators.}\par
01995 {\cf20  * Each read*() method moves pointer to the next character after the}\par
01996 {\cf20  * read value.}\par
01997 {\cf20  */}\par
01998 {\cf17 struct }InStream \{\par
01999     {\cf20 /* Do not use them. */}\par
02000     InStream();\par
02001 \par
02002     ~InStream();\par
02003 \par
02004     {\cf20 /* Wrap std::string with InStream. */}\par
02005     InStream({\cf17 const} InStream &baseStream, std::string content);\par
02006 \par
02007     InputStreamReader *reader;\par
02008     {\cf18 int} lastLine;\par
02009 \par
02010     std::string name;\par
02011     TMode mode;\par
02012     {\cf18 bool} opened;\par
02013     {\cf18 bool} stdfile;\par
02014     {\cf18 bool} strict;\par
02015 \par
02016     {\cf18 int} wordReserveSize;\par
02017     std::string _tmpReadToken;\par
02018 \par
02019     {\cf18 int} readManyIteration;\par
02020     {\cf18 size_t} maxFileSize;\par
02021     {\cf18 size_t} maxTokenLength;\par
02022     {\cf18 size_t} maxMessageLength;\par
02023 \par
02024     {\cf18 void} init(std::string fileName, TMode mode);\par
02025 \par
02026     {\cf18 void} init(std::FILE *f, TMode mode);\par
02027 \par
02028     {\cf18 void} setTestCase({\cf18 int} testCase);\par
02029     std::vector<int> getReadChars();\par
02030 \par
02031     {\cf20 /* Moves stream pointer to the first non-white-space character or EOF. */}\par
02032     {\cf18 void} skipBlanks();\par
02033 \par
02034     {\cf20 /* Returns current character in the stream. Doesn't remove it from stream. */}\par
02035     {\cf18 char} curChar();\par
02036 \par
02037     {\cf20 /* Moves stream pointer one character forward. */}\par
02038     {\cf18 void} skipChar();\par
02039 \par
02040     {\cf20 /* Returns current character and moves pointer one character forward. */}\par
02041     {\cf18 char} nextChar();\par
02042 \par
02043     {\cf20 /* Returns current character and moves pointer one character forward. */}\par
02044     {\cf18 char} readChar();\par
02045 \par
02046     {\cf20 /* As "readChar()" but ensures that the result is equal to given parameter. */}\par
02047     {\cf18 char} readChar({\cf18 char} c);\par
02048 \par
02049     {\cf20 /* As "readChar()" but ensures that the result is equal to the space (code=32). */}\par
02050     {\cf18 char} readSpace();\par
02051 \par
02052     {\cf20 /* Puts back the character into the stream. */}\par
02053     {\cf18 void} unreadChar({\cf18 char} c);\par
02054 \par
02055     {\cf20 /* Reopens stream, you should not use it. */}\par
02056     {\cf18 void} reset(std::FILE *file = NULL);\par
02057 \par
02058     {\cf20 /* Checks that current position is EOF. If not it doesn't move stream pointer. */}\par
02059     {\cf18 bool} eof();\par
02060 \par
02061     {\cf20 /* Moves pointer to the first non-white-space character and calls "eof()". */}\par
02062     {\cf18 bool} seekEof();\par
02063 \par
02064     {\cf20 /*}\par
02065 {\cf20      * Checks that current position contains EOLN.}\par
02066 {\cf20      * If not it doesn't move stream pointer.}\par
02067 {\cf20      * In strict mode expects "#13#10" for windows or "#10" for other platforms.}\par
02068 {\cf20      */}\par
02069     {\cf18 bool} eoln();\par
02070 \par
02071     {\cf20 /* Moves pointer to the first non-space and non-tab character and calls "eoln()". */}\par
02072     {\cf18 bool} seekEoln();\par
02073 \par
02074     {\cf20 /* Moves stream pointer to the first character of the next line (if exists). */}\par
02075     {\cf18 void} nextLine();\par
02076 \par
02077     {\cf20 /*}\par
02078 {\cf20      * Reads new token. Ignores white-spaces into the non-strict mode}\par
02079 {\cf20      * (strict mode is used in validators usually).}\par
02080 {\cf20      */}\par
02081     std::string readWord();\par
02082 \par
02083     {\cf20 /* The same as "readWord()", it is preferred to use "readToken()". */}\par
02084     std::string readToken();\par
02085 \par
02086     {\cf20 /* The same as "readWord()", but ensures that token matches to given pattern. */}\par
02087     std::string readWord({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02088 \par
02089     std::string readWord({\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02090 \par
02091     std::vector<std::string>\par
02092     readWords({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02093 \par
02094     std::vector<std::string>\par
02095     readWords({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02096 \par
02097     std::vector<std::string> readWords({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02098 \par
02099     {\cf20 /* The same as "readToken()", but ensures that token matches to given pattern. */}\par
02100     std::string readToken({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02101 \par
02102     std::string readToken({\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02103 \par
02104     std::vector<std::string>\par
02105     readTokens({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02106 \par
02107     std::vector<std::string>\par
02108     readTokens({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02109 \par
02110     std::vector<std::string> readTokens({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02111 \par
02112     {\cf18 void} readWordTo(std::string &result);\par
02113 \par
02114     {\cf18 void} readWordTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02115 \par
02116     {\cf18 void} readWordTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02117 \par
02118     {\cf18 void} readTokenTo(std::string &result);\par
02119 \par
02120     {\cf18 void} readTokenTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02121 \par
02122     {\cf18 void} readTokenTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02123 \par
02124     {\cf20 /*}\par
02125 {\cf20      * Reads new long long value. Ignores white-spaces into the non-strict mode}\par
02126 {\cf20      * (strict mode is used in validators usually).}\par
02127 {\cf20      */}\par
02128     {\cf18 long} {\cf18 long} readLong();\par
02129 \par
02130     {\cf18 unsigned} {\cf18 long} {\cf18 long} readUnsignedLong();\par
02131 \par
02132     {\cf20 /*}\par
02133 {\cf20      * Reads new int. Ignores white-spaces into the non-strict mode}\par
02134 {\cf20      * (strict mode is used in validators usually).}\par
02135 {\cf20      */}\par
02136     {\cf18 int} readInteger();\par
02137 \par
02138     {\cf20 /*}\par
02139 {\cf20      * Reads new int. Ignores white-spaces into the non-strict mode}\par
02140 {\cf20      * (strict mode is used in validators usually).}\par
02141 {\cf20      */}\par
02142     {\cf18 int} readInt();\par
02143 \par
02144     {\cf20 /* As "readLong()" but ensures that value in the range [minv,maxv]. */}\par
02145     {\cf18 long} {\cf18 long} readLong({\cf18 long} {\cf18 long} minv, {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02146 \par
02147     {\cf20 /* Reads space-separated sequence of long longs. */}\par
02148     std::vector<long long>\par
02149     readLongs({\cf18 int} size, {\cf18 long} {\cf18 long} minv, {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02150 \par
02151     {\cf20 /* Reads space-separated sequence of long longs. */}\par
02152     std::vector<long long> readLongs({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02153 \par
02154     {\cf18 unsigned} {\cf18 long} {\cf18 long}\par
02155     readUnsignedLong({\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02156 \par
02157     std::vector<unsigned long long>\par
02158     readUnsignedLongs({\cf18 int} size, {\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""},\par
02159                       {\cf18 int} indexBase = 1);\par
02160 \par
02161     std::vector<unsigned long long> readUnsignedLongs({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02162 \par
02163     {\cf18 unsigned} {\cf18 long} {\cf18 long} readLong({\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02164 \par
02165     std::vector<unsigned long long>\par
02166     readLongs({\cf18 int} size, {\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""},\par
02167               {\cf18 int} indexBase = 1);\par
02168 \par
02169     {\cf20 /* As "readInteger()" but ensures that value in the range [minv,maxv]. */}\par
02170     {\cf18 int} readInteger({\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02171 \par
02172     {\cf20 /* As "readInt()" but ensures that value in the range [minv,maxv]. */}\par
02173     {\cf18 int} readInt({\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02174 \par
02175     {\cf20 /* Reads space-separated sequence of integers. */}\par
02176     std::vector<int>\par
02177     readIntegers({\cf18 int} size, {\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02178 \par
02179     {\cf20 /* Reads space-separated sequence of integers. */}\par
02180     std::vector<int> readIntegers({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02181 \par
02182     {\cf20 /* Reads space-separated sequence of integers. */}\par
02183     std::vector<int> readInts({\cf18 int} size, {\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02184 \par
02185     {\cf20 /* Reads space-separated sequence of integers. */}\par
02186     std::vector<int> readInts({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02187 \par
02188     {\cf20 /*}\par
02189 {\cf20      * Reads new double. Ignores white-spaces into the non-strict mode}\par
02190 {\cf20      * (strict mode is used in validators usually).}\par
02191 {\cf20      */}\par
02192     {\cf18 double} readReal();\par
02193 \par
02194     {\cf20 /*}\par
02195 {\cf20      * Reads new double. Ignores white-spaces into the non-strict mode}\par
02196 {\cf20      * (strict mode is used in validators usually).}\par
02197 {\cf20      */}\par
02198     {\cf18 double} readDouble();\par
02199 \par
02200     {\cf20 /* As "readReal()" but ensures that value in the range [minv,maxv]. */}\par
02201     {\cf18 double} readReal({\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02202 \par
02203     std::vector<double>\par
02204     readReals({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02205 \par
02206     std::vector<double> readReals({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02207 \par
02208     {\cf20 /* As "readDouble()" but ensures that value in the range [minv,maxv]. */}\par
02209     {\cf18 double} readDouble({\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02210 \par
02211     std::vector<double>\par
02212     readDoubles({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02213 \par
02214     std::vector<double> readDoubles({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02215 \par
02216     {\cf20 /*}\par
02217 {\cf20      * As "readReal()" but ensures that value in the range [minv,maxv] and}\par
02218 {\cf20      * number of digit after the decimal point is in range [minAfterPointDigitCount,maxAfterPointDigitCount]}\par
02219 {\cf20      * and number is in the form "[-]digit(s)[.digit(s)]".}\par
02220 {\cf20      */}\par
02221     {\cf18 double} readStrictReal({\cf18 double} minv, {\cf18 double} maxv,\par
02222                           {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
02223                           {\cf17 const} std::string &variableName = {\cf22 ""});\par
02224 \par
02225     std::vector<double> readStrictReals({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv,\par
02226                                         {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
02227                                         {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02228 \par
02229     {\cf20 /*}\par
02230 {\cf20      * As "readDouble()" but ensures that value in the range [minv,maxv] and}\par
02231 {\cf20      * number of digit after the decimal point is in range [minAfterPointDigitCount,maxAfterPointDigitCount]}\par
02232 {\cf20      * and number is in the form "[-]digit(s)[.digit(s)]".}\par
02233 {\cf20      */}\par
02234     {\cf18 double} readStrictDouble({\cf18 double} minv, {\cf18 double} maxv,\par
02235                             {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
02236                             {\cf17 const} std::string &variableName = {\cf22 ""});\par
02237 \par
02238     std::vector<double> readStrictDoubles({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv,\par
02239                                           {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
02240                                           {\cf17 const} std::string &variablesName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02241 \par
02242     {\cf20 /* As readLine(). */}\par
02243     std::string readString();\par
02244 \par
02245     {\cf20 /* Read many lines. */}\par
02246     std::vector<std::string> readStrings({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02247 \par
02248     {\cf20 /* See readLine(). */}\par
02249     {\cf18 void} readStringTo(std::string &result);\par
02250 \par
02251     {\cf20 /* The same as "readLine()/readString()", but ensures that line matches to the given pattern. */}\par
02252     std::string readString({\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02253 \par
02254     {\cf20 /* The same as "readLine()/readString()", but ensures that line matches to the given pattern. */}\par
02255     std::string readString({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02256 \par
02257     {\cf20 /* Read many lines. */}\par
02258     std::vector<std::string>\par
02259     readStrings({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02260 \par
02261     {\cf20 /* Read many lines. */}\par
02262     std::vector<std::string>\par
02263     readStrings({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02264 \par
02265     {\cf20 /* The same as "readLine()/readString()", but ensures that line matches to the given pattern. */}\par
02266     {\cf18 void} readStringTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02267 \par
02268     {\cf20 /* The same as "readLine()/readString()", but ensures that line matches to the given pattern. */}\par
02269     {\cf18 void} readStringTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02270 \par
02271     {\cf20 /*}\par
02272 {\cf20      * Reads line from the current position to EOLN or EOF. Moves stream pointer to}\par
02273 {\cf20      * the first character of the new line (if possible).}\par
02274 {\cf20      */}\par
02275     std::string readLine();\par
02276 \par
02277     {\cf20 /* Read many lines. */}\par
02278     std::vector<std::string> readLines({\cf18 int} size, {\cf18 int} indexBase = 1);\par
02279 \par
02280     {\cf20 /* See readLine(). */}\par
02281     {\cf18 void} readLineTo(std::string &result);\par
02282 \par
02283     {\cf20 /* The same as "readLine()", but ensures that line matches to the given pattern. */}\par
02284     std::string readLine({\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02285 \par
02286     {\cf20 /* The same as "readLine()", but ensures that line matches to the given pattern. */}\par
02287     std::string readLine({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02288 \par
02289     {\cf20 /* Read many lines. */}\par
02290     std::vector<std::string>\par
02291     readLines({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02292 \par
02293     {\cf20 /* Read many lines. */}\par
02294     std::vector<std::string>\par
02295     readLines({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""}, {\cf18 int} indexBase = 1);\par
02296 \par
02297     {\cf20 /* The same as "readLine()", but ensures that line matches to the given pattern. */}\par
02298     {\cf18 void} readLineTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02299 \par
02300     {\cf20 /* The same as "readLine()", but ensures that line matches to the given pattern. */}\par
02301     {\cf18 void} readLineTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName = {\cf22 ""});\par
02302 \par
02303     {\cf20 /* Reads EOLN or fails. Use it in validators. Calls "eoln()" method internally. */}\par
02304     {\cf18 void} readEoln();\par
02305 \par
02306     {\cf20 /* Reads EOF or fails. Use it in validators. Calls "eof()" method internally. */}\par
02307     {\cf18 void} readEof();\par
02308 \par
02309     {\cf20 /*}\par
02310 {\cf20      * Quit-functions aborts program with <result> and <message>:}\par
02311 {\cf20      * input/answer streams replace any result to FAIL.}\par
02312 {\cf20      */}\par
02313     NORETURN {\cf18 void} quit(TResult result, {\cf17 const} {\cf18 char} *msg);\par
02314     {\cf20 /*}\par
02315 {\cf20      * Quit-functions aborts program with <result> and <message>:}\par
02316 {\cf20      * input/answer streams replace any result to FAIL.}\par
02317 {\cf20      */}\par
02318     NORETURN {\cf18 void} quitf(TResult result, {\cf17 const} {\cf18 char} *msg, ...);\par
02319 \par
02320     {\cf20 /*}\par
02321 {\cf20      * Quit-functions aborts program with <result> and <message>:}\par
02322 {\cf20      * input/answer streams replace any result to FAIL.}\par
02323 {\cf20      */}\par
02324     {\cf18 void} quitif({\cf18 bool} condition, TResult result, {\cf17 const} {\cf18 char} *msg, ...);\par
02325     {\cf20 /*}\par
02326 {\cf20      * Quit-functions aborts program with <result> and <message>:}\par
02327 {\cf20      * input/answer streams replace any result to FAIL.}\par
02328 {\cf20      */}\par
02329     NORETURN {\cf18 void} quits(TResult result, std::string msg);\par
02330 \par
02331     {\cf20 /*}\par
02332 {\cf20      * Checks condition and aborts a program if condition is false.}\par
02333 {\cf20      * Returns _wa for ouf and _fail on any other streams.}\par
02334 {\cf20      */}\par
02335 {\cf21 #ifdef __GNUC__}\par
02336     __attribute__ ((format (printf, 3, 4)))\par
02337 {\cf21 #endif}\par
02338     {\cf18 void} ensuref({\cf18 bool} cond, {\cf17 const} {\cf18 char} *format, ...);\par
02339 \par
02340     {\cf18 void} __testlib_ensure({\cf18 bool} cond, std::string message);\par
02341 \par
02342     {\cf18 void} close();\par
02343 \par
02344     {\cf17 const} {\cf17 static} {\cf18 int} NO_INDEX = INT_MAX;\par
02345     {\cf17 const} {\cf17 static} {\cf18 char} OPEN_BRACKET = char(11);\par
02346     {\cf17 const} {\cf17 static} {\cf18 char} CLOSE_BRACKET = char(17);\par
02347 \par
02348     {\cf17 const} {\cf17 static} WORD LightGray = 0x07;\par
02349     {\cf17 const} {\cf17 static} WORD LightRed = 0x0c;\par
02350     {\cf17 const} {\cf17 static} WORD LightCyan = 0x0b;\par
02351     {\cf17 const} {\cf17 static} WORD LightGreen = 0x0a;\par
02352     {\cf17 const} {\cf17 static} WORD LightYellow = 0x0e;\par
02353 \par
02354     {\cf17 static} {\cf18 void} textColor(WORD color);\par
02355 \par
02356     {\cf17 static} {\cf18 void} quitscr(WORD color, {\cf17 const} {\cf18 char} *msg);\par
02357 \par
02358     {\cf17 static} {\cf18 void} quitscrS(WORD color, std::string msg);\par
02359 \par
02360     {\cf18 void} xmlSafeWrite(std::FILE *file, {\cf17 const} {\cf18 char} *msg);\par
02361 \par
02362     {\cf20 /* Skips UTF-8 Byte Order Mark. */}\par
02363     {\cf18 void} skipBom();\par
02364 \par
02365 {\cf17 private}:\par
02366     InStream({\cf17 const} InStream &);\par
02367 \par
02368     InStream &operator=({\cf17 const} InStream &);\par
02369 \};\par
02370 \par
02371 InStream inf;\par
02372 InStream ouf;\par
02373 InStream ans;\par
02374 {\cf18 bool} appesMode;\par
02375 std::string appesModeEncoding = {\cf22 "windows-1251"};\par
02376 std::string resultName;\par
02377 std::string checkerName = {\cf22 "untitled checker"};\par
02378 random_t rnd;\par
02379 TTestlibMode testlibMode = _unknown;\par
02380 {\cf18 double} __testlib_points = std::numeric_limits<float>::infinity();\par
02381 \par
02382 {\cf17 const} {\cf18 size_t} VALIDATOR_MAX_VARIABLE_COUNT = 255;\par
02383 \par
02384 {\cf17 struct }ValidatorBoundsHit \{\par
02385     {\cf17 static} {\cf17 const} {\cf18 double} EPS;\par
02386     {\cf18 bool} minHit;\par
02387     {\cf18 bool} maxHit;\par
02388 \par
02389     ValidatorBoundsHit({\cf18 bool} minHit = {\cf17 false}, {\cf18 bool} maxHit = {\cf17 false}) : minHit(minHit), maxHit(maxHit) \{\par
02390     \};\par
02391 \par
02392     ValidatorBoundsHit merge({\cf17 const} ValidatorBoundsHit &validatorBoundsHit, {\cf18 bool} ignoreMinBound, {\cf18 bool} ignoreMaxBound) \{\par
02393         {\cf19 return} ValidatorBoundsHit(\par
02394                 __testlib_max(minHit, validatorBoundsHit.minHit) || ignoreMinBound,\par
02395                 __testlib_max(maxHit, validatorBoundsHit.maxHit) || ignoreMaxBound\par
02396         );\par
02397     \}\par
02398 \};\par
02399 \par
02400 {\cf17 struct }ConstantBound \{\par
02401     std::string value;\par
02402     {\cf18 bool} broken;\par
02403 \par
02404     {\cf17 template}<{\cf17 typename} T>\par
02405     {\cf18 void} adjust(T t) \{\par
02406         std::string t_string = std::to_string(t);\par
02407         {\cf19 if} (t_string.length() >= 32) \{\par
02408             broken = {\cf17 true};\par
02409             value = {\cf22 ""};\par
02410         \} {\cf19 else} \{\par
02411             {\cf19 if} (!broken && value.empty())\par
02412                 value = t_string;\par
02413             {\cf19 if} (!broken && value != t_string) \{\par
02414                 broken = {\cf17 true};\par
02415                 value = {\cf22 ""};\par
02416             \}\par
02417         \}\par
02418     \}\par
02419 \par
02420     {\cf18 bool} has_value() \{\par
02421         {\cf19 return} !value.empty() && !broken && value.length() < 32;\par
02422     \}\par
02423 \};\par
02424 \par
02425 {\cf17 struct }ConstantBounds \{\par
02426     ConstantBound lowerBound;\par
02427     ConstantBound upperBound;\par
02428 \};\par
02429 \par
02430 {\cf17 const} {\cf18 double} ValidatorBoundsHit::EPS = 1E-12;\par
02431 \par
02432 {\cf17 class }Validator \{\par
02433 {\cf17 private}:\par
02434     {\cf17 const} {\cf17 static} std::string TEST_MARKUP_HEADER;\par
02435     {\cf17 const} {\cf17 static} std::string TEST_CASE_OPEN_TAG;\par
02436     {\cf17 const} {\cf17 static} std::string TEST_CASE_CLOSE_TAG;\par
02437 \par
02438     {\cf18 bool} _initialized;\par
02439     std::string _testset;\par
02440     std::string _group;\par
02441 \par
02442     std::string _testOverviewLogFileName;\par
02443     std::string _testMarkupFileName;\par
02444     {\cf18 int} _testCase = -1;\par
02445     std::string _testCaseFileName;\par
02446 \par
02447     std::map<std::string, ValidatorBoundsHit> _boundsHitByVariableName;\par
02448     std::map<std::string, ConstantBounds> _constantBoundsByVariableName;\par
02449     std::set<std::string> _features;\par
02450     std::set<std::string> _hitFeatures;\par
02451     std::set<std::string> _variables;\par
02452 \par
02453     {\cf18 bool} isVariableNameBoundsAnalyzable({\cf17 const} std::string &variableName) \{\par
02454         {\cf19 for} ({\cf18 size_t} i = 0; i < variableName.length(); i++)\par
02455             {\cf19 if} ((variableName[i] >= {\cf23 '0'} && variableName[i] <= {\cf23 '9'}) || variableName[i] < {\cf23 ' '})\par
02456                 {\cf19 return} {\cf17 false};\par
02457         {\cf19 return} {\cf17 true};\par
02458     \}\par
02459 \par
02460     {\cf18 bool} isFeatureNameAnalyzable({\cf17 const} std::string &featureName) \{\par
02461         {\cf19 for} ({\cf18 size_t} i = 0; i < featureName.length(); i++)\par
02462             {\cf19 if} (featureName[i] < {\cf23 ' '})\par
02463                 {\cf19 return} {\cf17 false};\par
02464         {\cf19 return} {\cf17 true};\par
02465     \}\par
02466 \par
02467 {\cf17 public}:\par
02468     Validator() : _initialized(false), _testset({\cf22 "tests"}), _group() \{\par
02469     \}\par
02470 \par
02471     {\cf18 void} initialize() \{\par
02472         _initialized = {\cf17 true};\par
02473     \}\par
02474 \par
02475     std::string testset(){\cf17  const }\{\par
02476         {\cf19 if} (!_initialized)\par
02477             __testlib_fail({\cf22 "Validator should be initialized with registerValidation(argc, argv) instead of registerValidation() to support validator.testset()"});\par
02478         {\cf19 return} _testset;\par
02479     \}\par
02480 \par
02481     std::string group(){\cf17  const }\{\par
02482         {\cf19 if} (!_initialized)\par
02483             __testlib_fail({\cf22 "Validator should be initialized with registerValidation(argc, argv) instead of registerValidation() to support validator.group()"});\par
02484         {\cf19 return} _group;\par
02485     \}\par
02486 \par
02487     std::string testOverviewLogFileName(){\cf17  const }\{\par
02488         {\cf19 return} _testOverviewLogFileName;\par
02489     \}\par
02490 \par
02491     std::string testMarkupFileName(){\cf17  const }\{\par
02492         {\cf19 return} _testMarkupFileName;\par
02493     \}\par
02494 \par
02495     {\cf18 int} testCase(){\cf17  const }\{\par
02496         {\cf19 return} _testCase;\par
02497     \}\par
02498 \par
02499     std::string testCaseFileName(){\cf17  const }\{\par
02500         {\cf19 return} _testCaseFileName;\par
02501     \}\par
02502 \par
02503     {\cf18 void} setTestset({\cf17 const} {\cf18 char} *{\cf17 const} testset) \{\par
02504         _testset = testset;\par
02505     \}\par
02506 \par
02507     {\cf18 void} setGroup({\cf17 const} {\cf18 char} *{\cf17 const} group) \{\par
02508         _group = group;\par
02509     \}\par
02510 \par
02511     {\cf18 void} setTestOverviewLogFileName({\cf17 const} {\cf18 char} *{\cf17 const} testOverviewLogFileName) \{\par
02512         _testOverviewLogFileName = testOverviewLogFileName;\par
02513     \}\par
02514 \par
02515     {\cf18 void} setTestMarkupFileName({\cf17 const} {\cf18 char} *{\cf17 const} testMarkupFileName) \{\par
02516         _testMarkupFileName = testMarkupFileName;\par
02517     \}\par
02518 \par
02519     {\cf18 void} setTestCase({\cf18 int} testCase) \{\par
02520         _testCase = testCase;\par
02521     \}\par
02522 \par
02523     {\cf18 void} setTestCaseFileName({\cf17 const} {\cf18 char} *{\cf17 const} testCaseFileName) \{\par
02524         _testCaseFileName = testCaseFileName;\par
02525     \}\par
02526 \par
02527     std::string prepVariableName({\cf17 const} std::string &variableName) \{\par
02528         {\cf19 if} (variableName.length() >= 2 && variableName != {\cf22 "~~"}) \{\par
02529             {\cf19 if} (variableName[0] == {\cf23 '~'} && variableName.back() != {\cf23 '~'})\par
02530                 {\cf19 return} variableName.substr(1);\par
02531             {\cf19 if} (variableName[0] != {\cf23 '~'} && variableName.back() == {\cf23 '~'})\par
02532                 {\cf19 return} variableName.substr(0, variableName.length() - 1);\par
02533             {\cf19 if} (variableName[0] == {\cf23 '~'} && variableName.back() == {\cf23 '~'})\par
02534                 {\cf19 return} variableName.substr(1, variableName.length() - 2);\par
02535         \}\par
02536         {\cf19 return} variableName;\par
02537     \}\par
02538 \par
02539     {\cf18 bool} ignoreMinBound({\cf17 const} std::string &variableName) \{\par
02540         {\cf19 return} variableName.length() >= 2 && variableName != {\cf22 "~~"} && variableName[0] == {\cf23 '~'};\par
02541     \}\par
02542 \par
02543     {\cf18 bool} ignoreMaxBound({\cf17 const} std::string &variableName) \{\par
02544         {\cf19 return} variableName.length() >= 2 && variableName != {\cf22 "~~"} && variableName.back() == {\cf23 '~'};\par
02545     \}\par
02546 \par
02547     {\cf18 void} addBoundsHit({\cf17 const} std::string &variableName, ValidatorBoundsHit boundsHit) \{\par
02548         {\cf19 if} (isVariableNameBoundsAnalyzable(variableName)\par
02549                 && _boundsHitByVariableName.size() < VALIDATOR_MAX_VARIABLE_COUNT) \{\par
02550             std::string preparedVariableName = prepVariableName(variableName);\par
02551             _boundsHitByVariableName[preparedVariableName] = boundsHit.merge(_boundsHitByVariableName[preparedVariableName],\par
02552                 ignoreMinBound(variableName), ignoreMaxBound(variableName));\par
02553         \}\par
02554     \}\par
02555 \par
02556     {\cf18 void} addVariable({\cf17 const} std::string &variableName) \{\par
02557         {\cf19 if} (isVariableNameBoundsAnalyzable(variableName)\par
02558                 && _variables.size() < VALIDATOR_MAX_VARIABLE_COUNT) \{\par
02559             std::string preparedVariableName = prepVariableName(variableName);\par
02560             _variables.insert(preparedVariableName);\par
02561         \}\par
02562     \}\par
02563 \par
02564     std::string getVariablesLog() \{\par
02565         std::string result;\par
02566         {\cf19 for} ({\cf17 const} std::string &variableName: _variables)\par
02567             result += {\cf22 "variable \\""} + variableName + {\cf22 "\\"\\n"};\par
02568         {\cf19 return} result;\par
02569     \}\par
02570 \par
02571     {\cf17 template}<{\cf17 typename} T>\par
02572     {\cf18 void} adjustConstantBounds({\cf17 const} std::string &variableName, T lower, T upper) \{\par
02573         {\cf19 if} (isVariableNameBoundsAnalyzable(variableName)\par
02574                 && _constantBoundsByVariableName.size() < VALIDATOR_MAX_VARIABLE_COUNT) \{\par
02575             std::string preparedVariableName = prepVariableName(variableName);\par
02576             _constantBoundsByVariableName[preparedVariableName].lowerBound.adjust(lower);\par
02577             _constantBoundsByVariableName[preparedVariableName].upperBound.adjust(upper);\par
02578         \}\par
02579     \}\par
02580 \par
02581     std::string getBoundsHitLog() \{\par
02582         std::string result;\par
02583         {\cf19 for} (std::map<std::string, ValidatorBoundsHit>::iterator i = _boundsHitByVariableName.begin();\par
02584              i != _boundsHitByVariableName.end();\par
02585              i++) \{\par
02586             result += {\cf22 "\\""} + i->first + {\cf22 "\\":"};\par
02587             {\cf19 if} (i->second.minHit)\par
02588                 result += {\cf22 " min-value-hit"};\par
02589             {\cf19 if} (i->second.maxHit)\par
02590                 result += {\cf22 " max-value-hit"};\par
02591             result += {\cf22 "\\n"};\par
02592         \}\par
02593         {\cf19 return} result;\par
02594     \}\par
02595 \par
02596     std::string getConstantBoundsLog() \{\par
02597         std::string result;\par
02598         {\cf19 for} (std::map<std::string, ConstantBounds>::iterator i = _constantBoundsByVariableName.begin();\par
02599              i != _constantBoundsByVariableName.end();\par
02600              i++) \{\par
02601             {\cf19 if} (i->second.lowerBound.has_value() || i->second.upperBound.has_value()) \{\par
02602                 result += {\cf22 "constant-bounds \\""} + i->first + {\cf22 "\\":"};\par
02603                 {\cf19 if} (i->second.lowerBound.has_value())\par
02604                     result += {\cf22 " "} + i->second.lowerBound.value;\par
02605                 {\cf19 else}\par
02606                     result += {\cf22 " ?"};\par
02607                 {\cf19 if} (i->second.upperBound.has_value())\par
02608                     result += {\cf22 " "} + i->second.upperBound.value;\par
02609                 {\cf19 else}\par
02610                     result += {\cf22 " ?"};\par
02611                 result += {\cf22 "\\n"};\par
02612             \}\par
02613         \}\par
02614         {\cf19 return} result;\par
02615     \}\par
02616 \par
02617     std::string getFeaturesLog() \{\par
02618         std::string result;\par
02619         {\cf19 for} (std::set<std::string>::iterator i = _features.begin();\par
02620              i != _features.end();\par
02621              i++) \{\par
02622             result += {\cf22 "feature \\""} + *i + {\cf22 "\\":"};\par
02623             {\cf19 if} (_hitFeatures.count(*i))\par
02624                 result += {\cf22 " hit"};\par
02625             result += {\cf22 "\\n"};\par
02626         \}\par
02627         {\cf19 return} result;\par
02628     \}\par
02629 \par
02630     {\cf18 void} writeTestOverviewLog() \{\par
02631         {\cf19 if} (!_testOverviewLogFileName.empty()) \{\par
02632             std::string fileName(_testOverviewLogFileName);\par
02633             _testOverviewLogFileName = {\cf22 ""};\par
02634 \par
02635             FILE* f;\par
02636             {\cf18 bool} standard_file = {\cf17 false};\par
02637             {\cf19 if} (fileName == {\cf22 "stdout"})\par
02638                 f = stdout, standard_file = {\cf17 true};\par
02639             {\cf19 else} {\cf19 if} (fileName == {\cf22 "stderr"})\par
02640                 f = stderr, standard_file = {\cf17 true};\par
02641             {\cf19 else} \{\par
02642                 f = fopen(fileName.c_str(), {\cf22 "wb"});\par
02643                 {\cf19 if} (NULL == f)\par
02644                     __testlib_fail({\cf22 "Validator::writeTestOverviewLog: can't write test overview log to ("} + fileName + {\cf22 ")"});\par
02645             \}\par
02646             fprintf(f, {\cf22 "%s%s%s%s"},\par
02647                 getBoundsHitLog().c_str(),\par
02648                 getFeaturesLog().c_str(),\par
02649                 getConstantBoundsLog().c_str(),\par
02650                 getVariablesLog().c_str());\par
02651             std::fflush(f);\par
02652             {\cf19 if} (!standard_file)\par
02653                 {\cf19 if} (std::fclose(f))\par
02654                     __testlib_fail({\cf22 "Validator::writeTestOverviewLog: can't close test overview log file ("} + fileName + {\cf22 ")"});\par
02655         \}\par
02656     \}\par
02657 \par
02658     {\cf18 void} writeTestMarkup() \{\par
02659         {\cf19 if} (!_testMarkupFileName.empty()) \{\par
02660             std::vector<int> readChars = inf.getReadChars();\par
02661             {\cf19 if} (!readChars.empty()) \{\par
02662                 std::string markup(TEST_MARKUP_HEADER);\par
02663                 {\cf19 for} ({\cf18 size_t} i = 0; i < readChars.size(); i++) \{\par
02664                     {\cf18 int} c = readChars[i];\par
02665                     {\cf19 if} (i + 1 == readChars.size() && c == -1)\par
02666                         {\cf19 continue};\par
02667                     {\cf19 if} (c <= 256) \{\par
02668                         {\cf18 char} cc = char(c);\par
02669                         {\cf19 if} (cc == {\cf23 '\\\\'} || cc == {\cf23 '!'})\par
02670                             markup += {\cf23 '\\\\'};\par
02671                         markup += cc;\par
02672                     \} {\cf19 else} \{\par
02673                         markup += TEST_CASE_OPEN_TAG;\par
02674                         markup += toString(c - 256);\par
02675                         markup += TEST_CASE_CLOSE_TAG;\par
02676                     \}\par
02677                 \}\par
02678                 FILE* f;\par
02679                 {\cf18 bool} standard_file = {\cf17 false};\par
02680                 {\cf19 if} (_testMarkupFileName == {\cf22 "stdout"})\par
02681                     f = stdout, standard_file = {\cf17 true};\par
02682                 {\cf19 else} {\cf19 if} (_testMarkupFileName == {\cf22 "stderr"})\par
02683                     f = stderr, standard_file = {\cf17 true};\par
02684                 {\cf19 else} \{\par
02685                     f = fopen(_testMarkupFileName.c_str(), {\cf22 "wb"});\par
02686                     {\cf19 if} (NULL == f)\par
02687                         __testlib_fail({\cf22 "Validator::writeTestMarkup: can't write test markup to ("} + _testMarkupFileName + {\cf22 ")"});\par
02688                 \}\par
02689                 std::fprintf(f, {\cf22 "%s"}, markup.c_str());\par
02690                 std::fflush(f);\par
02691                 {\cf19 if} (!standard_file)\par
02692                     {\cf19 if} (std::fclose(f))\par
02693                         __testlib_fail({\cf22 "Validator::writeTestMarkup: can't close test markup file ("} + _testCaseFileName + {\cf22 ")"});\par
02694             \}\par
02695         \}\par
02696     \}\par
02697 \par
02698     {\cf18 void} writeTestCase() \{\par
02699         {\cf19 if} (_testCase > 0) \{\par
02700             std::vector<int> readChars = inf.getReadChars();\par
02701             {\cf19 if} (!readChars.empty()) \{\par
02702                 std::string content, testCaseContent;\par
02703                 {\cf18 bool} matchedTestCase = {\cf17 false};\par
02704                 {\cf19 for} ({\cf18 size_t} i = 0; i < readChars.size(); i++) \{\par
02705                     {\cf18 int} c = readChars[i];\par
02706                     {\cf19 if} (i + 1 == readChars.size() && c == -1)\par
02707                         {\cf19 continue};\par
02708                     {\cf19 if} (c <= 256)\par
02709                         content += char(c);\par
02710                     {\cf19 else} \{\par
02711                         {\cf19 if} (matchedTestCase) \{\par
02712                             testCaseContent = content;\par
02713                             matchedTestCase = {\cf17 false};\par
02714                         \}\par
02715                         content = {\cf22 ""};\par
02716                         {\cf18 int} testCase = c - 256;\par
02717                         {\cf19 if} (testCase == _testCase)\par
02718                             matchedTestCase = {\cf17 true};\par
02719                     \}\par
02720                 \}\par
02721                 {\cf19 if} (matchedTestCase)\par
02722                     testCaseContent = content;\par
02723 \par
02724                 {\cf19 if} (!testCaseContent.empty()) \{\par
02725                     FILE* f;\par
02726                     {\cf18 bool} standard_file = {\cf17 false};\par
02727                     {\cf19 if} (_testCaseFileName.empty() || _testCaseFileName == {\cf22 "stdout"})\par
02728                         f = stdout, standard_file = {\cf17 true};\par
02729                     {\cf19 else} {\cf19 if} (_testCaseFileName == {\cf22 "stderr"})\par
02730                         f = stderr, standard_file = {\cf17 true};\par
02731                     {\cf19 else} \{\par
02732                         f = fopen(_testCaseFileName.c_str(), {\cf22 "wb"});\par
02733                         {\cf19 if} (NULL == f)\par
02734                             __testlib_fail({\cf22 "Validator::writeTestCase: can't write test case to ("} + _testCaseFileName + {\cf22 ")"});\par
02735                     \}\par
02736                     std::fprintf(f, {\cf22 "%s"}, testCaseContent.c_str());\par
02737                     std::fflush(f);\par
02738                     {\cf19 if} (!standard_file)\par
02739                         {\cf19 if} (std::fclose(f))\par
02740                             __testlib_fail({\cf22 "Validator::writeTestCase: can't close test case file ("} + _testCaseFileName + {\cf22 ")"});\par
02741                 \}\par
02742             \}\par
02743         \}\par
02744     \}\par
02745 \par
02746     {\cf18 void} addFeature({\cf17 const} std::string &feature) \{\par
02747         {\cf19 if} (_features.count(feature))\par
02748             __testlib_fail({\cf22 "Feature "} + feature + {\cf22 " registered twice."});\par
02749         {\cf19 if} (!isFeatureNameAnalyzable(feature))\par
02750             __testlib_fail({\cf22 "Feature name '"} + feature + {\cf22 "' contains restricted characters."});\par
02751 \par
02752         _features.insert(feature);\par
02753     \}\par
02754 \par
02755     {\cf18 void} feature({\cf17 const} std::string &feature) \{\par
02756         {\cf19 if} (!isFeatureNameAnalyzable(feature))\par
02757             __testlib_fail({\cf22 "Feature name '"} + feature + {\cf22 "' contains restricted characters."});\par
02758 \par
02759         {\cf19 if} (!_features.count(feature))\par
02760             __testlib_fail({\cf22 "Feature "} + feature + {\cf22 " didn't registered via addFeature(feature)."});\par
02761 \par
02762         _hitFeatures.insert(feature);\par
02763     \}\par
02764 \} validator;\par
02765 \par
02766 {\cf17 const} std::string Validator::TEST_MARKUP_HEADER = {\cf22 "MU\\xF3\\x01"};\par
02767 {\cf17 const} std::string Validator::TEST_CASE_OPEN_TAG = {\cf22 "!c"};\par
02768 {\cf17 const} std::string Validator::TEST_CASE_CLOSE_TAG = {\cf22 ";"};\par
02769 \par
02770 {\cf17 struct }TestlibFinalizeGuard \{\par
02771     {\cf17 static} {\cf18 bool} alive;\par
02772     {\cf17 static} {\cf18 bool} registered;\par
02773 \par
02774     {\cf18 int} quitCount, readEofCount;\par
02775 \par
02776     TestlibFinalizeGuard() : quitCount(0), readEofCount(0) \{\par
02777         {\cf20 // No operations.}\par
02778     \}\par
02779 \par
02780     ~TestlibFinalizeGuard() \{\par
02781         {\cf18 bool} _alive = alive;\par
02782         alive = {\cf17 false};\par
02783 \par
02784         {\cf19 if} (_alive) \{\par
02785             {\cf19 if} (testlibMode == _checker && quitCount == 0)\par
02786                 __testlib_fail({\cf22 "Checker must end with quit or quitf call."});\par
02787 \par
02788             {\cf19 if} (testlibMode == _validator && readEofCount == 0 && quitCount == 0)\par
02789                 __testlib_fail({\cf22 "Validator must end with readEof call."});\par
02790 \par
02791             {\cf20 /* opts */}\par
02792             autoEnsureNoUnusedOpts();\par
02793 \par
02794             {\cf19 if} (!registered)\par
02795                 __testlib_fail({\cf22 "Call register-function in the first line of the main (registerTestlibCmd or other similar)"});\par
02796         \}\par
02797 \par
02798         {\cf19 if} (__testlib_exitCode == 0) \{\par
02799             validator.writeTestOverviewLog();\par
02800             validator.writeTestMarkup();\par
02801             validator.writeTestCase();\par
02802         \}\par
02803     \}\par
02804 \par
02805 {\cf17 private}:\par
02806     {\cf20 /* opts */}\par
02807     {\cf18 void} autoEnsureNoUnusedOpts();\par
02808 \};\par
02809 \par
02810 {\cf18 bool} TestlibFinalizeGuard::alive = {\cf17 true};\par
02811 {\cf18 bool} TestlibFinalizeGuard::registered = {\cf17 false};\par
02812 {\cf17 extern} TestlibFinalizeGuard testlibFinalizeGuard;\par
02813 \par
02814 {\cf20 /*}\par
02815 {\cf20  * Call it to disable checks on finalization.}\par
02816 {\cf20  */}\par
02817 {\cf18 void} disableFinalizeGuard() \{\par
02818     TestlibFinalizeGuard::alive = {\cf17 false};\par
02819 \}\par
02820 \par
02821 {\cf20 /* Interactor streams.}\par
02822 {\cf20  */}\par
02823 std::fstream tout;\par
02824 \par
02825 {\cf20 /* implementation}\par
02826 {\cf20  */}\par
02827 \par
02828 InStream::InStream() \{\par
02829     reader = NULL;\par
02830     lastLine = -1;\par
02831     opened = {\cf17 false};\par
02832     name = {\cf22 ""};\par
02833     mode = _input;\par
02834     strict = {\cf17 false};\par
02835     stdfile = {\cf17 false};\par
02836     wordReserveSize = 4;\par
02837     readManyIteration = NO_INDEX;\par
02838     maxFileSize = 128 * 1024 * 1024; {\cf20 // 128MB.}\par
02839     maxTokenLength = 32 * 1024 * 1024; {\cf20 // 32MB.}\par
02840     maxMessageLength = 32000;\par
02841 \}\par
02842 \par
02843 InStream::InStream({\cf17 const} InStream &baseStream, std::string content) \{\par
02844     reader = {\cf17 new} StringInputStreamReader(content);\par
02845     lastLine = -1;\par
02846     opened = {\cf17 true};\par
02847     strict = baseStream.strict;\par
02848     stdfile = {\cf17 false};\par
02849     mode = baseStream.mode;\par
02850     name = {\cf22 "based on "} + baseStream.name;\par
02851     readManyIteration = NO_INDEX;\par
02852     maxFileSize = 128 * 1024 * 1024; {\cf20 // 128MB.}\par
02853     maxTokenLength = 32 * 1024 * 1024; {\cf20 // 32MB.}\par
02854     maxMessageLength = 32000;\par
02855 \}\par
02856 \par
02857 InStream::~InStream() \{\par
02858     {\cf19 if} (NULL != reader) \{\par
02859         reader->close();\par
02860         {\cf17 delete} reader;\par
02861         reader = NULL;\par
02862     \}\par
02863 \}\par
02864 \par
02865 {\cf18 void} InStream::setTestCase({\cf18 int} testCase) \{\par
02866     {\cf19 if} (testlibMode != _validator || mode != _input || !stdfile || {\cf17 this} != &inf)\par
02867         __testlib_fail({\cf22 "InStream::setTestCase can be used only for inf in validator-mode."}\par
02868             {\cf22 " Actually, prefer setTestCase function instead of InStream member"});\par
02869     reader->setTestCase(testCase);\par
02870 \}\par
02871 \par
02872 std::vector<int> InStream::getReadChars() \{\par
02873     {\cf19 if} (testlibMode != _validator || mode != _input || !stdfile || {\cf17 this} != &inf)\par
02874         __testlib_fail({\cf22 "InStream::getReadChars can be used only for inf in validator-mode."});\par
02875     {\cf19 return} reader == NULL ? std::vector<int>() : reader->getReadChars();\par
02876 \}\par
02877 \par
02878 {\cf18 void} setTestCase({\cf18 int} testCase) \{\par
02879     {\cf17 static} {\cf18 bool} first_run = {\cf17 true};\par
02880     {\cf17 static} {\cf18 bool} zero_based = {\cf17 false};\par
02881 \par
02882     {\cf19 if} (first_run && testCase == 0)\par
02883         zero_based = {\cf17 true};\par
02884 \par
02885     {\cf19 if} (zero_based)\par
02886         testCase++;\par
02887 \par
02888     __testlib_hasTestCase = {\cf17 true};\par
02889     __testlib_testCase = testCase;\par
02890 \par
02891     {\cf19 if} (testlibMode == _validator)\par
02892         inf.setTestCase(testCase);\par
02893 \par
02894     first_run = {\cf17 false};\par
02895 \}\par
02896 \par
02897 {\cf21 #ifdef __GNUC__}\par
02898 __attribute__(({\cf17 const}))\par
02899 {\cf21 #endif}\par
02900 {\cf18 int} resultExitCode(TResult r) \{\par
02901     {\cf19 if} (r == _ok)\par
02902         {\cf19 return} OK_EXIT_CODE;\par
02903     {\cf19 if} (r == _wa)\par
02904         {\cf19 return} WA_EXIT_CODE;\par
02905     {\cf19 if} (r == _pe)\par
02906         {\cf19 return} PE_EXIT_CODE;\par
02907     {\cf19 if} (r == _fail)\par
02908         {\cf19 return} FAIL_EXIT_CODE;\par
02909     {\cf19 if} (r == _dirt)\par
02910         {\cf19 return} DIRT_EXIT_CODE;\par
02911     {\cf19 if} (r == _points)\par
02912         {\cf19 return} POINTS_EXIT_CODE;\par
02913     {\cf19 if} (r == _unexpected_eof)\par
02914 {\cf21 #ifdef ENABLE_UNEXPECTED_EOF}\par
02915         {\cf19 return} UNEXPECTED_EOF_EXIT_CODE;\par
02916 {\cf21 #else}\par
02917         {\cf19 return} PE_EXIT_CODE;\par
02918 {\cf21 #endif}\par
02919     {\cf19 if} (r >= _partially)\par
02920         {\cf19 return} PC_BASE_EXIT_CODE + (r - _partially);\par
02921     {\cf19 return} FAIL_EXIT_CODE;\par
02922 \}\par
02923 \par
02924 {\cf18 void} InStream::textColor(\par
02925 #{\cf19 if} !(defined(ON_WINDOWS) && (!defined(_MSC_VER) || _MSC_VER > 1400)) && defined(__GNUC__)\par
02926         __attribute__((unused))\par
02927 #endif\par
02928         WORD color\par
02929 ) \{\par
02930 {\cf21 #if defined(ON_WINDOWS) && (!defined(_MSC_VER) || _MSC_VER > 1400)}\par
02931     HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);\par
02932     SetConsoleTextAttribute(handle, color);\par
02933 {\cf21 #endif}\par
02934 {\cf21 #if !defined(ON_WINDOWS) && defined(__GNUC__)}\par
02935     {\cf19 if} (isatty(2))\par
02936     \{\par
02937         {\cf19 switch} (color)\par
02938         \{\par
02939         {\cf19 case} LightRed:\par
02940             fprintf(stderr, {\cf22 "\\033[1;31m"});\par
02941             {\cf19 break};\par
02942         {\cf19 case} LightCyan:\par
02943             fprintf(stderr, {\cf22 "\\033[1;36m"});\par
02944             {\cf19 break};\par
02945         {\cf19 case} LightGreen:\par
02946             fprintf(stderr, {\cf22 "\\033[1;32m"});\par
02947             {\cf19 break};\par
02948         {\cf19 case} LightYellow:\par
02949             fprintf(stderr, {\cf22 "\\033[1;33m"});\par
02950             {\cf19 break};\par
02951         {\cf19 case} LightGray:\par
02952         {\cf19 default}:\par
02953             fprintf(stderr, {\cf22 "\\033[0m"});\par
02954         \}\par
02955     \}\par
02956 {\cf21 #endif}\par
02957 \}\par
02958 \par
02959 {\cf21 #ifdef TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT}\par
02960 {\cf17 class }exit_exception: {\cf17 public} std::exception \{\par
02961 {\cf17 private}:\par
02962     {\cf18 int} exitCode;\par
02963 {\cf17 public}:\par
02964     exit_exception({\cf18 int} exitCode): exitCode(exitCode) \{\}\par
02965     {\cf18 int} getExitCode() \{ {\cf19 return} exitCode; \}\par
02966 \};\par
02967 {\cf21 #endif}\par
02968 \par
02969 NORETURN {\cf18 void} halt({\cf18 int} exitCode) \{\par
02970 {\cf21 #ifdef FOOTER}\par
02971     InStream::textColor(InStream::LightGray);\par
02972     std::fprintf(stderr, {\cf22 "Checker: \\"%s\\"\\n"}, checkerName.c_str());\par
02973     std::fprintf(stderr, {\cf22 "Exit code: %d\\n"}, exitCode);\par
02974     InStream::textColor(InStream::LightGray);\par
02975 {\cf21 #endif}\par
02976     __testlib_exitCode = exitCode;\par
02977 {\cf21 #ifdef TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT}\par
02978     {\cf19 throw} exit_exception(exitCode);\par
02979 {\cf21 #endif}\par
02980     std::exit(exitCode);\par
02981 \}\par
02982 \par
02983 {\cf17 static} {\cf18 bool} __testlib_shouldCheckDirt(TResult result) \{\par
02984     {\cf19 return} result == _ok || result == _points || result >= _partially;\par
02985 \}\par
02986 \par
02987 {\cf17 static} std::string __testlib_appendMessage({\cf17 const} std::string &message, {\cf17 const} std::string &extra) \{\par
02988     {\cf18 int} openPos = -1, closePos = -1;\par
02989     {\cf19 for} ({\cf18 size_t} i = 0; i < message.length(); i++) \{\par
02990         {\cf19 if} (message[i] == InStream::OPEN_BRACKET) \{\par
02991             {\cf19 if} (openPos == -1)\par
02992                 openPos = int(i);\par
02993             {\cf19 else}\par
02994                 openPos = INT_MAX;\par
02995         \}\par
02996         {\cf19 if} (message[i] == InStream::CLOSE_BRACKET) \{\par
02997             {\cf19 if} (closePos == -1)\par
02998                 closePos = int(i);\par
02999             {\cf19 else}\par
03000                 closePos = INT_MAX;\par
03001         \}\par
03002     \}\par
03003     {\cf19 if} (openPos != -1 && openPos != INT_MAX\par
03004         && closePos != -1 && closePos != INT_MAX\par
03005         && openPos < closePos) \{\par
03006         {\cf18 size_t} index = message.find(extra, openPos);\par
03007         {\cf19 if} (index == std::string::npos || {\cf18 int}(index) >= closePos) \{\par
03008             std::string result(message);\par
03009             result.insert(closePos, {\cf22 ", "} + extra);\par
03010             {\cf19 return} result;\par
03011         \}\par
03012         {\cf19 return} message;\par
03013     \}\par
03014 \par
03015     {\cf19 return} message + {\cf22 " "} + InStream::OPEN_BRACKET + extra + InStream::CLOSE_BRACKET;\par
03016 \}\par
03017 \par
03018 {\cf17 static} std::string __testlib_toPrintableMessage({\cf17 const} std::string &message) \{\par
03019     {\cf18 int} openPos = -1, closePos = -1;\par
03020     {\cf19 for} ({\cf18 size_t} i = 0; i < message.length(); i++) \{\par
03021         {\cf19 if} (message[i] == InStream::OPEN_BRACKET) \{\par
03022             {\cf19 if} (openPos == -1)\par
03023                 openPos = int(i);\par
03024             {\cf19 else}\par
03025                 openPos = INT_MAX;\par
03026         \}\par
03027         {\cf19 if} (message[i] == InStream::CLOSE_BRACKET) \{\par
03028             {\cf19 if} (closePos == -1)\par
03029                 closePos = int(i);\par
03030             {\cf19 else}\par
03031                 closePos = INT_MAX;\par
03032         \}\par
03033     \}\par
03034     {\cf19 if} (openPos != -1 && openPos != INT_MAX\par
03035         && closePos != -1 && closePos != INT_MAX\par
03036         && openPos < closePos) \{\par
03037         std::string result(message);\par
03038         result[openPos] = {\cf23 '('};\par
03039         result[closePos] = {\cf23 ')'};\par
03040         {\cf19 return} result;\par
03041     \}\par
03042 \par
03043     {\cf19 return} message;\par
03044 \}\par
03045 \par
03046 NORETURN {\cf18 void} InStream::quit(TResult result, {\cf17 const} {\cf18 char} *msg) \{\par
03047     {\cf19 if} (TestlibFinalizeGuard::alive)\par
03048         testlibFinalizeGuard.quitCount++;\par
03049 \par
03050     std::string message(msg);\par
03051     message = trim(message);\par
03052 \par
03053     {\cf19 if} (__testlib_hasTestCase) \{\par
03054         {\cf19 if} (result != _ok)\par
03055             message = __testlib_appendMessage(message, {\cf22 "test case "} + vtos(__testlib_testCase));\par
03056         {\cf19 else} \{\par
03057             {\cf19 if} (__testlib_testCase == 1)\par
03058                 message = __testlib_appendMessage(message, vtos(__testlib_testCase) + {\cf22 " test case"});\par
03059             {\cf19 else}\par
03060                 message = __testlib_appendMessage(message, vtos(__testlib_testCase) + {\cf22 " test cases"});\par
03061         \}\par
03062     \}\par
03063 \par
03064     {\cf20 // You can change maxMessageLength.}\par
03065     {\cf20 // Example: 'inf.maxMessageLength = 1024 * 1024;'.}\par
03066     {\cf19 if} (message.length() > maxMessageLength) \{\par
03067         std::string warn = {\cf22 "message length exceeds "} + vtos(maxMessageLength)\par
03068                            + {\cf22 ", the message is truncated: "};\par
03069         message = warn + message.substr(0, maxMessageLength - warn.length());\par
03070     \}\par
03071 \par
03072 {\cf21 #ifndef ENABLE_UNEXPECTED_EOF}\par
03073     {\cf19 if} (result == _unexpected_eof)\par
03074         result = _pe;\par
03075 {\cf21 #endif}\par
03076 \par
03077     {\cf19 if} (testlibMode == _scorer && result != _fail)\par
03078         quits(_fail, {\cf22 "Scorer should return points only. Don't use a quit function."});\par
03079 \par
03080     {\cf19 if} (mode != _output && result != _fail) \{\par
03081         {\cf19 if} (mode == _input && testlibMode == _validator && lastLine != -1)\par
03082             quits(_fail, __testlib_appendMessage(__testlib_appendMessage(message, name), {\cf22 "line "} + vtos(lastLine)));\par
03083         {\cf19 else}\par
03084             quits(_fail, __testlib_appendMessage(message, name));\par
03085     \}\par
03086 \par
03087     std::FILE *resultFile;\par
03088     std::string errorName;\par
03089 \par
03090     {\cf19 if} (__testlib_shouldCheckDirt(result)) \{\par
03091         {\cf19 if} (testlibMode != _interactor && !ouf.seekEof())\par
03092             quit(_dirt, {\cf22 "Extra information in the output file"});\par
03093     \}\par
03094 \par
03095     {\cf18 int} pctype = result - _partially;\par
03096     {\cf18 bool} isPartial = {\cf17 false};\par
03097 \par
03098     {\cf19 switch} (result) \{\par
03099         {\cf19 case} _ok:\par
03100             errorName = {\cf22 "ok "};\par
03101             quitscrS(LightGreen, errorName);\par
03102             {\cf19 break};\par
03103         {\cf19 case} _wa:\par
03104             errorName = {\cf22 "wrong answer "};\par
03105             quitscrS(LightRed, errorName);\par
03106             {\cf19 break};\par
03107         {\cf19 case} _pe:\par
03108             errorName = {\cf22 "wrong output format "};\par
03109             quitscrS(LightRed, errorName);\par
03110             {\cf19 break};\par
03111         {\cf19 case} _fail:\par
03112             errorName = {\cf22 "FAIL "};\par
03113             quitscrS(LightRed, errorName);\par
03114             {\cf19 break};\par
03115         {\cf19 case} _dirt:\par
03116             errorName = {\cf22 "wrong output format "};\par
03117             quitscrS(LightCyan, errorName);\par
03118             result = _pe;\par
03119             {\cf19 break};\par
03120         {\cf19 case} _points:\par
03121             errorName = {\cf22 "points "};\par
03122             quitscrS(LightYellow, errorName);\par
03123             {\cf19 break};\par
03124         {\cf19 case} _unexpected_eof:\par
03125             errorName = {\cf22 "unexpected eof "};\par
03126             quitscrS(LightCyan, errorName);\par
03127             {\cf19 break};\par
03128         {\cf19 default}:\par
03129             {\cf19 if} (result >= _partially) \{\par
03130                 errorName = format({\cf22 "partially correct (%d) "}, pctype);\par
03131                 isPartial = {\cf17 true};\par
03132                 quitscrS(LightYellow, errorName);\par
03133             \} {\cf19 else}\par
03134                 quit(_fail, {\cf22 "What is the code ??? "});\par
03135     \}\par
03136 \par
03137     {\cf19 if} (resultName != {\cf22 ""}) \{\par
03138         resultFile = std::fopen(resultName.c_str(), {\cf22 "w"});\par
03139         {\cf19 if} (resultFile == NULL) \{\par
03140             resultName = {\cf22 ""};\par
03141             quit(_fail, {\cf22 "Can not write to the result file"});\par
03142         \}\par
03143         {\cf19 if} (appesMode) \{\par
03144             std::fprintf(resultFile, {\cf22 "<?xml version=\\"1.0\\" encoding=\\"%s\\"?>"}, appesModeEncoding.c_str());\par
03145             {\cf19 if} (isPartial)\par
03146                 std::fprintf(resultFile, {\cf22 "<result outcome = \\"%s\\" pctype = \\"%d\\">"},\par
03147                              outcomes[({\cf18 int}) _partially].c_str(), pctype);\par
03148             {\cf19 else} \{\par
03149                 {\cf19 if} (result != _points)\par
03150                     std::fprintf(resultFile, {\cf22 "<result outcome = \\"%s\\">"}, outcomes[({\cf18 int}) result].c_str());\par
03151                 {\cf19 else} \{\par
03152                     {\cf19 if} (__testlib_points == std::numeric_limits<float>::infinity())\par
03153                         quit(_fail, {\cf22 "Expected points, but infinity found"});\par
03154                     std::string stringPoints = removeDoubleTrailingZeroes(format({\cf22 "%.10f"}, __testlib_points));\par
03155                     std::fprintf(resultFile, {\cf22 "<result outcome = \\"%s\\" points = \\"%s\\">"},\par
03156                                  outcomes[({\cf18 int}) result].c_str(), stringPoints.c_str());\par
03157                 \}\par
03158             \}\par
03159             xmlSafeWrite(resultFile, __testlib_toPrintableMessage(message).c_str());\par
03160             std::fprintf(resultFile, {\cf22 "</result>\\n"});\par
03161         \} {\cf19 else}\par
03162             std::fprintf(resultFile, {\cf22 "%s"}, __testlib_toPrintableMessage(message).c_str());\par
03163         {\cf19 if} (NULL == resultFile || fclose(resultFile) != 0) \{\par
03164             resultName = {\cf22 ""};\par
03165             quit(_fail, {\cf22 "Can not write to the result file"});\par
03166         \}\par
03167     \}\par
03168 \par
03169     quitscr(LightGray, __testlib_toPrintableMessage(message).c_str());\par
03170     std::fprintf(stderr, {\cf22 "\\n"});\par
03171 \par
03172     inf.close();\par
03173     ouf.close();\par
03174     ans.close();\par
03175     {\cf19 if} (tout.is_open())\par
03176         tout.close();\par
03177 \par
03178     textColor(LightGray);\par
03179 \par
03180     {\cf19 if} (resultName != {\cf22 ""})\par
03181         std::fprintf(stderr, {\cf22 "See file to check exit message\\n"});\par
03182 \par
03183     halt(resultExitCode(result));\par
03184 \}\par
03185 \par
03186 {\cf21 #ifdef __GNUC__}\par
03187 __attribute__ ((format (printf, 3, 4)))\par
03188 {\cf21 #endif}\par
03189 NORETURN {\cf18 void} InStream::quitf(TResult result, {\cf17 const} {\cf18 char} *msg, ...) \{\par
03190     FMT_TO_RESULT(msg, msg, message);\par
03191     InStream::quit(result, message.c_str());\par
03192 \}\par
03193 \par
03194 {\cf21 #ifdef __GNUC__}\par
03195 __attribute__ ((format (printf, 4, 5)))\par
03196 {\cf21 #endif}\par
03197 {\cf18 void} InStream::quitif({\cf18 bool} condition, TResult result, {\cf17 const} {\cf18 char} *msg, ...) \{\par
03198     {\cf19 if} (condition) \{\par
03199         FMT_TO_RESULT(msg, msg, message);\par
03200         InStream::quit(result, message.c_str());\par
03201     \}\par
03202 \}\par
03203 \par
03204 NORETURN {\cf18 void} InStream::quits(TResult result, std::string msg) \{\par
03205     InStream::quit(result, msg.c_str());\par
03206 \}\par
03207 \par
03208 {\cf18 void} InStream::xmlSafeWrite(std::FILE *file, {\cf17 const} {\cf18 char} *msg) \{\par
03209     {\cf18 size_t} lmsg = strlen(msg);\par
03210     {\cf19 for} ({\cf18 size_t} i = 0; i < lmsg; i++) \{\par
03211         {\cf19 if} (msg[i] == {\cf23 '&'}) \{\par
03212             std::fprintf(file, {\cf22 "%s"}, {\cf22 "&amp;"});\par
03213             {\cf19 continue};\par
03214         \}\par
03215         {\cf19 if} (msg[i] == {\cf23 '<'}) \{\par
03216             std::fprintf(file, {\cf22 "%s"}, {\cf22 "&lt;"});\par
03217             {\cf19 continue};\par
03218         \}\par
03219         {\cf19 if} (msg[i] == {\cf23 '>'}) \{\par
03220             std::fprintf(file, {\cf22 "%s"}, {\cf22 "&gt;"});\par
03221             {\cf19 continue};\par
03222         \}\par
03223         {\cf19 if} (msg[i] == {\cf23 '"'}) \{\par
03224             std::fprintf(file, {\cf22 "%s"}, {\cf22 "&quot;"});\par
03225             {\cf19 continue};\par
03226         \}\par
03227         {\cf19 if} (0 <= msg[i] && msg[i] <= 31) \{\par
03228             std::fprintf(file, {\cf22 "%c"}, {\cf23 '.'});\par
03229             {\cf19 continue};\par
03230         \}\par
03231         std::fprintf(file, {\cf22 "%c"}, msg[i]);\par
03232     \}\par
03233 \}\par
03234 \par
03235 {\cf18 void} InStream::quitscrS(WORD color, std::string msg) \{\par
03236     quitscr(color, msg.c_str());\par
03237 \}\par
03238 \par
03239 {\cf18 void} InStream::quitscr(WORD color, {\cf17 const} {\cf18 char} *msg) \{\par
03240     {\cf19 if} (resultName == {\cf22 ""}) \{\par
03241         textColor(color);\par
03242         std::fprintf(stderr, {\cf22 "%s"}, msg);\par
03243         textColor(LightGray);\par
03244     \}\par
03245 \}\par
03246 \par
03247 {\cf18 void} InStream::reset(std::FILE *file) \{\par
03248     {\cf19 if} (opened && stdfile)\par
03249         quit(_fail, {\cf22 "Can't reset standard handle"});\par
03250 \par
03251     {\cf19 if} (opened)\par
03252         close();\par
03253 \par
03254     {\cf19 if} (!stdfile && NULL == file)\par
03255         {\cf19 if} (NULL == (file = std::fopen(name.c_str(), {\cf22 "rb"}))) \{\par
03256             {\cf19 if} (mode == _output)\par
03257                 quits(_pe, std::string({\cf22 "Output file not found: \\""}) + name + {\cf22 "\\""});\par
03258 \par
03259             {\cf19 if} (mode == _answer)\par
03260                 quits(_fail, std::string({\cf22 "Answer file not found: \\""}) + name + {\cf22 "\\""});\par
03261         \}\par
03262 \par
03263     {\cf19 if} (NULL != file) \{\par
03264         opened = {\cf17 true};\par
03265         __testlib_set_binary(file);\par
03266 \par
03267         {\cf19 if} (stdfile)\par
03268             reader = {\cf17 new} FileInputStreamReader(file, name);\par
03269         {\cf19 else}\par
03270             reader = {\cf17 new} BufferedFileInputStreamReader(file, name);\par
03271     \} {\cf19 else} \{\par
03272         opened = {\cf17 false};\par
03273         reader = NULL;\par
03274     \}\par
03275 \}\par
03276 \par
03277 {\cf18 void} InStream::init(std::string fileName, TMode mode) \{\par
03278     opened = {\cf17 false};\par
03279     name = fileName;\par
03280     stdfile = {\cf17 false};\par
03281     this->mode = mode;\par
03282 \par
03283     std::ifstream stream;\par
03284     stream.open(fileName.c_str(), std::ios::in);\par
03285     {\cf19 if} (stream.is_open()) \{\par
03286         std::streampos start = stream.tellg();\par
03287         stream.seekg(0, std::ios::end);\par
03288         std::streampos end = stream.tellg();\par
03289         {\cf18 size_t} fileSize = size_t(end - start);\par
03290         stream.close();\par
03291 \par
03292         {\cf20 // You can change maxFileSize.}\par
03293         {\cf20 // Example: 'inf.maxFileSize = 256 * 1024 * 1024;'.}\par
03294         {\cf19 if} (fileSize > maxFileSize)\par
03295             quitf(_pe, {\cf22 "File size exceeds %d bytes, size is %d"}, {\cf18 int}(maxFileSize), {\cf18 int}(fileSize));\par
03296     \}\par
03297 \par
03298     reset();\par
03299 \}\par
03300 \par
03301 {\cf18 void} InStream::init(std::FILE *f, TMode mode) \{\par
03302     opened = {\cf17 false};\par
03303     name = {\cf22 "untitled"};\par
03304     this->mode = mode;\par
03305 \par
03306     {\cf19 if} (f == stdin)\par
03307         name = {\cf22 "stdin"}, stdfile = {\cf17 true};\par
03308     {\cf19 if} (f == stdout)\par
03309         name = {\cf22 "stdout"}, stdfile = {\cf17 true};\par
03310     {\cf19 if} (f == stderr)\par
03311         name = {\cf22 "stderr"}, stdfile = {\cf17 true};\par
03312 \par
03313     reset(f);\par
03314 \}\par
03315 \par
03316 {\cf18 void} InStream::skipBom() \{\par
03317     {\cf17 const} std::string utf8Bom = {\cf22 "\\xEF\\xBB\\xBF"};\par
03318     {\cf18 size_t} index = 0;\par
03319     {\cf19 while} (index < utf8Bom.size() && curChar() == utf8Bom[index]) \{\par
03320         index++;\par
03321         skipChar();\par
03322     \}\par
03323     {\cf19 if} (index < utf8Bom.size()) \{\par
03324         {\cf19 while} (index != 0) \{\par
03325             unreadChar(utf8Bom[index - 1]);\par
03326             index--;\par
03327         \}\par
03328     \}\par
03329 \}\par
03330 \par
03331 {\cf18 char} InStream::curChar() \{\par
03332     {\cf19 return} char(reader->curChar());\par
03333 \}\par
03334 \par
03335 {\cf18 char} InStream::nextChar() \{\par
03336     {\cf19 return} char(reader->nextChar());\par
03337 \}\par
03338 \par
03339 {\cf18 char} InStream::readChar() \{\par
03340     {\cf19 return} nextChar();\par
03341 \}\par
03342 \par
03343 {\cf18 char} InStream::readChar({\cf18 char} c) \{\par
03344     lastLine = reader->getLine();\par
03345     {\cf18 char} found = readChar();\par
03346     {\cf19 if} (c != found) \{\par
03347         {\cf19 if} (!isEoln(found))\par
03348             quit(_pe, ({\cf22 "Unexpected character '"} + std::string(1, found) + {\cf22 "', but '"} + std::string(1, c) +\par
03349                        {\cf22 "' expected"}).c_str());\par
03350         {\cf19 else}\par
03351             quit(_pe, ({\cf22 "Unexpected character "} + ({\cf22 "#"} + vtos({\cf18 int}(found))) + {\cf22 ", but '"} + std::string(1, c) +\par
03352                        {\cf22 "' expected"}).c_str());\par
03353     \}\par
03354     {\cf19 return} found;\par
03355 \}\par
03356 \par
03357 {\cf18 char} InStream::readSpace() \{\par
03358     {\cf19 return} readChar({\cf23 ' '});\par
03359 \}\par
03360 \par
03361 {\cf18 void} InStream::unreadChar({\cf18 char} c) \{\par
03362     reader->unreadChar(c);\par
03363 \}\par
03364 \par
03365 {\cf18 void} InStream::skipChar() \{\par
03366     reader->skipChar();\par
03367 \}\par
03368 \par
03369 {\cf18 void} InStream::skipBlanks() \{\par
03370     {\cf19 while} (isBlanks(reader->curChar()))\par
03371         reader->skipChar();\par
03372 \}\par
03373 \par
03374 std::string InStream::readWord() \{\par
03375     readWordTo(_tmpReadToken);\par
03376     {\cf19 return} _tmpReadToken;\par
03377 \}\par
03378 \par
03379 {\cf18 void} InStream::readWordTo(std::string &result) \{\par
03380     {\cf19 if} (!strict)\par
03381         skipBlanks();\par
03382 \par
03383     lastLine = reader->getLine();\par
03384     {\cf18 int} cur = reader->nextChar();\par
03385 \par
03386     {\cf19 if} (cur == EOFC)\par
03387         quit(_unexpected_eof, {\cf22 "Unexpected end of file - token expected"});\par
03388 \par
03389     {\cf19 if} (isBlanks(cur))\par
03390         quit(_pe, {\cf22 "Unexpected white-space - token expected"});\par
03391 \par
03392     result.clear();\par
03393 \par
03394     {\cf19 while} (!(isBlanks(cur) || cur == EOFC)) \{\par
03395         result += char(cur);\par
03396 \par
03397         {\cf20 // You can change maxTokenLength.}\par
03398         {\cf20 // Example: 'inf.maxTokenLength = 128 * 1024 * 1024;'.}\par
03399         {\cf19 if} (result.length() > maxTokenLength)\par
03400             quitf(_pe, {\cf22 "Length of token exceeds %d, token is '%s...'"}, {\cf18 int}(maxTokenLength),\par
03401                   __testlib_part(result).c_str());\par
03402 \par
03403         cur = reader->nextChar();\par
03404     \}\par
03405 \par
03406     reader->unreadChar(cur);\par
03407 \par
03408     {\cf19 if} (result.length() == 0)\par
03409         quit(_unexpected_eof, {\cf22 "Unexpected end of file or white-space - token expected"});\par
03410 \}\par
03411 \par
03412 std::string InStream::readToken() \{\par
03413     {\cf19 return} readWord();\par
03414 \}\par
03415 \par
03416 {\cf18 void} InStream::readTokenTo(std::string &result) \{\par
03417     readWordTo(result);\par
03418 \}\par
03419 \par
03420 {\cf21 #ifdef __GNUC__}\par
03421 __attribute__(({\cf17 const}))\par
03422 {\cf21 #endif}\par
03423 {\cf17 static} std::string __testlib_part({\cf17 const} std::string &s) \{\par
03424     std::string t;\par
03425     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
03426         {\cf19 if} (s[i] != {\cf23 '\\0'})\par
03427             t += s[i];\par
03428         {\cf19 else}\par
03429             t += {\cf23 '~'};\par
03430     {\cf19 if} (t.length() <= 64)\par
03431         {\cf19 return} t;\par
03432     {\cf19 else}\par
03433         {\cf19 return} t.substr(0, 30) + {\cf22 "..."} + t.substr(s.length() - 31, 31);\par
03434 \}\par
03435 \par
03436 {\cf21 #define __testlib_readMany(readMany, readOne, typeName, space)                  \\}\par
03437 {\cf21     if (size < 0)                                                               \\}\par
03438 {\cf21         quit(_fail, #readMany ": size should be non-negative.");                \\}\par
03439 {\cf21     if (size > 100000000)                                                       \\}\par
03440 {\cf21         quit(_fail, #readMany ": size should be at most 100000000.");           \\}\par
03441 {\cf21                                                                                 \\}\par
03442 {\cf21     std::vector<typeName> result(size);                                         \\}\par
03443 {\cf21     readManyIteration = indexBase;                                              \\}\par
03444 {\cf21                                                                                 \\}\par
03445 {\cf21     for (int i = 0; i < size; i++)                                              \\}\par
03446 {\cf21     \{                                                                           \\}\par
03447 {\cf21         result[i] = readOne;                                                    \\}\par
03448 {\cf21         readManyIteration++;                                                    \\}\par
03449 {\cf21         if (strict && space && i + 1 < size)                                              \\}\par
03450 {\cf21             readSpace();                                                        \\}\par
03451 {\cf21     \}                                                                           \\}\par
03452 {\cf21                                                                                 \\}\par
03453 {\cf21     readManyIteration = NO_INDEX;                                               \\}\par
03454 {\cf21     return result;                                                              \\}\par
03455 {\cf21 }\par
03456 \par
03457 std::string InStream::readWord({\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
03458     readWordTo(_tmpReadToken);\par
03459     {\cf19 if} (!p.matches(_tmpReadToken)) \{\par
03460         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
03461             {\cf19 if} (variableName.empty())\par
03462                 quit(_wa,\par
03463                      ({\cf22 "Token \\""} + __testlib_part(_tmpReadToken) + {\cf22 "\\" doesn't correspond to pattern \\""} + p.src() +\par
03464                       {\cf22 "\\""}).c_str());\par
03465             {\cf19 else}\par
03466                 quit(_wa, ({\cf22 "Token parameter [name="} + variableName + {\cf22 "] equals to \\""} + __testlib_part(_tmpReadToken) +\par
03467                            {\cf22 "\\", doesn't correspond to pattern \\""} + p.src() + {\cf22 "\\""}).c_str());\par
03468         \} {\cf19 else} \{\par
03469             {\cf19 if} (variableName.empty())\par
03470                 quit(_wa, ({\cf22 "Token element [index="} + vtos(readManyIteration) + {\cf22 "] equals to \\""} +\par
03471                            __testlib_part(_tmpReadToken) + {\cf22 "\\" doesn't correspond to pattern \\""} + p.src() +\par
03472                            {\cf22 "\\""}).c_str());\par
03473             {\cf19 else}\par
03474                 quit(_wa, ({\cf22 "Token element "} + variableName + {\cf22 "["} + vtos(readManyIteration) + {\cf22 "] equals to \\""} +\par
03475                            __testlib_part(_tmpReadToken) + {\cf22 "\\", doesn't correspond to pattern \\""} + p.src() +\par
03476                            {\cf22 "\\""}).c_str());\par
03477         \}\par
03478     \}\par
03479     {\cf19 if} (strict && !variableName.empty())\par
03480         validator.addVariable(variableName);\par
03481     {\cf19 return} _tmpReadToken;\par
03482 \}\par
03483 \par
03484 std::vector<std::string>\par
03485 InStream::readWords({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03486     __testlib_readMany(readWords, readWord(p, variablesName), std::string, {\cf17 true});\par
03487     {\cf19 if} (strict && !variablesName.empty())\par
03488         validator.addVariable(variablesName);\par
03489 \}\par
03490 \par
03491 std::vector<std::string> InStream::readWords({\cf18 int} size, {\cf18 int} indexBase) \{\par
03492     __testlib_readMany(readWords, readWord(), std::string, {\cf17 true});\par
03493 \}\par
03494 \par
03495 std::string InStream::readWord({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
03496     {\cf19 return} readWord(pattern(ptrn), variableName);\par
03497 \}\par
03498 \par
03499 std::vector<std::string>\par
03500 InStream::readWords({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03501     pattern p(ptrn);\par
03502     __testlib_readMany(readWords, readWord(p, variablesName), std::string, {\cf17 true});\par
03503     {\cf19 if} (strict && !variablesName.empty())\par
03504         validator.addVariable(variablesName);\par
03505 \}\par
03506 \par
03507 std::string InStream::readToken({\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
03508     {\cf19 return} readWord(p, variableName);\par
03509 \}\par
03510 \par
03511 std::vector<std::string>\par
03512 InStream::readTokens({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03513     __testlib_readMany(readTokens, readToken(p, variablesName), std::string, {\cf17 true});\par
03514     {\cf19 if} (strict && !variablesName.empty())\par
03515         validator.addVariable(variablesName);\par
03516 \}\par
03517 \par
03518 std::vector<std::string> InStream::readTokens({\cf18 int} size, {\cf18 int} indexBase) \{\par
03519     __testlib_readMany(readTokens, readToken(), std::string, {\cf17 true});\par
03520 \}\par
03521 \par
03522 std::string InStream::readToken({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
03523     {\cf19 return} readWord(ptrn, variableName);\par
03524 \}\par
03525 \par
03526 std::vector<std::string>\par
03527 InStream::readTokens({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03528     pattern p(ptrn);\par
03529     __testlib_readMany(readTokens, readWord(p, variablesName), std::string, {\cf17 true});\par
03530     {\cf19 if} (strict && !variablesName.empty())\par
03531         validator.addVariable(variablesName);\par
03532 \}\par
03533 \par
03534 {\cf18 void} InStream::readWordTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
03535     readWordTo(result);\par
03536     {\cf19 if} (!p.matches(result)) \{\par
03537         {\cf19 if} (variableName.empty())\par
03538             quit(_wa, ({\cf22 "Token \\""} + __testlib_part(result) + {\cf22 "\\" doesn't correspond to pattern \\""} + p.src() +\par
03539                        {\cf22 "\\""}).c_str());\par
03540         {\cf19 else}\par
03541             quit(_wa, ({\cf22 "Token parameter [name="} + variableName + {\cf22 "] equals to \\""} + __testlib_part(result) +\par
03542                        {\cf22 "\\", doesn't correspond to pattern \\""} + p.src() + {\cf22 "\\""}).c_str());\par
03543     \}\par
03544     {\cf19 if} (strict && !variableName.empty())\par
03545         validator.addVariable(variableName);\par
03546 \}\par
03547 \par
03548 {\cf18 void} InStream::readWordTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
03549     {\cf19 return} readWordTo(result, pattern(ptrn), variableName);\par
03550 \}\par
03551 \par
03552 {\cf18 void} InStream::readTokenTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
03553     {\cf19 return} readWordTo(result, p, variableName);\par
03554 \}\par
03555 \par
03556 {\cf18 void} InStream::readTokenTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
03557     {\cf19 return} readWordTo(result, ptrn, variableName);\par
03558 \}\par
03559 \par
03560 {\cf21 #ifdef __GNUC__}\par
03561 __attribute__((pure))\par
03562 {\cf21 #endif}\par
03563 {\cf17 static} {\cf17 inline} {\cf18 bool} equals({\cf18 long} {\cf18 long} integer, {\cf17 const} {\cf18 char} *s) \{\par
03564     {\cf19 if} (integer == LLONG_MIN)\par
03565         {\cf19 return} strcmp(s, {\cf22 "-9223372036854775808"}) == 0;\par
03566 \par
03567     {\cf19 if} (integer == 0LL)\par
03568         {\cf19 return} strcmp(s, {\cf22 "0"}) == 0;\par
03569 \par
03570     {\cf18 size_t} length = strlen(s);\par
03571 \par
03572     {\cf19 if} (length == 0)\par
03573         {\cf19 return} {\cf17 false};\par
03574 \par
03575     {\cf19 if} (integer < 0 && s[0] != {\cf23 '-'})\par
03576         {\cf19 return} {\cf17 false};\par
03577 \par
03578     {\cf19 if} (integer < 0)\par
03579         s++, length--, integer = -integer;\par
03580 \par
03581     {\cf19 if} (length == 0)\par
03582         {\cf19 return} {\cf17 false};\par
03583 \par
03584     {\cf19 while} (integer > 0) \{\par
03585         {\cf18 int} digit = int(integer % 10);\par
03586 \par
03587         {\cf19 if} (s[length - 1] != {\cf23 '0'} + digit)\par
03588             {\cf19 return} {\cf17 false};\par
03589 \par
03590         length--;\par
03591         integer /= 10;\par
03592     \}\par
03593 \par
03594     {\cf19 return} length == 0;\par
03595 \}\par
03596 \par
03597 {\cf21 #ifdef __GNUC__}\par
03598 __attribute__((pure))\par
03599 {\cf21 #endif}\par
03600 {\cf17 static} {\cf17 inline} {\cf18 bool} equals({\cf18 unsigned} {\cf18 long} {\cf18 long} integer, {\cf17 const} {\cf18 char} *s) \{\par
03601     {\cf19 if} (integer == ULLONG_MAX)\par
03602         {\cf19 return} strcmp(s, {\cf22 "18446744073709551615"}) == 0;\par
03603 \par
03604     {\cf19 if} (integer == 0ULL)\par
03605         {\cf19 return} strcmp(s, {\cf22 "0"}) == 0;\par
03606 \par
03607     {\cf18 size_t} length = strlen(s);\par
03608 \par
03609     {\cf19 if} (length == 0)\par
03610         {\cf19 return} {\cf17 false};\par
03611 \par
03612     {\cf19 while} (integer > 0) \{\par
03613         {\cf18 int} digit = int(integer % 10);\par
03614 \par
03615         {\cf19 if} (s[length - 1] != {\cf23 '0'} + digit)\par
03616             {\cf19 return} {\cf17 false};\par
03617 \par
03618         length--;\par
03619         integer /= 10;\par
03620     \}\par
03621 \par
03622     {\cf19 return} length == 0;\par
03623 \}\par
03624 \par
03625 {\cf17 static} {\cf17 inline} {\cf18 double} stringToDouble(InStream &in, {\cf17 const} {\cf18 char} *buffer) \{\par
03626     {\cf18 double} result;\par
03627 \par
03628     {\cf18 size_t} length = strlen(buffer);\par
03629 \par
03630     {\cf18 int} minusCount = 0;\par
03631     {\cf18 int} plusCount = 0;\par
03632     {\cf18 int} decimalPointCount = 0;\par
03633     {\cf18 int} digitCount = 0;\par
03634     {\cf18 int} eCount = 0;\par
03635 \par
03636     {\cf19 for} ({\cf18 size_t} i = 0; i < length; i++) \{\par
03637         {\cf19 if} (({\cf23 '0'} <= buffer[i] && buffer[i] <= {\cf23 '9'}) || buffer[i] == {\cf23 '.'}\par
03638             || buffer[i] == {\cf23 'e'} || buffer[i] == {\cf23 'E'}\par
03639             || buffer[i] == {\cf23 '-'} || buffer[i] == {\cf23 '+'}) \{\par
03640             {\cf19 if} ({\cf23 '0'} <= buffer[i] && buffer[i] <= {\cf23 '9'})\par
03641                 digitCount++;\par
03642             {\cf19 if} (buffer[i] == {\cf23 'e'} || buffer[i] == {\cf23 'E'})\par
03643                 eCount++;\par
03644             {\cf19 if} (buffer[i] == {\cf23 '-'})\par
03645                 minusCount++;\par
03646             {\cf19 if} (buffer[i] == {\cf23 '+'})\par
03647                 plusCount++;\par
03648             {\cf19 if} (buffer[i] == {\cf23 '.'})\par
03649                 decimalPointCount++;\par
03650         \} {\cf19 else}\par
03651             in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03652     \}\par
03653 \par
03654     {\cf20 // If for sure is not a number in standard notation or in e-notation.}\par
03655     {\cf19 if} (digitCount == 0 || minusCount > 2 || plusCount > 2 || decimalPointCount > 1 || eCount > 1)\par
03656         in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03657 \par
03658     {\cf18 char} *suffix = {\cf17 new} {\cf18 char}[length + 1];\par
03659     std::memset(suffix, 0, length + 1);\par
03660     {\cf18 int} scanned = std::sscanf(buffer, {\cf22 "%lf%s"}, &result, suffix);\par
03661     {\cf18 bool} empty = strlen(suffix) == 0;\par
03662     {\cf17 delete}[] suffix;\par
03663 \par
03664     {\cf19 if} (scanned == 1 || (scanned == 2 && empty)) \{\par
03665         {\cf19 if} (__testlib_isNaN(result))\par
03666             in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03667         {\cf19 return} result;\par
03668     \} {\cf19 else}\par
03669         in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03670 \}\par
03671 \par
03672 {\cf17 static} {\cf17 inline} {\cf18 double} stringToDouble(InStream &in, {\cf17 const} std::string& buffer) \{\par
03673     {\cf19 for} ({\cf18 size_t} i = 0; i < buffer.length(); i++)\par
03674         {\cf19 if} (buffer[i] == {\cf23 '\\0'})\par
03675             in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found (it contains \\\\0)"}).c_str());\par
03676     {\cf19 return} stringToDouble(in, buffer.c_str());\par
03677 \}\par
03678 \par
03679 {\cf17 static} {\cf17 inline} {\cf18 double} stringToStrictDouble(InStream &in, {\cf17 const} {\cf18 char} *buffer,\par
03680         {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount) \{\par
03681     {\cf19 if} (minAfterPointDigitCount < 0)\par
03682         in.quit(_fail, {\cf22 "stringToStrictDouble: minAfterPointDigitCount should be non-negative."});\par
03683 \par
03684     {\cf19 if} (minAfterPointDigitCount > maxAfterPointDigitCount)\par
03685         in.quit(_fail,\par
03686                 {\cf22 "stringToStrictDouble: minAfterPointDigitCount should be less or equal to maxAfterPointDigitCount."});\par
03687 \par
03688     {\cf18 double} result;\par
03689 \par
03690     {\cf18 size_t} length = strlen(buffer);\par
03691 \par
03692     {\cf19 if} (length == 0 || length > 1000)\par
03693         in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03694 \par
03695     {\cf19 if} (buffer[0] != {\cf23 '-'} && (buffer[0] < {\cf23 '0'} || buffer[0] > {\cf23 '9'}))\par
03696         in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03697 \par
03698     {\cf18 int} pointPos = -1;\par
03699     {\cf19 for} ({\cf18 size_t} i = 1; i + 1 < length; i++) \{\par
03700         {\cf19 if} (buffer[i] == {\cf23 '.'}) \{\par
03701             {\cf19 if} (pointPos > -1)\par
03702                 in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03703             pointPos = int(i);\par
03704         \}\par
03705         {\cf19 if} (buffer[i] != {\cf23 '.'} && (buffer[i] < {\cf23 '0'} || buffer[i] > {\cf23 '9'}))\par
03706             in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03707     \}\par
03708 \par
03709     {\cf19 if} (buffer[length - 1] < {\cf23 '0'} || buffer[length - 1] > {\cf23 '9'})\par
03710         in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03711 \par
03712     {\cf18 int} afterDigitsCount = (pointPos == -1 ? 0 : int(length) - pointPos - 1);\par
03713     {\cf19 if} (afterDigitsCount < minAfterPointDigitCount || afterDigitsCount > maxAfterPointDigitCount)\par
03714         in.quit(_pe, ({\cf22 "Expected strict double with number of digits after point in range ["}\par
03715                       + vtos(minAfterPointDigitCount)\par
03716                       + {\cf22 ","}\par
03717                       + vtos(maxAfterPointDigitCount)\par
03718                       + {\cf22 "], but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str()\par
03719         );\par
03720 \par
03721     {\cf18 int} firstDigitPos = -1;\par
03722     {\cf19 for} ({\cf18 size_t} i = 0; i < length; i++)\par
03723         {\cf19 if} (buffer[i] >= {\cf23 '0'} && buffer[i] <= {\cf23 '9'}) \{\par
03724             firstDigitPos = int(i);\par
03725             {\cf19 break};\par
03726         \}\par
03727 \par
03728     {\cf19 if} (firstDigitPos > 1 || firstDigitPos == -1)\par
03729         in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03730 \par
03731     {\cf19 if} (buffer[firstDigitPos] == {\cf23 '0'} && firstDigitPos + 1 < {\cf18 int}(length)\par
03732         && buffer[firstDigitPos + 1] >= {\cf23 '0'} && buffer[firstDigitPos + 1] <= {\cf23 '9'})\par
03733         in.quit(_pe, ({\cf22 "Expected strict double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03734 \par
03735     {\cf18 char} *suffix = {\cf17 new} {\cf18 char}[length + 1];\par
03736     std::memset(suffix, 0, length + 1);\par
03737     {\cf18 int} scanned = std::sscanf(buffer, {\cf22 "%lf%s"}, &result, suffix);\par
03738     {\cf18 bool} empty = strlen(suffix) == 0;\par
03739     {\cf17 delete}[] suffix;\par
03740 \par
03741     {\cf19 if} (scanned == 1 || (scanned == 2 && empty)) \{\par
03742         {\cf19 if} (__testlib_isNaN(result) || __testlib_isInfinite(result))\par
03743             in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03744         {\cf19 if} (buffer[0] == {\cf23 '-'} && result >= 0)\par
03745             in.quit(_pe, ({\cf22 "Redundant minus in \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03746         {\cf19 return} result;\par
03747     \} {\cf19 else}\par
03748         in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03749 \}\par
03750 \par
03751 {\cf17 static} {\cf17 inline} {\cf18 double} stringToStrictDouble(InStream &in, {\cf17 const} std::string& buffer,\par
03752         {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount) \{\par
03753     {\cf19 for} ({\cf18 size_t} i = 0; i < buffer.length(); i++)\par
03754         {\cf19 if} (buffer[i] == {\cf23 '\\0'})\par
03755             in.quit(_pe, ({\cf22 "Expected double, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found (it contains \\\\0)"}).c_str());\par
03756     {\cf19 return} stringToStrictDouble(in, buffer.c_str(), minAfterPointDigitCount, maxAfterPointDigitCount);\par
03757 \}\par
03758 \par
03759 {\cf17 static} {\cf17 inline} {\cf18 long} {\cf18 long} stringToLongLong(InStream &in, {\cf17 const} {\cf18 char} *buffer) \{\par
03760     {\cf18 size_t} length = strlen(buffer);\par
03761     {\cf19 if} (length == 0 || length > 20)\par
03762         in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03763 \par
03764     {\cf18 bool} has_minus = (length > 1 && buffer[0] == {\cf23 '-'});\par
03765     {\cf18 int} zeroes = 0;\par
03766     {\cf18 bool} processingZeroes = {\cf17 true};\par
03767 \par
03768     {\cf19 for} ({\cf18 int} i = (has_minus ? 1 : 0); i < int(length); i++) \{\par
03769         {\cf19 if} (buffer[i] == {\cf23 '0'} && processingZeroes)\par
03770             zeroes++;\par
03771         {\cf19 else}\par
03772             processingZeroes = {\cf17 false};\par
03773 \par
03774         {\cf19 if} (buffer[i] < {\cf23 '0'} || buffer[i] > {\cf23 '9'})\par
03775             in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03776     \}\par
03777 \par
03778     {\cf18 long} {\cf18 long} {\cf18 int} result;\par
03779     {\cf19 try} \{\par
03780         result = std::stoll(buffer);\par
03781     \} {\cf19 catch} ({\cf17 const} std::exception&) \{\par
03782         in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03783     \} {\cf19 catch} (...) \{\par
03784         in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03785     \}\par
03786 \par
03787     {\cf19 if} ((zeroes > 0 && (result != 0 || has_minus)) || zeroes > 1)\par
03788         in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03789 \par
03790     {\cf19 return} result;\par
03791 \}\par
03792 \par
03793 {\cf17 static} {\cf17 inline} {\cf18 long} {\cf18 long} stringToLongLong(InStream &in, {\cf17 const} std::string& buffer) \{\par
03794     {\cf19 for} ({\cf18 size_t} i = 0; i < buffer.length(); i++)\par
03795         {\cf19 if} (buffer[i] == {\cf23 '\\0'})\par
03796             in.quit(_pe, ({\cf22 "Expected integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found (it contains \\\\0)"}).c_str());\par
03797     {\cf19 return} stringToLongLong(in, buffer.c_str());\par
03798 \}\par
03799 \par
03800 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} {\cf18 long} stringToUnsignedLongLong(InStream &in, {\cf17 const} {\cf18 char} *buffer) \{\par
03801     {\cf18 size_t} length = strlen(buffer);\par
03802 \par
03803     {\cf19 if} (length == 0 || length > 20)\par
03804         in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03805     {\cf19 if} (length > 1 && buffer[0] == {\cf23 '0'})\par
03806         in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03807 \par
03808     {\cf19 for} ({\cf18 int} i = 0; i < int(length); i++) \{\par
03809         {\cf19 if} (buffer[i] < {\cf23 '0'} || buffer[i] > {\cf23 '9'})\par
03810             in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03811     \}\par
03812 \par
03813     {\cf18 unsigned} {\cf18 long} {\cf18 long} result;\par
03814     {\cf19 try} \{\par
03815         result = std::stoull(buffer);\par
03816     \} {\cf19 catch} ({\cf17 const} std::exception&) \{\par
03817         in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03818     \} {\cf19 catch} (...) \{\par
03819         in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found"}).c_str());\par
03820     \}\par
03821 \par
03822     {\cf19 return} result;\par
03823 \}\par
03824 \par
03825 {\cf17 static} {\cf17 inline} {\cf18 long} {\cf18 long} stringToUnsignedLongLong(InStream &in, {\cf17 const} std::string& buffer) \{\par
03826     {\cf19 for} ({\cf18 size_t} i = 0; i < buffer.length(); i++)\par
03827         {\cf19 if} (buffer[i] == {\cf23 '\\0'})\par
03828             in.quit(_pe, ({\cf22 "Expected unsigned integer, but \\""} + __testlib_part(buffer) + {\cf22 "\\" found (it contains \\\\0)"}).c_str());\par
03829     {\cf19 return} stringToUnsignedLongLong(in, buffer.c_str());\par
03830 \}\par
03831 \par
03832 {\cf18 int} InStream::readInteger() \{\par
03833     {\cf19 if} (!strict && seekEof())\par
03834         quit(_unexpected_eof, {\cf22 "Unexpected end of file - int32 expected"});\par
03835 \par
03836     readWordTo(_tmpReadToken);\par
03837 \par
03838     {\cf18 long} {\cf18 long} value = stringToLongLong(*{\cf17 this}, _tmpReadToken);\par
03839     {\cf19 if} (value < INT_MIN || value > INT_MAX)\par
03840         quit(_pe, ({\cf22 "Expected int32, but \\""} + __testlib_part(_tmpReadToken) + {\cf22 "\\" found"}).c_str());\par
03841 \par
03842     {\cf19 return} int(value);\par
03843 \}\par
03844 \par
03845 {\cf18 long} {\cf18 long} InStream::readLong() \{\par
03846     {\cf19 if} (!strict && seekEof())\par
03847         quit(_unexpected_eof, {\cf22 "Unexpected end of file - int64 expected"});\par
03848 \par
03849     readWordTo(_tmpReadToken);\par
03850 \par
03851     {\cf19 return} stringToLongLong(*{\cf17 this}, _tmpReadToken);\par
03852 \}\par
03853 \par
03854 {\cf18 unsigned} {\cf18 long} {\cf18 long} InStream::readUnsignedLong() \{\par
03855     {\cf19 if} (!strict && seekEof())\par
03856         quit(_unexpected_eof, {\cf22 "Unexpected end of file - int64 expected"});\par
03857 \par
03858     readWordTo(_tmpReadToken);\par
03859 \par
03860     {\cf19 return} stringToUnsignedLongLong(*{\cf17 this}, _tmpReadToken);\par
03861 \}\par
03862 \par
03863 {\cf18 long} {\cf18 long} InStream::readLong({\cf18 long} {\cf18 long} minv, {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName) \{\par
03864     {\cf18 long} {\cf18 long} result = readLong();\par
03865 \par
03866     {\cf19 if} (result < minv || result > maxv) \{\par
03867         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
03868             {\cf19 if} (variableName.empty())\par
03869                 quit(_wa, ({\cf22 "Integer "} + vtos(result) + {\cf22 " violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) +\par
03870                            {\cf22 "]"}).c_str());\par
03871             {\cf19 else}\par
03872                 quit(_wa, ({\cf22 "Integer parameter [name="} + std::string(variableName) + {\cf22 "] equals to "} + vtos(result) +\par
03873                            {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03874         \} {\cf19 else} \{\par
03875             {\cf19 if} (variableName.empty())\par
03876                 quit(_wa, ({\cf22 "Integer element [index="} + vtos(readManyIteration) + {\cf22 "] equals to "} + vtos(result) +\par
03877                            {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03878             {\cf19 else}\par
03879                 quit(_wa,\par
03880                      ({\cf22 "Integer element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) + {\cf22 "] equals to "} +\par
03881                       vtos(result) + {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03882         \}\par
03883     \}\par
03884 \par
03885     {\cf19 if} (strict && !variableName.empty()) \{\par
03886         validator.addBoundsHit(variableName, ValidatorBoundsHit(minv == result, maxv == result));\par
03887         validator.adjustConstantBounds(variableName, minv, maxv);\par
03888         validator.addVariable(variableName);\par
03889     \}\par
03890 \par
03891     {\cf19 return} result;\par
03892 \}\par
03893 \par
03894 std::vector<long long>\par
03895 InStream::readLongs({\cf18 int} size, {\cf18 long} {\cf18 long} minv, {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03896     __testlib_readMany(readLongs, readLong(minv, maxv, variablesName), {\cf18 long} {\cf18 long}, {\cf17 true})\par
03897     {\cf19 if} (strict && !variablesName.empty())\par
03898         validator.addVariable(variablesName);\par
03899 \}\par
03900 \par
03901 std::vector<long long> InStream::readLongs({\cf18 int} size, {\cf18 int} indexBase) \{\par
03902     __testlib_readMany(readLongs, readLong(), {\cf18 long} {\cf18 long}, {\cf17 true})\par
03903 \}\par
03904 \par
03905 {\cf18 unsigned} {\cf18 long} {\cf18 long}\par
03906 InStream::readUnsignedLong({\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName) \{\par
03907     {\cf18 unsigned} {\cf18 long} {\cf18 long} result = readUnsignedLong();\par
03908 \par
03909     {\cf19 if} (result < minv || result > maxv) \{\par
03910         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
03911             {\cf19 if} (variableName.empty())\par
03912                 quit(_wa,\par
03913                      ({\cf22 "Unsigned integer "} + vtos(result) + {\cf22 " violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) +\par
03914                       {\cf22 "]"}).c_str());\par
03915             {\cf19 else}\par
03916                 quit(_wa,\par
03917                      ({\cf22 "Unsigned integer parameter [name="} + std::string(variableName) + {\cf22 "] equals to "} + vtos(result) +\par
03918                       {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03919         \} {\cf19 else} \{\par
03920             {\cf19 if} (variableName.empty())\par
03921                 quit(_wa,\par
03922                      ({\cf22 "Unsigned integer element [index="} + vtos(readManyIteration) + {\cf22 "] equals to "} + vtos(result) +\par
03923                       {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03924             {\cf19 else}\par
03925                 quit(_wa, ({\cf22 "Unsigned integer element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) +\par
03926                            {\cf22 "] equals to "} + vtos(result) + {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) +\par
03927                            {\cf22 "]"}).c_str());\par
03928         \}\par
03929     \}\par
03930 \par
03931     {\cf19 if} (strict && !variableName.empty()) \{\par
03932         validator.addBoundsHit(variableName, ValidatorBoundsHit(minv == result, maxv == result));\par
03933         validator.adjustConstantBounds(variableName, minv, maxv);\par
03934         validator.addVariable(variableName);\par
03935     \}\par
03936 \par
03937     {\cf19 return} result;\par
03938 \}\par
03939 \par
03940 std::vector<unsigned long long> InStream::readUnsignedLongs({\cf18 int} size, {\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv,\par
03941                                                             {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03942     __testlib_readMany(readUnsignedLongs, readUnsignedLong(minv, maxv, variablesName), {\cf18 unsigned} {\cf18 long} {\cf18 long}, {\cf17 true})\par
03943     {\cf19 if} (strict && !variablesName.empty())\par
03944         validator.addVariable(variablesName);\par
03945 \}\par
03946 \par
03947 std::vector<unsigned long long> InStream::readUnsignedLongs({\cf18 int} size, {\cf18 int} indexBase) \{\par
03948     __testlib_readMany(readUnsignedLongs, readUnsignedLong(), {\cf18 unsigned} {\cf18 long} {\cf18 long}, {\cf17 true})\par
03949 \}\par
03950 \par
03951 {\cf18 unsigned} {\cf18 long} {\cf18 long}\par
03952 InStream::readLong({\cf18 unsigned} {\cf18 long} {\cf18 long} minv, {\cf18 unsigned} {\cf18 long} {\cf18 long} maxv, {\cf17 const} std::string &variableName) \{\par
03953     {\cf19 return} readUnsignedLong(minv, maxv, variableName);\par
03954 \}\par
03955 \par
03956 {\cf18 int} InStream::readInt() \{\par
03957     {\cf19 return} readInteger();\par
03958 \}\par
03959 \par
03960 {\cf18 int} InStream::readInt({\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variableName) \{\par
03961     {\cf18 int} result = readInt();\par
03962 \par
03963     {\cf19 if} (result < minv || result > maxv) \{\par
03964         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
03965             {\cf19 if} (variableName.empty())\par
03966                 quit(_wa, ({\cf22 "Integer "} + vtos(result) + {\cf22 " violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) +\par
03967                            {\cf22 "]"}).c_str());\par
03968             {\cf19 else}\par
03969                 quit(_wa, ({\cf22 "Integer parameter [name="} + std::string(variableName) + {\cf22 "] equals to "} + vtos(result) +\par
03970                            {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03971         \} {\cf19 else} \{\par
03972             {\cf19 if} (variableName.empty())\par
03973                 quit(_wa, ({\cf22 "Integer element [index="} + vtos(readManyIteration) + {\cf22 "] equals to "} + vtos(result) +\par
03974                            {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03975             {\cf19 else}\par
03976                 quit(_wa,\par
03977                      ({\cf22 "Integer element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) + {\cf22 "] equals to "} +\par
03978                       vtos(result) + {\cf22 ", violates the range ["} + toHumanReadableString(minv) + {\cf22 ", "} + toHumanReadableString(maxv) + {\cf22 "]"}).c_str());\par
03979         \}\par
03980     \}\par
03981 \par
03982     {\cf19 if} (strict && !variableName.empty()) \{\par
03983         validator.addBoundsHit(variableName, ValidatorBoundsHit(minv == result, maxv == result));\par
03984         validator.adjustConstantBounds(variableName, minv, maxv);\par
03985         validator.addVariable(variableName);\par
03986     \}\par
03987 \par
03988     {\cf19 return} result;\par
03989 \}\par
03990 \par
03991 {\cf18 int} InStream::readInteger({\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variableName) \{\par
03992     {\cf19 return} readInt(minv, maxv, variableName);\par
03993 \}\par
03994 \par
03995 std::vector<int> InStream::readInts({\cf18 int} size, {\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
03996     __testlib_readMany(readInts, readInt(minv, maxv, variablesName), {\cf18 int}, {\cf17 true})\par
03997     {\cf19 if} (strict && !variablesName.empty())\par
03998         validator.addVariable(variablesName);\par
03999 \}\par
04000 \par
04001 std::vector<int> InStream::readInts({\cf18 int} size, {\cf18 int} indexBase) \{\par
04002     __testlib_readMany(readInts, readInt(), {\cf18 int}, {\cf17 true})\par
04003 \}\par
04004 \par
04005 std::vector<int> InStream::readIntegers({\cf18 int} size, {\cf18 int} minv, {\cf18 int} maxv, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04006     __testlib_readMany(readIntegers, readInt(minv, maxv, variablesName), {\cf18 int}, {\cf17 true})\par
04007     {\cf19 if} (strict && !variablesName.empty())\par
04008         validator.addVariable(variablesName);\par
04009 \}\par
04010 \par
04011 std::vector<int> InStream::readIntegers({\cf18 int} size, {\cf18 int} indexBase) \{\par
04012     __testlib_readMany(readIntegers, readInt(), {\cf18 int}, {\cf17 true})\par
04013 \}\par
04014 \par
04015 {\cf18 double} InStream::readReal() \{\par
04016     {\cf19 if} (!strict && seekEof())\par
04017         quit(_unexpected_eof, {\cf22 "Unexpected end of file - double expected"});\par
04018 \par
04019     {\cf19 return} stringToDouble(*{\cf17 this}, readWord());\par
04020 \}\par
04021 \par
04022 {\cf18 double} InStream::readDouble() \{\par
04023     {\cf19 return} readReal();\par
04024 \}\par
04025 \par
04026 {\cf18 double} InStream::readReal({\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variableName) \{\par
04027     {\cf18 double} result = readReal();\par
04028 \par
04029     {\cf19 if} (result < minv || result > maxv) \{\par
04030         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
04031             {\cf19 if} (variableName.empty())\par
04032                 quit(_wa, ({\cf22 "Double "} + vtos(result) + {\cf22 " violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) +\par
04033                            {\cf22 "]"}).c_str());\par
04034             {\cf19 else}\par
04035                 quit(_wa, ({\cf22 "Double parameter [name="} + std::string(variableName) + {\cf22 "] equals to "} + vtos(result) +\par
04036                            {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) + {\cf22 "]"}).c_str());\par
04037         \} {\cf19 else} \{\par
04038             {\cf19 if} (variableName.empty())\par
04039                 quit(_wa, ({\cf22 "Double element [index="} + vtos(readManyIteration) + {\cf22 "] equals to "} + vtos(result) +\par
04040                            {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) + {\cf22 "]"}).c_str());\par
04041             {\cf19 else}\par
04042                 quit(_wa,\par
04043                      ({\cf22 "Double element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) + {\cf22 "] equals to "} +\par
04044                       vtos(result) + {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) + {\cf22 "]"}).c_str());\par
04045         \}\par
04046     \}\par
04047 \par
04048     {\cf19 if} (strict && !variableName.empty()) \{\par
04049         validator.addBoundsHit(variableName, ValidatorBoundsHit(\par
04050                 doubleDelta(minv, result) < ValidatorBoundsHit::EPS,\par
04051                 doubleDelta(maxv, result) < ValidatorBoundsHit::EPS\par
04052         ));\par
04053         validator.adjustConstantBounds(variableName, minv, maxv);\par
04054         validator.addVariable(variableName);\par
04055     \}\par
04056     \par
04057     {\cf19 return} result;\par
04058 \}\par
04059 \par
04060 std::vector<double>\par
04061 InStream::readReals({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04062     __testlib_readMany(readReals, readReal(minv, maxv, variablesName), {\cf18 double}, {\cf17 true})\par
04063     {\cf19 if} (strict && !variablesName.empty())\par
04064         validator.addVariable(variablesName);\par
04065 \}\par
04066 \par
04067 std::vector<double> InStream::readReals({\cf18 int} size, {\cf18 int} indexBase) \{\par
04068     __testlib_readMany(readReals, readReal(), {\cf18 double}, {\cf17 true})\par
04069 \}\par
04070 \par
04071 {\cf18 double} InStream::readDouble({\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variableName) \{\par
04072     {\cf19 return} readReal(minv, maxv, variableName);\par
04073 \}\par
04074 \par
04075 std::vector<double>\par
04076 InStream::readDoubles({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04077     __testlib_readMany(readDoubles, readDouble(minv, maxv, variablesName), {\cf18 double}, {\cf17 true})\par
04078     {\cf19 if} (strict && !variablesName.empty())\par
04079         validator.addVariable(variablesName);\par
04080 \}\par
04081 \par
04082 std::vector<double> InStream::readDoubles({\cf18 int} size, {\cf18 int} indexBase) \{\par
04083     __testlib_readMany(readDoubles, readDouble(), {\cf18 double}, {\cf17 true})\par
04084 \}\par
04085 \par
04086 {\cf18 double} InStream::readStrictReal({\cf18 double} minv, {\cf18 double} maxv,\par
04087                                 {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
04088                                 {\cf17 const} std::string &variableName) \{\par
04089     {\cf19 if} (!strict && seekEof())\par
04090         quit(_unexpected_eof, {\cf22 "Unexpected end of file - strict double expected"});\par
04091 \par
04092     {\cf18 double} result = stringToStrictDouble(*{\cf17 this}, readWord(), minAfterPointDigitCount, maxAfterPointDigitCount);\par
04093 \par
04094     {\cf19 if} (result < minv || result > maxv) \{\par
04095         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
04096             {\cf19 if} (variableName.empty())\par
04097                 quit(_wa, ({\cf22 "Strict double "} + vtos(result) + {\cf22 " violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) +\par
04098                            {\cf22 "]"}).c_str());\par
04099             {\cf19 else}\par
04100                 quit(_wa,\par
04101                      ({\cf22 "Strict double parameter [name="} + std::string(variableName) + {\cf22 "] equals to "} + vtos(result) +\par
04102                       {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) + {\cf22 "]"}).c_str());\par
04103         \} {\cf19 else} \{\par
04104             {\cf19 if} (variableName.empty())\par
04105                 quit(_wa, ({\cf22 "Strict double element [index="} + vtos(readManyIteration) + {\cf22 "] equals to "} + vtos(result) +\par
04106                            {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) + {\cf22 "]"}).c_str());\par
04107             {\cf19 else}\par
04108                 quit(_wa, ({\cf22 "Strict double element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) +\par
04109                            {\cf22 "] equals to "} + vtos(result) + {\cf22 ", violates the range ["} + vtos(minv) + {\cf22 ", "} + vtos(maxv) +\par
04110                            {\cf22 "]"}).c_str());\par
04111         \}\par
04112     \}\par
04113 \par
04114     {\cf19 if} (strict && !variableName.empty()) \{\par
04115         validator.addBoundsHit(variableName, ValidatorBoundsHit(\par
04116                 doubleDelta(minv, result) < ValidatorBoundsHit::EPS,\par
04117                 doubleDelta(maxv, result) < ValidatorBoundsHit::EPS\par
04118         ));\par
04119         validator.adjustConstantBounds(variableName, minv, maxv);\par
04120         validator.addVariable(variableName);\par
04121     \}\par
04122 \par
04123     {\cf19 return} result;\par
04124 \}\par
04125 \par
04126 std::vector<double> InStream::readStrictReals({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv,\par
04127                                               {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
04128                                               {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04129     __testlib_readMany(readStrictReals,\par
04130                        readStrictReal(minv, maxv, minAfterPointDigitCount, maxAfterPointDigitCount, variablesName),\par
04131                        {\cf18 double}, {\cf17 true})\par
04132     {\cf19 if} (strict && !variablesName.empty())\par
04133         validator.addVariable(variablesName);\par
04134 \}\par
04135 \par
04136 {\cf18 double} InStream::readStrictDouble({\cf18 double} minv, {\cf18 double} maxv,\par
04137                                   {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
04138                                   {\cf17 const} std::string &variableName) \{\par
04139     {\cf19 return} readStrictReal(minv, maxv,\par
04140                           minAfterPointDigitCount, maxAfterPointDigitCount,\par
04141                           variableName);\par
04142 \}\par
04143 \par
04144 std::vector<double> InStream::readStrictDoubles({\cf18 int} size, {\cf18 double} minv, {\cf18 double} maxv,\par
04145                                                 {\cf18 int} minAfterPointDigitCount, {\cf18 int} maxAfterPointDigitCount,\par
04146                                                 {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04147     __testlib_readMany(readStrictDoubles,\par
04148                        readStrictDouble(minv, maxv, minAfterPointDigitCount, maxAfterPointDigitCount, variablesName),\par
04149                        {\cf18 double}, {\cf17 true})\par
04150     {\cf19 if} (strict && !variablesName.empty())\par
04151         validator.addVariable(variablesName);\par
04152 \}\par
04153 \par
04154 {\cf18 bool} InStream::eof() \{\par
04155     {\cf19 if} (!strict && NULL == reader)\par
04156         {\cf19 return} {\cf17 true};\par
04157 \par
04158     {\cf19 return} reader->eof();\par
04159 \}\par
04160 \par
04161 {\cf18 bool} InStream::seekEof() \{\par
04162     {\cf19 if} (!strict && NULL == reader)\par
04163         {\cf19 return} {\cf17 true};\par
04164     skipBlanks();\par
04165     {\cf19 return} eof();\par
04166 \}\par
04167 \par
04168 {\cf18 bool} InStream::eoln() \{\par
04169     {\cf19 if} (!strict && NULL == reader)\par
04170         {\cf19 return} {\cf17 true};\par
04171 \par
04172     {\cf18 int} c = reader->nextChar();\par
04173 \par
04174     {\cf19 if} (!strict) \{\par
04175         {\cf19 if} (c == EOFC)\par
04176             {\cf19 return} {\cf17 true};\par
04177 \par
04178         {\cf19 if} (c == CR) \{\par
04179             c = reader->nextChar();\par
04180 \par
04181             {\cf19 if} (c != LF) \{\par
04182                 reader->unreadChar(c);\par
04183                 reader->unreadChar(CR);\par
04184                 {\cf19 return} {\cf17 false};\par
04185             \} {\cf19 else}\par
04186                 {\cf19 return} {\cf17 true};\par
04187         \}\par
04188 \par
04189         {\cf19 if} (c == LF)\par
04190             {\cf19 return} {\cf17 true};\par
04191 \par
04192         reader->unreadChar(c);\par
04193         {\cf19 return} {\cf17 false};\par
04194     \} {\cf19 else} \{\par
04195         {\cf18 bool} returnCr = {\cf17 false};\par
04196 \par
04197 {\cf21 #if (defined(ON_WINDOWS) && !defined(FOR_LINUX)) || defined(FOR_WINDOWS)}\par
04198         {\cf19 if} (c != CR) \{\par
04199             reader->unreadChar(c);\par
04200             {\cf19 return} {\cf17 false};\par
04201         \} {\cf19 else} \{\par
04202             {\cf19 if} (!returnCr)\par
04203                 returnCr = {\cf17 true};\par
04204             c = reader->nextChar();\par
04205         \}\par
04206 {\cf21 #endif}\par
04207         {\cf19 if} (c != LF) \{\par
04208             reader->unreadChar(c);\par
04209             {\cf19 if} (returnCr)\par
04210                 reader->unreadChar(CR);\par
04211             {\cf19 return} {\cf17 false};\par
04212         \}\par
04213 \par
04214         {\cf19 return} {\cf17 true};\par
04215     \}\par
04216 \}\par
04217 \par
04218 {\cf18 void} InStream::readEoln() \{\par
04219     lastLine = reader->getLine();\par
04220     {\cf19 if} (!eoln())\par
04221         quit(_pe, {\cf22 "Expected EOLN"});\par
04222 \}\par
04223 \par
04224 {\cf18 void} InStream::readEof() \{\par
04225     lastLine = reader->getLine();\par
04226     {\cf19 if} (!eof())\par
04227         quit(_pe, {\cf22 "Expected EOF"});\par
04228 \par
04229     {\cf19 if} (TestlibFinalizeGuard::alive && {\cf17 this} == &inf)\par
04230         testlibFinalizeGuard.readEofCount++;\par
04231 \}\par
04232 \par
04233 {\cf18 bool} InStream::seekEoln() \{\par
04234     {\cf19 if} (!strict && NULL == reader)\par
04235         {\cf19 return} {\cf17 true};\par
04236 \par
04237     {\cf18 int} cur;\par
04238     {\cf19 do} \{\par
04239         cur = reader->nextChar();\par
04240     \} {\cf19 while} (cur == SPACE || cur == TAB);\par
04241 \par
04242     reader->unreadChar(cur);\par
04243     {\cf19 return} eoln();\par
04244 \}\par
04245 \par
04246 {\cf18 void} InStream::nextLine() \{\par
04247     readLine();\par
04248 \}\par
04249 \par
04250 {\cf18 void} InStream::readStringTo(std::string &result) \{\par
04251     {\cf19 if} (NULL == reader)\par
04252         quit(_pe, {\cf22 "Expected line"});\par
04253 \par
04254     result.clear();\par
04255 \par
04256     {\cf19 for} (;;) \{\par
04257         {\cf18 int} cur = reader->curChar();\par
04258 \par
04259         {\cf19 if} (cur == LF || cur == EOFC)\par
04260             {\cf19 break};\par
04261 \par
04262         {\cf19 if} (cur == CR) \{\par
04263             cur = reader->nextChar();\par
04264             {\cf19 if} (reader->curChar() == LF) \{\par
04265                 reader->unreadChar(cur);\par
04266                 {\cf19 break};\par
04267             \}\par
04268         \}\par
04269 \par
04270         lastLine = reader->getLine();\par
04271         result += char(reader->nextChar());\par
04272     \}\par
04273 \par
04274     {\cf19 if} (strict)\par
04275         readEoln();\par
04276     {\cf19 else}\par
04277         eoln();\par
04278 \}\par
04279 \par
04280 std::string InStream::readString() \{\par
04281     readStringTo(_tmpReadToken);\par
04282     {\cf19 return} _tmpReadToken;\par
04283 \}\par
04284 \par
04285 std::vector<std::string> InStream::readStrings({\cf18 int} size, {\cf18 int} indexBase) \{\par
04286     __testlib_readMany(readStrings, readString(), std::string, {\cf17 false})\par
04287 \}\par
04288 \par
04289 {\cf18 void} InStream::readStringTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
04290     readStringTo(result);\par
04291     {\cf19 if} (!p.matches(result)) \{\par
04292         {\cf19 if} (readManyIteration == NO_INDEX) \{\par
04293             {\cf19 if} (variableName.empty())\par
04294                 quit(_wa, ({\cf22 "Line \\""} + __testlib_part(result) + {\cf22 "\\" doesn't correspond to pattern \\""} + p.src() +\par
04295                            {\cf22 "\\""}).c_str());\par
04296             {\cf19 else}\par
04297                 quit(_wa, ({\cf22 "Line [name="} + variableName + {\cf22 "] equals to \\""} + __testlib_part(result) +\par
04298                            {\cf22 "\\", doesn't correspond to pattern \\""} + p.src() + {\cf22 "\\""}).c_str());\par
04299         \} {\cf19 else} \{\par
04300             {\cf19 if} (variableName.empty())\par
04301                 quit(_wa,\par
04302                      ({\cf22 "Line element [index="} + vtos(readManyIteration) + {\cf22 "] equals to \\""} + __testlib_part(result) +\par
04303                       {\cf22 "\\" doesn't correspond to pattern \\""} + p.src() + {\cf22 "\\""}).c_str());\par
04304             {\cf19 else}\par
04305                 quit(_wa,\par
04306                      ({\cf22 "Line element "} + std::string(variableName) + {\cf22 "["} + vtos(readManyIteration) + {\cf22 "] equals to \\""} +\par
04307                       __testlib_part(result) + {\cf22 "\\", doesn't correspond to pattern \\""} + p.src() + {\cf22 "\\""}).c_str());\par
04308         \}\par
04309     \}\par
04310     {\cf19 if} (strict && !variableName.empty())\par
04311         validator.addVariable(variableName);\par
04312 \}\par
04313 \par
04314 {\cf18 void} InStream::readStringTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
04315     readStringTo(result, pattern(ptrn), variableName);\par
04316 \}\par
04317 \par
04318 std::string InStream::readString({\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
04319     readStringTo(_tmpReadToken, p, variableName);\par
04320     {\cf19 return} _tmpReadToken;\par
04321 \}\par
04322 \par
04323 std::vector<std::string>\par
04324 InStream::readStrings({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04325     __testlib_readMany(readStrings, readString(p, variablesName), std::string, {\cf17 false})\par
04326     {\cf19 if} (strict && !variablesName.empty())\par
04327         validator.addVariable(variablesName);\par
04328 \}\par
04329 \par
04330 std::string InStream::readString({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
04331     readStringTo(_tmpReadToken, ptrn, variableName);\par
04332     {\cf19 return} _tmpReadToken;\par
04333 \}\par
04334 \par
04335 std::vector<std::string>\par
04336 InStream::readStrings({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04337     pattern p(ptrn);\par
04338     __testlib_readMany(readStrings, readString(p, variablesName), std::string, {\cf17 false})\par
04339     {\cf19 if} (strict && !variablesName.empty())\par
04340         validator.addVariable(variablesName);\par
04341 \}\par
04342 \par
04343 {\cf18 void} InStream::readLineTo(std::string &result) \{\par
04344     readStringTo(result);\par
04345 \}\par
04346 \par
04347 std::string InStream::readLine() \{\par
04348     {\cf19 return} readString();\par
04349 \}\par
04350 \par
04351 std::vector<std::string> InStream::readLines({\cf18 int} size, {\cf18 int} indexBase) \{\par
04352     __testlib_readMany(readLines, readString(), std::string, {\cf17 false})\par
04353 \}\par
04354 \par
04355 {\cf18 void} InStream::readLineTo(std::string &result, {\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
04356     readStringTo(result, p, variableName);\par
04357 \}\par
04358 \par
04359 {\cf18 void} InStream::readLineTo(std::string &result, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
04360     readStringTo(result, ptrn, variableName);\par
04361 \}\par
04362 \par
04363 std::string InStream::readLine({\cf17 const} pattern &p, {\cf17 const} std::string &variableName) \{\par
04364     {\cf19 return} readString(p, variableName);\par
04365 \}\par
04366 \par
04367 std::vector<std::string>\par
04368 InStream::readLines({\cf18 int} size, {\cf17 const} pattern &p, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04369     __testlib_readMany(readLines, readString(p, variablesName), std::string, {\cf17 false})\par
04370     {\cf19 if} (strict && !variablesName.empty())\par
04371         validator.addVariable(variablesName);\par
04372 \}\par
04373 \par
04374 std::string InStream::readLine({\cf17 const} std::string &ptrn, {\cf17 const} std::string &variableName) \{\par
04375     {\cf19 return} readString(ptrn, variableName);\par
04376 \}\par
04377 \par
04378 std::vector<std::string>\par
04379 InStream::readLines({\cf18 int} size, {\cf17 const} std::string &ptrn, {\cf17 const} std::string &variablesName, {\cf18 int} indexBase) \{\par
04380     pattern p(ptrn);\par
04381     __testlib_readMany(readLines, readString(p, variablesName), std::string, {\cf17 false})\par
04382     {\cf19 if} (strict && !variablesName.empty())\par
04383         validator.addVariable(variablesName);\par
04384 \}\par
04385 \par
04386 {\cf21 #ifdef __GNUC__}\par
04387 __attribute__ ((format (printf, 3, 4)))\par
04388 {\cf21 #endif}\par
04389 {\cf18 void} InStream::ensuref({\cf18 bool} cond, {\cf17 const} {\cf18 char} *format, ...) \{\par
04390     {\cf19 if} (!cond) \{\par
04391         FMT_TO_RESULT(format, format, message);\par
04392         this->__testlib_ensure(cond, message);\par
04393     \}\par
04394 \}\par
04395 \par
04396 {\cf18 void} InStream::__testlib_ensure({\cf18 bool} cond, std::string message) \{\par
04397     {\cf19 if} (!cond)\par
04398         this->quit(_wa, message.c_str());\par
04399 \}\par
04400 \par
04401 {\cf18 void} InStream::close() \{\par
04402     {\cf19 if} (NULL != reader) \{\par
04403         reader->close();\par
04404         {\cf17 delete} reader;\par
04405         reader = NULL;\par
04406     \}\par
04407 \par
04408     opened = {\cf17 false};\par
04409 \}\par
04410 \par
04411 NORETURN {\cf18 void} quit(TResult result, {\cf17 const} std::string &msg) \{\par
04412     ouf.quit(result, msg.c_str());\par
04413 \}\par
04414 \par
04415 NORETURN {\cf18 void} quit(TResult result, {\cf17 const} {\cf18 char} *msg) \{\par
04416     ouf.quit(result, msg);\par
04417 \}\par
04418 \par
04419 NORETURN {\cf18 void} __testlib_quitp({\cf18 double} points, {\cf17 const} {\cf18 char} *message) \{\par
04420     __testlib_points = points;\par
04421     std::string stringPoints = removeDoubleTrailingZeroes(format({\cf22 "%.10f"}, points));\par
04422 \par
04423     std::string quitMessage;\par
04424     {\cf19 if} (NULL == message || 0 == strlen(message))\par
04425         quitMessage = stringPoints;\par
04426     {\cf19 else}\par
04427         quitMessage = stringPoints + {\cf22 " "} + message;\par
04428 \par
04429     quit(_points, quitMessage.c_str());\par
04430 \}\par
04431 \par
04432 NORETURN {\cf18 void} __testlib_quitp({\cf18 int} points, {\cf17 const} {\cf18 char} *message) \{\par
04433     __testlib_points = points;\par
04434     std::string stringPoints = format({\cf22 "%d"}, points);\par
04435 \par
04436     std::string quitMessage;\par
04437     {\cf19 if} (NULL == message || 0 == strlen(message))\par
04438         quitMessage = stringPoints;\par
04439     {\cf19 else}\par
04440         quitMessage = stringPoints + {\cf22 " "} + message;\par
04441 \par
04442     quit(_points, quitMessage.c_str());\par
04443 \}\par
04444 \par
04445 NORETURN {\cf18 void} quitp({\cf18 float} points, {\cf17 const} std::string &message = {\cf22 ""}) \{\par
04446     __testlib_quitp({\cf18 double}(points), message.c_str());\par
04447 \}\par
04448 \par
04449 NORETURN {\cf18 void} quitp({\cf18 double} points, {\cf17 const} std::string &message = {\cf22 ""}) \{\par
04450     __testlib_quitp(points, message.c_str());\par
04451 \}\par
04452 \par
04453 NORETURN {\cf18 void} quitp({\cf18 long} {\cf18 double} points, {\cf17 const} std::string &message = {\cf22 ""}) \{\par
04454     __testlib_quitp({\cf18 double}(points), message.c_str());\par
04455 \}\par
04456 \par
04457 NORETURN {\cf18 void} quitp({\cf18 int} points, {\cf17 const} std::string &message = {\cf22 ""}) \{\par
04458     __testlib_quitp(points, message.c_str());\par
04459 \}\par
04460 \par
04461 NORETURN {\cf18 void} quitpi({\cf17 const} std::string &points_info, {\cf17 const} std::string &message = {\cf22 ""}) \{\par
04462     {\cf19 if} (points_info.find({\cf23 ' '}) != std::string::npos)\par
04463         quit(_fail, {\cf22 "Parameter 'points_info' can't contain spaces"});\par
04464     {\cf19 if} (message.empty())\par
04465         quit(_points, ({\cf22 "points_info="} + points_info).c_str());\par
04466     {\cf19 else}\par
04467         quit(_points, ({\cf22 "points_info="} + points_info + {\cf22 " "} + message).c_str());\par
04468 \}\par
04469 \par
04470 {\cf17 template}<{\cf17 typename} F>\par
04471 {\cf21 #ifdef __GNUC__}\par
04472 __attribute__ ((format (printf, 2, 3)))\par
04473 {\cf21 #endif}\par
04474 NORETURN {\cf18 void} quitp(F points, {\cf17 const} {\cf18 char} *format, ...) \{\par
04475     FMT_TO_RESULT(format, format, message);\par
04476     quitp(points, message);\par
04477 \}\par
04478 \par
04479 {\cf21 #ifdef __GNUC__}\par
04480 __attribute__ ((format (printf, 2, 3)))\par
04481 {\cf21 #endif}\par
04482 NORETURN {\cf18 void} quitf(TResult result, {\cf17 const} {\cf18 char} *format, ...) \{\par
04483     FMT_TO_RESULT(format, format, message);\par
04484     quit(result, message);\par
04485 \}\par
04486 \par
04487 {\cf21 #ifdef __GNUC__}\par
04488 __attribute__ ((format (printf, 3, 4)))\par
04489 {\cf21 #endif}\par
04490 {\cf18 void} quitif({\cf18 bool} condition, TResult result, {\cf17 const} {\cf18 char} *format, ...) \{\par
04491     {\cf19 if} (condition) \{\par
04492         FMT_TO_RESULT(format, format, message);\par
04493         quit(result, message);\par
04494     \}\par
04495 \}\par
04496 \par
04497 NORETURN {\cf18 void} __testlib_help() \{\par
04498     InStream::textColor(InStream::LightCyan);\par
04499     std::fprintf(stderr, {\cf22 "TESTLIB %s, https://github.com/MikeMirzayanov/testlib/ "}, VERSION);\par
04500     std::fprintf(stderr, {\cf22 "by Mike Mirzayanov, copyright(c) 2005-2020\\n"});\par
04501     std::fprintf(stderr, {\cf22 "Checker name: \\"%s\\"\\n"}, checkerName.c_str());\par
04502     InStream::textColor(InStream::LightGray);\par
04503 \par
04504     std::fprintf(stderr, {\cf22 "\\n"});\par
04505     std::fprintf(stderr, {\cf22 "Latest features: \\n"});\par
04506     {\cf19 for} ({\cf18 size_t} i = 0; i < {\cf17 sizeof}(latestFeatures) / {\cf17 sizeof}({\cf18 char} *); i++) \{\par
04507         std::fprintf(stderr, {\cf22 "*) %s\\n"}, latestFeatures[i]);\par
04508     \}\par
04509     std::fprintf(stderr, {\cf22 "\\n"});\par
04510 \par
04511     std::fprintf(stderr, {\cf22 "Program must be run with the following arguments: \\n"});\par
04512     std::fprintf(stderr, {\cf22 "    [--testset testset] [--group group] <input-file> <output-file> <answer-file> [<report-file> [<-appes>]]\\n\\n"});\par
04513 \par
04514     __testlib_exitCode = FAIL_EXIT_CODE;\par
04515     std::exit(FAIL_EXIT_CODE);\par
04516 \}\par
04517 \par
04518 {\cf17 static} {\cf18 void} __testlib_ensuresPreconditions() \{\par
04519     {\cf20 // testlib assumes: sizeof(int) = 4.}\par
04520     __TESTLIB_STATIC_ASSERT({\cf17 sizeof}({\cf18 int}) == 4);\par
04521 \par
04522     {\cf20 // testlib assumes: INT_MAX == 2147483647.}\par
04523     __TESTLIB_STATIC_ASSERT(INT_MAX == 2147483647);\par
04524 \par
04525     {\cf20 // testlib assumes: sizeof(long long) = 8.}\par
04526     __TESTLIB_STATIC_ASSERT({\cf17 sizeof}({\cf18 long} {\cf18 long}) == 8);\par
04527 \par
04528     {\cf20 // testlib assumes: sizeof(double) = 8.}\par
04529     __TESTLIB_STATIC_ASSERT({\cf17 sizeof}({\cf18 double}) == 8);\par
04530 \par
04531     {\cf20 // testlib assumes: no -ffast-math.}\par
04532     {\cf19 if} (!__testlib_isNaN(+__testlib_nan()))\par
04533         quit(_fail, {\cf22 "Function __testlib_isNaN is not working correctly: possible reason is '-ffast-math'"});\par
04534     {\cf19 if} (!__testlib_isNaN(-__testlib_nan()))\par
04535         quit(_fail, {\cf22 "Function __testlib_isNaN is not working correctly: possible reason is '-ffast-math'"});\par
04536 \}\par
04537 \par
04538 std::string __testlib_testset;\par
04539 \par
04540 std::string getTestset() \{\par
04541     {\cf19 return} __testlib_testset;\par
04542 \}\par
04543 \par
04544 std::string __testlib_group;\par
04545 \par
04546 std::string getGroup() \{\par
04547     {\cf19 return} __testlib_group;\par
04548 \}\par
04549 \par
04550 {\cf17 static} {\cf18 void} __testlib_set_testset_and_group({\cf18 int} argc, {\cf18 char}* argv[]) \{\par
04551     {\cf19 for} ({\cf18 int} i = 1; i < argc; i++) \{\par
04552         {\cf19 if} (!strcmp({\cf22 "--testset"}, argv[i])) \{\par
04553             {\cf19 if} (i + 1 < argc && strlen(argv[i + 1]) > 0)\par
04554                 __testlib_testset = argv[++i];\par
04555             {\cf19 else}\par
04556                 quit(_fail, std::string({\cf22 "Expected non-empty testset after --testset command line parameter"}));\par
04557         \} {\cf19 else} {\cf19 if} (!strcmp({\cf22 "--group"}, argv[i])) \{\par
04558             {\cf19 if} (i + 1 < argc)\par
04559                 __testlib_group = argv[++i];\par
04560             {\cf19 else}\par
04561                 quit(_fail, std::string({\cf22 "Expected group after --group command line parameter"}));\par
04562         \}\par
04563     \}\par
04564 \}\par
04565 \par
04566 {\cf18 void} registerGen({\cf18 int} argc, {\cf18 char} *argv[], {\cf18 int} randomGeneratorVersion) \{\par
04567     {\cf19 if} (randomGeneratorVersion < 0 || randomGeneratorVersion > 1)\par
04568         quitf(_fail, {\cf22 "Random generator version is expected to be 0 or 1."});\par
04569     random_t::version = randomGeneratorVersion;\par
04570 \par
04571     __testlib_ensuresPreconditions();\par
04572     TestlibFinalizeGuard::registered = {\cf17 true};\par
04573 \par
04574     testlibMode = _generator;\par
04575     __testlib_set_binary(stdin);\par
04576     rnd.setSeed(argc, argv);\par
04577 \par
04578 {\cf21 #if __cplusplus > 199711L || defined(_MSC_VER)}\par
04579     prepareOpts(argc, argv);\par
04580 {\cf21 #endif}\par
04581 \}\par
04582 \par
04583 {\cf21 #ifdef USE_RND_AS_BEFORE_087}\par
04584 {\cf18 void} registerGen({\cf18 int} argc, {\cf18 char}* argv[])\par
04585 \{\par
04586     registerGen(argc, argv, 0);\par
04587 \}\par
04588 {\cf21 #else}\par
04589 {\cf21 #ifdef __GNUC__}\par
04590 {\cf21 #if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 4))}\par
04591 __attribute__ ((deprecated({\cf22 "Use registerGen(argc, argv, 0) or registerGen(argc, argv, 1)."}\par
04592 {\cf22 " The third parameter stands for the random generator version."}\par
04593 {\cf22 " If you are trying to compile old generator use macro -DUSE_RND_AS_BEFORE_087 or registerGen(argc, argv, 0)."}\par
04594 {\cf22 " Version 1 has been released on Spring, 2013. Use it to write new generators."})))\par
04595 {\cf21 #else}\par
04596 __attribute__ ((deprecated))\par
04597 {\cf21 #endif}\par
04598 {\cf21 #endif}\par
04599 {\cf21 #ifdef _MSC_VER}\par
04600 __declspec(deprecated({\cf22 "Use registerGen(argc, argv, 0) or registerGen(argc, argv, 1)."}\par
04601         {\cf22 " The third parameter stands for the random generator version."}\par
04602         {\cf22 " If you are trying to compile old generator use macro -DUSE_RND_AS_BEFORE_087 or registerGen(argc, argv, 0)."}\par
04603         {\cf22 " Version 1 has been released on Spring, 2013. Use it to write new generators."}))\par
04604 {\cf21 #endif}\par
04605 {\cf18 void} registerGen({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
04606     std::fprintf(stderr, {\cf22 "Use registerGen(argc, argv, 0) or registerGen(argc, argv, 1)."}\par
04607                          {\cf22 " The third parameter stands for the random generator version."}\par
04608                          {\cf22 " If you are trying to compile old generator use macro -DUSE_RND_AS_BEFORE_087 or registerGen(argc, argv, 0)."}\par
04609                          {\cf22 " Version 1 has been released on Spring, 2013. Use it to write new generators.\\n\\n"});\par
04610     registerGen(argc, argv, 0);\par
04611 \}\par
04612 {\cf21 #endif}\par
04613 \par
04614 {\cf18 void} setAppesModeEncoding(std::string appesModeEncoding) \{\par
04615     {\cf17 static} {\cf17 const} {\cf18 char}* {\cf17 const} ENCODINGS[] = \{{\cf22 "ascii"}, {\cf22 "utf-7"}, {\cf22 "utf-8"}, {\cf22 "utf-16"}, {\cf22 "utf-16le"}, {\cf22 "utf-16be"}, {\cf22 "utf-32"}, {\cf22 "utf-32le"}, {\cf22 "utf-32be"}, {\cf22 "iso-8859-1"}, \par
04616 {\cf22 "iso-8859-2"}, {\cf22 "iso-8859-3"}, {\cf22 "iso-8859-4"}, {\cf22 "iso-8859-5"}, {\cf22 "iso-8859-6"}, {\cf22 "iso-8859-7"}, {\cf22 "iso-8859-8"}, {\cf22 "iso-8859-9"}, {\cf22 "iso-8859-10"}, {\cf22 "iso-8859-11"}, \par
04617 {\cf22 "iso-8859-13"}, {\cf22 "iso-8859-14"}, {\cf22 "iso-8859-15"}, {\cf22 "iso-8859-16"}, {\cf22 "windows-1250"}, {\cf22 "windows-1251"}, {\cf22 "windows-1252"}, {\cf22 "windows-1253"}, {\cf22 "windows-1254"}, {\cf22 "windows-1255"}, \par
04618 {\cf22 "windows-1256"}, {\cf22 "windows-1257"}, {\cf22 "windows-1258"}, {\cf22 "gb2312"}, {\cf22 "gbk"}, {\cf22 "gb18030"}, {\cf22 "big5"}, {\cf22 "shift-jis"}, {\cf22 "euc-jp"}, {\cf22 "euc-kr"}, \par
04619 {\cf22 "euc-cn"}, {\cf22 "euc-tw"}, {\cf22 "koi8-r"}, {\cf22 "koi8-u"}, {\cf22 "tis-620"}, {\cf22 "ibm437"}, {\cf22 "ibm850"}, {\cf22 "ibm852"}, {\cf22 "ibm855"}, {\cf22 "ibm857"}, \par
04620 {\cf22 "ibm860"}, {\cf22 "ibm861"}, {\cf22 "ibm862"}, {\cf22 "ibm863"}, {\cf22 "ibm865"}, {\cf22 "ibm866"}, {\cf22 "ibm869"}, {\cf22 "macroman"}, {\cf22 "maccentraleurope"}, {\cf22 "maciceland"}, \par
04621 {\cf22 "maccroatian"}, {\cf22 "macromania"}, {\cf22 "maccyrillic"}, {\cf22 "macukraine"}, {\cf22 "macgreek"}, {\cf22 "macturkish"}, {\cf22 "machebrew"}, {\cf22 "macarabic"}, {\cf22 "macthai"}, {\cf22 "hz-gb-2312"}, \par
04622 {\cf22 "iso-2022-jp"}, {\cf22 "iso-2022-kr"}, {\cf22 "iso-2022-cn"}, {\cf22 "armscii-8"}, {\cf22 "tscii"}, {\cf22 "iscii"}, {\cf22 "viscii"}, {\cf22 "geostd8"}, {\cf22 "cp949"}, {\cf22 "cp874"}, \par
04623 {\cf22 "cp1006"}, {\cf22 "cp775"}, {\cf22 "cp858"}, {\cf22 "cp737"}, {\cf22 "cp853"}, {\cf22 "cp856"}, {\cf22 "cp922"}, {\cf22 "cp1046"}, {\cf22 "cp1125"}, {\cf22 "cp1131"}, \par
04624 {\cf22 "ptcp154"}, {\cf22 "koi8-t"}, {\cf22 "koi8-ru"}, {\cf22 "mulelao-1"}, {\cf22 "cp1133"}, {\cf22 "iso-ir-166"}, {\cf22 "tcvn"}, {\cf22 "iso-ir-14"}, {\cf22 "iso-ir-87"}, {\cf22 "iso-ir-159"}\};\par
04625     \par
04626     appesModeEncoding = lowerCase(appesModeEncoding);\par
04627     {\cf18 bool} valid = {\cf17 false};\par
04628     {\cf19 for} ({\cf18 size_t} i = 0; i < {\cf17 sizeof}(ENCODINGS) / {\cf17 sizeof}(ENCODINGS[0]); i++)\par
04629         {\cf19 if} (appesModeEncoding == ENCODINGS[i]) \{\par
04630             valid = {\cf17 true};\par
04631             {\cf19 break};\par
04632         \}\par
04633     {\cf19 if} (!valid)\par
04634         quit(_fail, {\cf22 "Unexpected encoding for setAppesModeEncoding(encoding)"});\par
04635     ::appesModeEncoding = appesModeEncoding;\par
04636 \}\par
04637 \par
04638 {\cf18 void} registerInteraction({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
04639     __testlib_ensuresPreconditions();\par
04640     __testlib_set_testset_and_group(argc, argv);\par
04641     TestlibFinalizeGuard::registered = {\cf17 true};\par
04642 \par
04643     testlibMode = _interactor;\par
04644     __testlib_set_binary(stdin);\par
04645 \par
04646     {\cf19 if} (argc > 1 && !strcmp({\cf22 "--help"}, argv[1]))\par
04647         __testlib_help();\par
04648 \par
04649     {\cf19 if} (argc < 3 || argc > 6) \{\par
04650         quit(_fail, std::string({\cf22 "Program must be run with the following arguments: "}) +\par
04651                     std::string({\cf22 "<input-file> <output-file> [<answer-file> [<report-file> [<-appes>]]]"}) +\par
04652                     {\cf22 "\\nUse \\"--help\\" to get help information"});\par
04653     \}\par
04654 \par
04655     {\cf19 if} (argc <= 4) \{\par
04656         resultName = {\cf22 ""};\par
04657         appesMode = {\cf17 false};\par
04658     \}\par
04659 \par
04660 {\cf21 #ifndef EJUDGE}\par
04661     {\cf19 if} (argc == 5) \{\par
04662         resultName = argv[4];\par
04663         appesMode = {\cf17 false};\par
04664     \}\par
04665 \par
04666     {\cf19 if} (argc == 6) \{\par
04667         {\cf19 if} (strcmp({\cf22 "-APPES"}, argv[5]) && strcmp({\cf22 "-appes"}, argv[5])) \{\par
04668             quit(_fail, std::string({\cf22 "Program must be run with the following arguments: "}) +\par
04669                         {\cf22 "<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"});\par
04670         \} {\cf19 else} \{\par
04671             resultName = argv[4];\par
04672             appesMode = {\cf17 true};\par
04673         \}\par
04674     \}\par
04675 {\cf21 #endif}\par
04676 \par
04677     inf.init(argv[1], _input);\par
04678 \par
04679     tout.open(argv[2], std::ios_base::out);\par
04680     {\cf19 if} (tout.fail() || !tout.is_open())\par
04681         quit(_fail, std::string({\cf22 "Can not write to the test-output-file '"}) + argv[2] + std::string({\cf22 "'"}));\par
04682 \par
04683     ouf.init(stdin, _output);\par
04684 \par
04685     {\cf19 if} (argc >= 4)\par
04686         ans.init(argv[3], _answer);\par
04687     {\cf19 else}\par
04688         ans.name = {\cf22 "unopened answer stream"};\par
04689 \}\par
04690 \par
04691 {\cf18 void} registerValidation() \{\par
04692     __testlib_ensuresPreconditions();\par
04693     TestlibFinalizeGuard::registered = {\cf17 true};\par
04694 \par
04695     testlibMode = _validator;\par
04696 \par
04697     __testlib_set_binary(stdin);\par
04698     __testlib_set_binary(stdout);\par
04699     __testlib_set_binary(stderr);\par
04700 \par
04701     inf.init(stdin, _input);\par
04702     inf.strict = {\cf17 true};\par
04703 \}\par
04704 \par
04705 {\cf18 void} registerValidation({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
04706     registerValidation();\par
04707     __testlib_set_testset_and_group(argc, argv);\par
04708 \par
04709     validator.initialize();\par
04710     TestlibFinalizeGuard::registered = {\cf17 true};\par
04711 \par
04712     std::string comment = {\cf22 "Validator must be run with the following arguments:"}\par
04713                             {\cf22 " [--testset testset]"}\par
04714                             {\cf22 " [--group group]"}\par
04715                             {\cf22 " [--testOverviewLogFileName fileName]"}\par
04716                             {\cf22 " [--testMarkupFileName fileName]"}\par
04717                             {\cf22 " [--testCase testCase]"}\par
04718                             {\cf22 " [--testCaseFileName fileName]"}\par
04719                             ;\par
04720 \par
04721     {\cf19 for} ({\cf18 int} i = 1; i < argc; i++) \{\par
04722         {\cf19 if} (!strcmp({\cf22 "--testset"}, argv[i])) \{\par
04723             {\cf19 if} (i + 1 < argc && strlen(argv[i + 1]) > 0)\par
04724                 validator.setTestset(argv[++i]);\par
04725             {\cf19 else}\par
04726                 quit(_fail, comment);\par
04727         \}\par
04728         {\cf19 if} (!strcmp({\cf22 "--group"}, argv[i])) \{\par
04729             {\cf19 if} (i + 1 < argc)\par
04730                 validator.setGroup(argv[++i]);\par
04731             {\cf19 else}\par
04732                 quit(_fail, comment);\par
04733         \}\par
04734         {\cf19 if} (!strcmp({\cf22 "--testOverviewLogFileName"}, argv[i])) \{\par
04735             {\cf19 if} (i + 1 < argc)\par
04736                 validator.setTestOverviewLogFileName(argv[++i]);\par
04737             {\cf19 else}\par
04738                 quit(_fail, comment);\par
04739         \}\par
04740         {\cf19 if} (!strcmp({\cf22 "--testMarkupFileName"}, argv[i])) \{\par
04741             {\cf19 if} (i + 1 < argc)\par
04742                 validator.setTestMarkupFileName(argv[++i]);\par
04743             {\cf19 else}\par
04744                 quit(_fail, comment);\par
04745         \}\par
04746         {\cf19 if} (!strcmp({\cf22 "--testCase"}, argv[i])) \{\par
04747             {\cf19 if} (i + 1 < argc) \{\par
04748                 {\cf18 long} {\cf18 long} testCase = stringToLongLong(inf, argv[++i]);\par
04749                 {\cf19 if} (testCase < 1 || testCase >= __TESTLIB_MAX_TEST_CASE)\par
04750                     quit(_fail, format({\cf22 "Argument testCase should be between 1 and %d, but "}, __TESTLIB_MAX_TEST_CASE)\par
04751                         + toString(testCase) + {\cf22 " found"});\par
04752                 validator.setTestCase({\cf18 int}(testCase));\par
04753             \} {\cf19 else}\par
04754                 quit(_fail, comment);\par
04755         \}\par
04756         {\cf19 if} (!strcmp({\cf22 "--testCaseFileName"}, argv[i])) \{\par
04757             {\cf19 if} (i + 1 < argc) \{\par
04758                 validator.setTestCaseFileName(argv[++i]);\par
04759             \} {\cf19 else}\par
04760                 quit(_fail, comment);\par
04761         \}\par
04762     \}\par
04763 \}\par
04764 \par
04765 {\cf18 void} addFeature({\cf17 const} std::string &feature) \{\par
04766     {\cf19 if} (testlibMode != _validator)\par
04767         quit(_fail, {\cf22 "Features are supported in validators only."});\par
04768     validator.addFeature(feature);\par
04769 \}\par
04770 \par
04771 {\cf18 void} feature({\cf17 const} std::string &feature) \{\par
04772     {\cf19 if} (testlibMode != _validator)\par
04773         quit(_fail, {\cf22 "Features are supported in validators only."});\par
04774     validator.feature(feature);\par
04775 \}\par
04776 \par
04777 {\cf17 class }Checker \{\par
04778 {\cf17 private}:\par
04779     {\cf18 bool} _initialized;\par
04780     std::string _testset;\par
04781     std::string _group;\par
04782 \par
04783 {\cf17 public}:\par
04784     Checker() : _initialized(false), _testset({\cf22 "tests"}), _group() \{\par
04785     \}\par
04786 \par
04787     {\cf18 void} initialize() \{\par
04788         _initialized = {\cf17 true};\par
04789     \}\par
04790 \par
04791     std::string testset(){\cf17  const }\{\par
04792         {\cf19 if} (!_initialized)\par
04793             __testlib_fail({\cf22 "Checker should be initialized with registerTestlibCmd(argc, argv) instead of registerTestlibCmd() to support checker.testset()"});\par
04794         {\cf19 return} _testset;\par
04795     \}\par
04796 \par
04797     std::string group(){\cf17  const }\{\par
04798         {\cf19 if} (!_initialized)\par
04799             __testlib_fail({\cf22 "Checker should be initialized with registerTestlibCmd(argc, argv) instead of registerTestlibCmd() to support checker.group()"});\par
04800         {\cf19 return} _group;\par
04801     \}\par
04802 \par
04803     {\cf18 void} setTestset({\cf17 const} {\cf18 char} *{\cf17 const} testset) \{\par
04804         _testset = testset;\par
04805     \}\par
04806 \par
04807     {\cf18 void} setGroup({\cf17 const} {\cf18 char} *{\cf17 const} group) \{\par
04808         _group = group;\par
04809     \}\par
04810 \} checker;\par
04811 \par
04812 {\cf18 void} registerTestlibCmd({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
04813     __testlib_ensuresPreconditions();\par
04814     __testlib_set_testset_and_group(argc, argv);\par
04815     TestlibFinalizeGuard::registered = {\cf17 true};\par
04816 \par
04817     testlibMode = _checker;\par
04818     __testlib_set_binary(stdin);\par
04819 \par
04820     std::vector<std::string> args(1, argv[0]);\par
04821     checker.initialize();\par
04822 \par
04823     {\cf19 for} ({\cf18 int} i = 1; i < argc; i++) \{\par
04824         {\cf19 if} (!strcmp({\cf22 "--testset"}, argv[i])) \{\par
04825             {\cf19 if} (i + 1 < argc && strlen(argv[i + 1]) > 0)\par
04826                 checker.setTestset(argv[++i]);\par
04827             {\cf19 else}\par
04828                 quit(_fail, std::string({\cf22 "Expected testset after --testset command line parameter"}));\par
04829         \} {\cf19 else} {\cf19 if} (!strcmp({\cf22 "--group"}, argv[i])) \{\par
04830             {\cf19 if} (i + 1 < argc)\par
04831                 checker.setGroup(argv[++i]);\par
04832             {\cf19 else}\par
04833                 quit(_fail, std::string({\cf22 "Expected group after --group command line parameter"}));\par
04834         \} {\cf19 else}\par
04835             args.push_back(argv[i]);\par
04836     \}\par
04837 \par
04838     argc = int(args.size());\par
04839     {\cf19 if} (argc > 1 && {\cf22 "--help"} == args[1])\par
04840         __testlib_help();\par
04841 \par
04842     {\cf19 if} (argc < 4 || argc > 6) \{\par
04843         quit(_fail, std::string({\cf22 "Program must be run with the following arguments: "}) +\par
04844                     std::string({\cf22 "[--testset testset] [--group group] <input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"}) +\par
04845                     {\cf22 "\\nUse \\"--help\\" to get help information"});\par
04846     \}\par
04847 \par
04848     {\cf19 if} (argc == 4) \{\par
04849         resultName = {\cf22 ""};\par
04850         appesMode = {\cf17 false};\par
04851     \}\par
04852 \par
04853 {\cf21 #ifndef EJUDGE}\par
04854     {\cf19 if} (argc == 5) \{\par
04855         resultName = args[4];\par
04856         appesMode = {\cf17 false};\par
04857     \}\par
04858 \par
04859     {\cf19 if} (argc == 6) \{\par
04860         {\cf19 if} ({\cf22 "-APPES"} != args[5] && {\cf22 "-appes"} != args[5]) \{\par
04861             quit(_fail, std::string({\cf22 "Program must be run with the following arguments: "}) +\par
04862                         {\cf22 "<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"});\par
04863         \} {\cf19 else} \{\par
04864             resultName = args[4];\par
04865             appesMode = {\cf17 true};\par
04866         \}\par
04867     \}\par
04868 {\cf21 #endif}\par
04869 \par
04870     inf.init(args[1], _input);\par
04871     ouf.init(args[2], _output);\par
04872     ouf.skipBom();\par
04873     ans.init(args[3], _answer);\par
04874 \}\par
04875 \par
04876 {\cf18 void} registerTestlib({\cf18 int} argc, ...) \{\par
04877     {\cf19 if} (argc < 3 || argc > 5)\par
04878         quit(_fail, std::string({\cf22 "Program must be run with the following arguments: "}) +\par
04879                     {\cf22 "<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"});\par
04880 \par
04881     {\cf18 char} **argv = {\cf17 new} {\cf18 char} *[argc + 1];\par
04882 \par
04883     va_list ap;\par
04884     va_start(ap, argc);\par
04885     argv[0] = NULL;\par
04886     {\cf19 for} ({\cf18 int} i = 0; i < argc; i++) \{\par
04887         argv[i + 1] = va_arg(ap, {\cf18 char}*);\par
04888     \}\par
04889     va_end(ap);\par
04890 \par
04891     registerTestlibCmd(argc + 1, argv);\par
04892     {\cf17 delete}[] argv;\par
04893 \}\par
04894 \par
04895 {\cf17 static} {\cf17 inline} {\cf18 void} __testlib_ensure({\cf18 bool} cond, {\cf17 const} std::string &msg) \{\par
04896     {\cf19 if} (!cond)\par
04897         quit(_fail, msg.c_str());\par
04898 \}\par
04899 \par
04900 {\cf21 #ifdef __GNUC__}\par
04901 __attribute__((unused))\par
04902 {\cf21 #endif}\par
04903 {\cf17 static} {\cf17 inline} {\cf18 void} __testlib_ensure({\cf18 bool} cond, {\cf17 const} {\cf18 char} *msg) \{\par
04904     {\cf19 if} (!cond)\par
04905         quit(_fail, msg);\par
04906 \}\par
04907 \par
04908 {\cf21 #define ensure(cond) __testlib_ensure(cond, "Condition failed: \\"" #cond "\\"")}\par
04909 {\cf21 #define STRINGIZE_DETAIL(x) #x}\par
04910 {\cf21 #define STRINGIZE(x) STRINGIZE_DETAIL(x)}\par
04911 {\cf21 #define ensure_ext(cond) __testlib_ensure(cond, "Line " STRINGIZE(__LINE__) ": Condition failed: \\"" #cond "\\"")}\par
04912 \par
04913 {\cf21 #ifdef __GNUC__}\par
04914 __attribute__ ((format (printf, 2, 3)))\par
04915 {\cf21 #endif}\par
04916 {\cf17 inline} {\cf18 void} ensuref({\cf18 bool} cond, {\cf17 const} {\cf18 char} *format, ...) \{\par
04917     {\cf19 if} (!cond) \{\par
04918         FMT_TO_RESULT(format, format, message);\par
04919         __testlib_ensure(cond, message);\par
04920     \}\par
04921 \}\par
04922 \par
04923 NORETURN {\cf17 static} {\cf18 void} __testlib_fail({\cf17 const} std::string &message) \{\par
04924     quitf(_fail, {\cf22 "%s"}, message.c_str());\par
04925 \}\par
04926 \par
04927 {\cf21 #ifdef __GNUC__}\par
04928 __attribute__ ((format (printf, 1, 2)))\par
04929 {\cf21 #endif}\par
04930 {\cf18 void} setName({\cf17 const} {\cf18 char} *format, ...) \{\par
04931     FMT_TO_RESULT(format, format, name);\par
04932     checkerName = name;\par
04933 \}\par
04934 \par
04935 {\cf20 /*}\par
04936 {\cf20  * Do not use random_shuffle, because it will produce different result}\par
04937 {\cf20  * for different C++ compilers.}\par
04938 {\cf20  *}\par
04939 {\cf20  * This implementation uses testlib random_t to produce random numbers, so}\par
04940 {\cf20  * it is stable.}\par
04941 {\cf20  */}\par
04942 {\cf17 template}<{\cf17 typename} _RandomAccessIter>\par
04943 {\cf18 void} shuffle(_RandomAccessIter __first, _RandomAccessIter __last) \{\par
04944     {\cf19 if} (__first == __last) {\cf19 return};\par
04945     {\cf19 for} (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)\par
04946         std::iter_swap(__i, __first + rnd.next({\cf18 int}(__i - __first) + 1));\par
04947 \}\par
04948 \par
04949 \par
04950 {\cf17 template}<{\cf17 typename} _RandomAccessIter>\par
04951 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
04952 __attribute__ ((error({\cf22 "Don't use random_shuffle(), use shuffle() instead"})))\par
04953 {\cf21 #endif}\par
04954 {\cf18 void} random_shuffle(_RandomAccessIter, _RandomAccessIter) \{\par
04955     quitf(_fail, {\cf22 "Don't use random_shuffle(), use shuffle() instead"});\par
04956 \}\par
04957 \par
04958 {\cf21 #ifdef __GLIBC__}\par
04959 {\cf21 #  define RAND_THROW_STATEMENT throw()}\par
04960 {\cf21 #else}\par
04961 {\cf21 #  define RAND_THROW_STATEMENT}\par
04962 {\cf21 #endif}\par
04963 \par
04964 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
04965 \par
04966 __attribute__ ((error({\cf22 "Don't use rand(), use rnd.next() instead"})))\par
04967 {\cf21 #endif}\par
04968 {\cf21 #ifdef _MSC_VER}\par
04969 {\cf21 #   pragma warning( disable : 4273 )}\par
04970 {\cf21 #endif}\par
04971 {\cf18 int} rand() RAND_THROW_STATEMENT\par
04972 \{\par
04973     quitf(_fail, {\cf22 "Don't use rand(), use rnd.next() instead"});\par
04974 \par
04975     {\cf20 /* This line never runs. */}\par
04976     {\cf20 //throw "Don't use rand(), use rnd.next() instead";}\par
04977 \}\par
04978 \par
04979 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
04980 \par
04981 __attribute__ ((error({\cf22 "Don't use srand(), you should use "}\par
04982 {\cf22 "'registerGen(argc, argv, 1);' to initialize generator seed "}\par
04983 {\cf22 "by hash code of the command line params. The third parameter "}\par
04984 {\cf22 "is randomGeneratorVersion (currently the latest is 1)."})))\par
04985 {\cf21 #endif}\par
04986 {\cf21 #ifdef _MSC_VER}\par
04987 {\cf21 #   pragma warning( disable : 4273 )}\par
04988 {\cf21 #endif}\par
04989 {\cf18 void} srand({\cf18 unsigned} {\cf18 int} seed) RAND_THROW_STATEMENT\par
04990 \{\par
04991     quitf(_fail, {\cf22 "Don't use srand(), you should use "}\par
04992                  {\cf22 "'registerGen(argc, argv, 1);' to initialize generator seed "}\par
04993                  {\cf22 "by hash code of the command line params. The third parameter "}\par
04994                  {\cf22 "is randomGeneratorVersion (currently the latest is 1) [ignored seed=%u]."}, seed);\par
04995 \}\par
04996 \par
04997 {\cf18 void} startTest({\cf18 int} test) \{\par
04998     {\cf17 const} std::string testFileName = vtos(test);\par
04999     {\cf19 if} (NULL == freopen(testFileName.c_str(), {\cf22 "wt"}, stdout))\par
05000         __testlib_fail({\cf22 "Unable to write file '"} + testFileName + {\cf22 "'"});\par
05001 \}\par
05002 \par
05003 {\cf21 #ifdef __GNUC__}\par
05004 __attribute__(({\cf17 const}))\par
05005 {\cf21 #endif}\par
05006 {\cf17 inline} std::string compress({\cf17 const} std::string &s) \{\par
05007     {\cf19 return} __testlib_part(s);\par
05008 \}\par
05009 \par
05010 {\cf21 #ifdef __GNUC__}\par
05011 __attribute__(({\cf17 const}))\par
05012 {\cf21 #endif}\par
05013 {\cf17 inline} std::string englishEnding({\cf18 int} x) \{\par
05014     x %= 100;\par
05015     {\cf19 if} (x / 10 == 1)\par
05016         {\cf19 return} {\cf22 "th"};\par
05017     {\cf19 if} (x % 10 == 1)\par
05018         {\cf19 return} {\cf22 "st"};\par
05019     {\cf19 if} (x % 10 == 2)\par
05020         {\cf19 return} {\cf22 "nd"};\par
05021     {\cf19 if} (x % 10 == 3)\par
05022         {\cf19 return} {\cf22 "rd"};\par
05023     {\cf19 return} {\cf22 "th"};\par
05024 \}\par
05025 \par
05026 {\cf17 template}<{\cf17 typename} _ForwardIterator, {\cf17 typename} _Separator>\par
05027 {\cf21 #ifdef __GNUC__}\par
05028 __attribute__(({\cf17 const}))\par
05029 {\cf21 #endif}\par
05030 std::string join(_ForwardIterator first, _ForwardIterator last, _Separator separator) \{\par
05031     std::stringstream ss;\par
05032     {\cf18 bool} repeated = {\cf17 false};\par
05033     {\cf19 for} (_ForwardIterator i = first; i != last; i++) \{\par
05034         {\cf19 if} (repeated)\par
05035             ss << separator;\par
05036         {\cf19 else}\par
05037             repeated = {\cf17 true};\par
05038         ss << *i;\par
05039     \}\par
05040     {\cf19 return} ss.str();\par
05041 \}\par
05042 \par
05043 {\cf17 template}<{\cf17 typename} _ForwardIterator>\par
05044 {\cf21 #ifdef __GNUC__}\par
05045 __attribute__(({\cf17 const}))\par
05046 {\cf21 #endif}\par
05047 std::string join(_ForwardIterator first, _ForwardIterator last) \{\par
05048     {\cf19 return} join(first, last, {\cf23 ' '});\par
05049 \}\par
05050 \par
05051 {\cf17 template}<{\cf17 typename} _Collection, {\cf17 typename} _Separator>\par
05052 {\cf21 #ifdef __GNUC__}\par
05053 __attribute__(({\cf17 const}))\par
05054 {\cf21 #endif}\par
05055 std::string join({\cf17 const} _Collection &collection, _Separator separator) \{\par
05056     {\cf19 return} join(collection.begin(), collection.end(), separator);\par
05057 \}\par
05058 \par
05059 {\cf17 template}<{\cf17 typename} _Collection>\par
05060 {\cf21 #ifdef __GNUC__}\par
05061 __attribute__(({\cf17 const}))\par
05062 {\cf21 #endif}\par
05063 std::string join({\cf17 const} _Collection &collection) \{\par
05064     {\cf19 return} join(collection, {\cf23 ' '});\par
05065 \}\par
05066 \par
05071 {\cf21 #ifdef __GNUC__}\par
05072 __attribute__(({\cf17 const}))\par
05073 {\cf21 #endif}\par
05074 std::vector<std::string> split({\cf17 const} std::string &s, {\cf18 char} separator) \{\par
05075     std::vector<std::string> result;\par
05076     std::string item;\par
05077     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
05078         {\cf19 if} (s[i] == separator) \{\par
05079             result.push_back(item);\par
05080             item = {\cf22 ""};\par
05081         \} {\cf19 else}\par
05082             item += s[i];\par
05083     result.push_back(item);\par
05084     {\cf19 return} result;\par
05085 \}\par
05086 \par
05091 {\cf21 #ifdef __GNUC__}\par
05092 __attribute__(({\cf17 const}))\par
05093 {\cf21 #endif}\par
05094 std::vector<std::string> split({\cf17 const} std::string &s, {\cf17 const} std::string &separators) \{\par
05095     {\cf19 if} (separators.empty())\par
05096         {\cf19 return} std::vector<std::string>(1, s);\par
05097 \par
05098     std::vector<bool> isSeparator(256);\par
05099     {\cf19 for} ({\cf18 size_t} i = 0; i < separators.size(); i++)\par
05100         isSeparator[({\cf18 unsigned} {\cf18 char}) (separators[i])] = {\cf17 true};\par
05101 \par
05102     std::vector<std::string> result;\par
05103     std::string item;\par
05104     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
05105         {\cf19 if} (isSeparator[({\cf18 unsigned} {\cf18 char}) (s[i])]) \{\par
05106             result.push_back(item);\par
05107             item = {\cf22 ""};\par
05108         \} {\cf19 else}\par
05109             item += s[i];\par
05110     result.push_back(item);\par
05111     {\cf19 return} result;\par
05112 \}\par
05113 \par
05117 {\cf21 #ifdef __GNUC__}\par
05118 __attribute__(({\cf17 const}))\par
05119 {\cf21 #endif}\par
05120 std::vector<std::string> tokenize({\cf17 const} std::string &s, {\cf18 char} separator) \{\par
05121     std::vector<std::string> result;\par
05122     std::string item;\par
05123     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
05124         {\cf19 if} (s[i] == separator) \{\par
05125             {\cf19 if} (!item.empty())\par
05126                 result.push_back(item);\par
05127             item = {\cf22 ""};\par
05128         \} {\cf19 else}\par
05129             item += s[i];\par
05130     {\cf19 if} (!item.empty())\par
05131         result.push_back(item);\par
05132     {\cf19 return} result;\par
05133 \}\par
05134 \par
05138 {\cf21 #ifdef __GNUC__}\par
05139 __attribute__(({\cf17 const}))\par
05140 {\cf21 #endif}\par
05141 std::vector<std::string> tokenize({\cf17 const} std::string &s, {\cf17 const} std::string &separators) \{\par
05142     {\cf19 if} (separators.empty())\par
05143         {\cf19 return} std::vector<std::string>(1, s);\par
05144 \par
05145     std::vector<bool> isSeparator(256);\par
05146     {\cf19 for} ({\cf18 size_t} i = 0; i < separators.size(); i++)\par
05147         isSeparator[({\cf18 unsigned} {\cf18 char}) (separators[i])] = {\cf17 true};\par
05148 \par
05149     std::vector<std::string> result;\par
05150     std::string item;\par
05151     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
05152         {\cf19 if} (isSeparator[({\cf18 unsigned} {\cf18 char}) (s[i])]) \{\par
05153             {\cf19 if} (!item.empty())\par
05154                 result.push_back(item);\par
05155             item = {\cf22 ""};\par
05156         \} {\cf19 else}\par
05157             item += s[i];\par
05158 \par
05159     {\cf19 if} (!item.empty())\par
05160         result.push_back(item);\par
05161 \par
05162     {\cf19 return} result;\par
05163 \}\par
05164 \par
05165 NORETURN {\cf18 void} __testlib_expectedButFound(TResult result, std::string expected, std::string found, {\cf17 const} {\cf18 char} *prepend) \{\par
05166     std::string message;\par
05167     {\cf19 if} (strlen(prepend) != 0)\par
05168         message = format({\cf22 "%s: expected '%s', but found '%s'"},\par
05169                          compress(prepend).c_str(), compress(expected).c_str(), compress(found).c_str());\par
05170     {\cf19 else}\par
05171         message = format({\cf22 "expected '%s', but found '%s'"},\par
05172                          compress(expected).c_str(), compress(found).c_str());\par
05173     quit(result, message);\par
05174 \}\par
05175 \par
05176 NORETURN {\cf18 void} __testlib_expectedButFound(TResult result, {\cf18 double} expected, {\cf18 double} found, {\cf17 const} {\cf18 char} *prepend) \{\par
05177     std::string expectedString = removeDoubleTrailingZeroes(format({\cf22 "%.12f"}, expected));\par
05178     std::string foundString = removeDoubleTrailingZeroes(format({\cf22 "%.12f"}, found));\par
05179     __testlib_expectedButFound(result, expectedString, foundString, prepend);\par
05180 \}\par
05181 \par
05182 {\cf17 template}<{\cf17 typename} T>\par
05183 {\cf21 #ifdef __GNUC__}\par
05184 __attribute__ ((format (printf, 4, 5)))\par
05185 {\cf21 #endif}\par
05186 NORETURN {\cf18 void} expectedButFound(TResult result, T expected, T found, {\cf17 const} {\cf18 char} *prependFormat = {\cf22 ""}, ...) \{\par
05187     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05188     std::string expectedString = vtos(expected);\par
05189     std::string foundString = vtos(found);\par
05190     __testlib_expectedButFound(result, expectedString, foundString, prepend.c_str());\par
05191 \}\par
05192 \par
05193 {\cf17 template}<>\par
05194 {\cf21 #ifdef __GNUC__}\par
05195 __attribute__ ((format (printf, 4, 5)))\par
05196 {\cf21 #endif}\par
05197 NORETURN {\cf18 void}\par
05198 expectedButFound<std::string>(TResult result, std::string expected, std::string found, {\cf17 const} {\cf18 char} *prependFormat, ...) \{\par
05199     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05200     __testlib_expectedButFound(result, expected, found, prepend.c_str());\par
05201 \}\par
05202 \par
05203 {\cf17 template}<>\par
05204 {\cf21 #ifdef __GNUC__}\par
05205 __attribute__ ((format (printf, 4, 5)))\par
05206 {\cf21 #endif}\par
05207 NORETURN {\cf18 void} expectedButFound<double>(TResult result, {\cf18 double} expected, {\cf18 double} found, {\cf17 const} {\cf18 char} *prependFormat, ...) \{\par
05208     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05209     std::string expectedString = removeDoubleTrailingZeroes(format({\cf22 "%.12f"}, expected));\par
05210     std::string foundString = removeDoubleTrailingZeroes(format({\cf22 "%.12f"}, found));\par
05211     __testlib_expectedButFound(result, expectedString, foundString, prepend.c_str());\par
05212 \}\par
05213 \par
05214 {\cf17 template}<>\par
05215 {\cf21 #ifdef __GNUC__}\par
05216 __attribute__ ((format (printf, 4, 5)))\par
05217 {\cf21 #endif}\par
05218 NORETURN {\cf18 void}\par
05219 expectedButFound<const char *>(TResult result, {\cf17 const} {\cf18 char} *expected, {\cf17 const} {\cf18 char} *found, {\cf17 const} {\cf18 char} *prependFormat,\par
05220                                ...) \{\par
05221     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05222     __testlib_expectedButFound(result, std::string(expected), std::string(found), prepend.c_str());\par
05223 \}\par
05224 \par
05225 {\cf17 template}<>\par
05226 {\cf21 #ifdef __GNUC__}\par
05227 __attribute__ ((format (printf, 4, 5)))\par
05228 {\cf21 #endif}\par
05229 NORETURN {\cf18 void} expectedButFound<float>(TResult result, {\cf18 float} expected, {\cf18 float} found, {\cf17 const} {\cf18 char} *prependFormat, ...) \{\par
05230     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05231     __testlib_expectedButFound(result, {\cf18 double}(expected), {\cf18 double}(found), prepend.c_str());\par
05232 \}\par
05233 \par
05234 {\cf17 template}<>\par
05235 {\cf21 #ifdef __GNUC__}\par
05236 __attribute__ ((format (printf, 4, 5)))\par
05237 {\cf21 #endif}\par
05238 NORETURN {\cf18 void}\par
05239 expectedButFound<long double>(TResult result, {\cf18 long} {\cf18 double} expected, {\cf18 long} {\cf18 double} found, {\cf17 const} {\cf18 char} *prependFormat, ...) \{\par
05240     FMT_TO_RESULT(prependFormat, prependFormat, prepend);\par
05241     __testlib_expectedButFound(result, {\cf18 double}(expected), {\cf18 double}(found), prepend.c_str());\par
05242 \}\par
05243 \par
05244 {\cf21 #if __cplusplus > 199711L || defined(_MSC_VER)}\par
05245 {\cf17 template}<{\cf17 typename} T>\par
05246 {\cf17 struct }is_iterable \{\par
05247     {\cf17 template}<{\cf17 typename} U>\par
05248     {\cf17 static} {\cf18 char} test({\cf17 typename} U::iterator *x);\par
05249 \par
05250     {\cf17 template}<{\cf17 typename} U>\par
05251     {\cf17 static} {\cf18 long} test(U *x);\par
05252 \par
05253     {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 sizeof}(test<T>(0)) == 1;\par
05254 \};\par
05255 \par
05256 {\cf17 template}<{\cf18 bool} B, {\cf17 class} T = {\cf18 void}>\par
05257 {\cf17 struct }__testlib_enable_if \{\par
05258 \};\par
05259 \par
05260 {\cf17 template}<{\cf17 class} T>\par
05261 {\cf17 struct }__testlib_enable_if<true, T> \{\par
05262     {\cf17 typedef} T type;\par
05263 \};\par
05264 \par
05265 {\cf17 template}<{\cf17 typename} T>\par
05266 {\cf17 typename} __testlib_enable_if<!is_iterable<T>::value, {\cf18 void}>::type __testlib_print_one({\cf17 const} T &t) \{\par
05267     std::cout << t;\par
05268 \}\par
05269 \par
05270 {\cf17 template}<{\cf17 typename} T>\par
05271 {\cf17 typename} __testlib_enable_if<is_iterable<T>::value, {\cf18 void}>::type __testlib_print_one({\cf17 const} T &t) \{\par
05272     {\cf18 bool} first = {\cf17 true};\par
05273     {\cf19 for} ({\cf17 typename} T::const_iterator i = t.begin(); i != t.end(); i++) \{\par
05274         {\cf19 if} (first)\par
05275             first = {\cf17 false};\par
05276         {\cf19 else}\par
05277             std::cout << {\cf22 " "};\par
05278         std::cout << *i;\par
05279     \}\par
05280 \}\par
05281 \par
05282 {\cf17 template}<>\par
05283 {\cf17 typename} __testlib_enable_if<is_iterable<std::string>::value, {\cf18 void}>::type\par
05284 __testlib_print_one<std::string>({\cf17 const} std::string &t) \{\par
05285     std::cout << t;\par
05286 \}\par
05287 \par
05288 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B>\par
05289 {\cf18 void} __println_range(A begin, B end) \{\par
05290     {\cf18 bool} first = {\cf17 true};\par
05291     {\cf19 for} (B i = B(begin); i != end; i++) \{\par
05292         {\cf19 if} (first)\par
05293             first = {\cf17 false};\par
05294         {\cf19 else}\par
05295             std::cout << {\cf22 " "};\par
05296         __testlib_print_one(*i);\par
05297     \}\par
05298     std::cout << std::endl;\par
05299 \}\par
05300 \par
05301 {\cf17 template}<{\cf17 class} T, {\cf17 class} Enable = {\cf18 void}>\par
05302 {\cf17 struct }is_iterator \{\par
05303     {\cf17 static} T makeT();\par
05304 \par
05305     {\cf17 typedef} {\cf18 void} *twoptrs[2];\par
05306 \par
05307     {\cf17 static} twoptrs &test(...);\par
05308 \par
05309     {\cf17 template}<{\cf17 class} R>\par
05310     {\cf17 static} {\cf17 typename} R::iterator_category *test(R);\par
05311 \par
05312     {\cf17 template}<{\cf17 class} R>\par
05313     {\cf17 static} {\cf18 void} *test(R *);\par
05314 \par
05315     {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 sizeof}(test(makeT())) == {\cf17 sizeof}({\cf18 void} *);\par
05316 \};\par
05317 \par
05318 {\cf17 template}<{\cf17 class} T>\par
05319 {\cf17 struct }is_iterator<T, typename __testlib_enable_if<std::is_array<T>::value>::type> \{\par
05320     {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 false};\par
05321 \};\par
05322 \par
05323 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B>\par
05324 {\cf17 typename} __testlib_enable_if<!is_iterator<B>::value, {\cf18 void}>::type println({\cf17 const} A &a, {\cf17 const} B &b) \{\par
05325     __testlib_print_one(a);\par
05326     std::cout << {\cf22 " "};\par
05327     __testlib_print_one(b);\par
05328     std::cout << std::endl;\par
05329 \}\par
05330 \par
05331 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B>\par
05332 {\cf17 typename} __testlib_enable_if<is_iterator<B>::value, {\cf18 void}>::type println({\cf17 const} A &a, {\cf17 const} B &b) \{\par
05333     __println_range(a, b);\par
05334 \}\par
05335 \par
05336 {\cf17 template}<{\cf17 typename} A>\par
05337 {\cf18 void} println({\cf17 const} A *a, {\cf17 const} A *b) \{\par
05338     __println_range(a, b);\par
05339 \}\par
05340 \par
05341 {\cf17 template}<>\par
05342 {\cf18 void} println<char>({\cf17 const} {\cf18 char} *a, {\cf17 const} {\cf18 char} *b) \{\par
05343     __testlib_print_one(a);\par
05344     std::cout << {\cf22 " "};\par
05345     __testlib_print_one(b);\par
05346     std::cout << std::endl;\par
05347 \}\par
05348 \par
05349 {\cf17 template}<{\cf17 typename} T>\par
05350 {\cf18 void} println({\cf17 const} T &x) \{\par
05351     __testlib_print_one(x);\par
05352     std::cout << std::endl;\par
05353 \}\par
05354 \par
05355 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B, {\cf17 typename} C>\par
05356 {\cf18 void} println({\cf17 const} A &a, {\cf17 const} B &b, {\cf17 const} C &c) \{\par
05357     __testlib_print_one(a);\par
05358     std::cout << {\cf22 " "};\par
05359     __testlib_print_one(b);\par
05360     std::cout << {\cf22 " "};\par
05361     __testlib_print_one(c);\par
05362     std::cout << std::endl;\par
05363 \}\par
05364 \par
05365 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B, {\cf17 typename} C, {\cf17 typename} D>\par
05366 {\cf18 void} println({\cf17 const} A &a, {\cf17 const} B &b, {\cf17 const} C &c, {\cf17 const} D &d) \{\par
05367     __testlib_print_one(a);\par
05368     std::cout << {\cf22 " "};\par
05369     __testlib_print_one(b);\par
05370     std::cout << {\cf22 " "};\par
05371     __testlib_print_one(c);\par
05372     std::cout << {\cf22 " "};\par
05373     __testlib_print_one(d);\par
05374     std::cout << std::endl;\par
05375 \}\par
05376 \par
05377 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B, {\cf17 typename} C, {\cf17 typename} D, {\cf17 typename} E>\par
05378 {\cf18 void} println({\cf17 const} A &a, {\cf17 const} B &b, {\cf17 const} C &c, {\cf17 const} D &d, {\cf17 const} E &e) \{\par
05379     __testlib_print_one(a);\par
05380     std::cout << {\cf22 " "};\par
05381     __testlib_print_one(b);\par
05382     std::cout << {\cf22 " "};\par
05383     __testlib_print_one(c);\par
05384     std::cout << {\cf22 " "};\par
05385     __testlib_print_one(d);\par
05386     std::cout << {\cf22 " "};\par
05387     __testlib_print_one(e);\par
05388     std::cout << std::endl;\par
05389 \}\par
05390 \par
05391 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B, {\cf17 typename} C, {\cf17 typename} D, {\cf17 typename} E, {\cf17 typename} F>\par
05392 {\cf18 void} println({\cf17 const} A &a, {\cf17 const} B &b, {\cf17 const} C &c, {\cf17 const} D &d, {\cf17 const} E &e, {\cf17 const} F &f) \{\par
05393     __testlib_print_one(a);\par
05394     std::cout << {\cf22 " "};\par
05395     __testlib_print_one(b);\par
05396     std::cout << {\cf22 " "};\par
05397     __testlib_print_one(c);\par
05398     std::cout << {\cf22 " "};\par
05399     __testlib_print_one(d);\par
05400     std::cout << {\cf22 " "};\par
05401     __testlib_print_one(e);\par
05402     std::cout << {\cf22 " "};\par
05403     __testlib_print_one(f);\par
05404     std::cout << std::endl;\par
05405 \}\par
05406 \par
05407 {\cf17 template}<{\cf17 typename} A, {\cf17 typename} B, {\cf17 typename} C, {\cf17 typename} D, {\cf17 typename} E, {\cf17 typename} F, {\cf17 typename} G>\par
05408 {\cf18 void} println({\cf17 const} A &a, {\cf17 const} B &b, {\cf17 const} C &c, {\cf17 const} D &d, {\cf17 const} E &e, {\cf17 const} F &f, {\cf17 const} G &g) \{\par
05409     __testlib_print_one(a);\par
05410     std::cout << {\cf22 " "};\par
05411     __testlib_print_one(b);\par
05412     std::cout << {\cf22 " "};\par
05413     __testlib_print_one(c);\par
05414     std::cout << {\cf22 " "};\par
05415     __testlib_print_one(d);\par
05416     std::cout << {\cf22 " "};\par
05417     __testlib_print_one(e);\par
05418     std::cout << {\cf22 " "};\par
05419     __testlib_print_one(f);\par
05420     std::cout << {\cf22 " "};\par
05421     __testlib_print_one(g);\par
05422     std::cout << std::endl;\par
05423 \}\par
05424 \par
05425 {\cf20 /* opts */}\par
05426 \par
05431 {\cf17 struct }TestlibOpt \{\par
05432     std::string value;\par
05433     {\cf18 bool} used;\par
05434 \par
05435     TestlibOpt() : value(), used(false) \{\}\par
05436 \};\par
05437 \par
05451 {\cf18 size_t} getOptType({\cf18 char} *s) \{\par
05452     {\cf19 if} (!s || strlen(s) <= 1)\par
05453         {\cf19 return} 0;\par
05454 \par
05455     {\cf19 if} (s[0] == {\cf23 '-'}) \{\par
05456         {\cf19 if} (isalpha(s[1]))\par
05457             {\cf19 return} 1;\par
05458         {\cf19 else} {\cf19 if} (s[1] == {\cf23 '-'})\par
05459             {\cf19 return} isalpha(s[2]) ? 2 : 0;\par
05460     \}\par
05461 \par
05462     {\cf19 return} 0;\par
05463 \}\par
05464 \par
05494 {\cf18 size_t} parseOpt({\cf18 size_t} argc, {\cf18 char} *argv[], {\cf18 size_t} index, std::map<std::string, TestlibOpt> &opts) \{\par
05495     {\cf19 if} (index >= argc)\par
05496         {\cf19 return} 0;\par
05497 \par
05498     {\cf18 size_t} type = getOptType(argv[index]), inc = 1;\par
05499     {\cf19 if} (type > 0) \{\par
05500         std::string key(argv[index] + type), val;\par
05501         {\cf18 size_t} sep = key.find({\cf23 '='});\par
05502         {\cf19 if} (sep != std::string::npos) \{\par
05503             val = key.substr(sep + 1);\par
05504             key = key.substr(0, sep);\par
05505         \} {\cf19 else} \{\par
05506             {\cf19 if} (index + 1 < argc && getOptType(argv[index + 1]) == 0) \{\par
05507                 val = argv[index + 1];\par
05508                 inc = 2;\par
05509             \} {\cf19 else} \{\par
05510                 {\cf19 if} (key.length() > 1 && isdigit(key[1])) \{\par
05511                     val = key.substr(1);\par
05512                     key = key.substr(0, 1);\par
05513                 \} {\cf19 else} \{\par
05514                     val = {\cf22 "true"};\par
05515                 \}\par
05516             \}\par
05517         \}\par
05518         opts[key].value = val;\par
05519     \} {\cf19 else} \{\par
05520         {\cf19 return} inc;\par
05521     \}\par
05522 \par
05523     {\cf19 return} inc;\par
05524 \}\par
05525 \par
05529 std::vector<std::string> __testlib_argv;\par
05530 \par
05534 std::map<std::string, TestlibOpt> __testlib_opts;\par
05535 \par
05543 {\cf18 bool} __testlib_ensureNoUnusedOptsFlag = {\cf17 false};\par
05544 \par
05549 {\cf18 bool} __testlib_ensureNoUnusedOptsSuppressed = {\cf17 false};\par
05550 \par
05555 {\cf18 void} prepareOpts({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
05556     {\cf19 if} (argc <= 0)\par
05557         __testlib_fail({\cf22 "Opts: expected argc>=0 but found "} + toString(argc));\par
05558     {\cf18 size_t} n = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(argc); {\cf20 // NOLINT(hicpp-use-auto,modernize-use-auto)}\par
05559     __testlib_opts = std::map<std::string, TestlibOpt>();\par
05560     {\cf19 for} ({\cf18 size_t} index = 1; index < n; index += parseOpt(n, argv, index, __testlib_opts));\par
05561     __testlib_argv = std::vector<std::string>(n);\par
05562     {\cf19 for} ({\cf18 size_t} index = 0; index < n; index++)\par
05563         __testlib_argv[index] = argv[index];\par
05564 \}\par
05565 \par
05570 std::string __testlib_indexToArgv({\cf18 int} index) \{\par
05571     {\cf19 if} (index < 0 || index >= {\cf18 int}(__testlib_argv.size()))\par
05572         __testlib_fail({\cf22 "Opts: index '"} + toString(index) + {\cf22 "' is out of range [0,"}\par
05573             + toString(__testlib_argv.size()) + {\cf22 ")"});\par
05574     {\cf19 return} __testlib_argv[size_t(index)];\par
05575 \}\par
05576 \par
05581 std::string __testlib_keyToOpts({\cf17 const} std::string &key) \{\par
05582     {\cf17 auto} it = __testlib_opts.find(key);\par
05583     {\cf19 if} (it == __testlib_opts.end())\par
05584         __testlib_fail({\cf22 "Opts: unknown key '"} + compress(key) + {\cf22 "'"});\par
05585     it->second.used = {\cf17 true};\par
05586     {\cf19 return} it->second.value;\par
05587 \}\par
05588 \par
05589 {\cf17 template}<{\cf17 typename} T>\par
05590 T optValueToIntegral({\cf17 const} std::string &s, {\cf18 bool} nonnegative);\par
05591 \par
05592 {\cf18 long} {\cf18 double} optValueToLongDouble({\cf17 const} std::string &s);\par
05593 \par
05594 std::string parseExponentialOptValue({\cf17 const} std::string &s) \{\par
05595     {\cf18 size_t} pos = std::string::npos;\par
05596     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++)\par
05597         {\cf19 if} (s[i] == {\cf23 'e'} || s[i] == {\cf23 'E'}) \{\par
05598             {\cf19 if} (pos != std::string::npos)\par
05599                 __testlib_fail({\cf22 "Opts: expected typical exponential notation but '"} + compress(s) + {\cf22 "' found"});\par
05600             pos = i;\par
05601         \}\par
05602     {\cf19 if} (pos == std::string::npos)\par
05603         {\cf19 return} s;\par
05604     std::string e = s.substr(pos + 1);\par
05605     {\cf19 if} (!e.empty() && e[0] == {\cf23 '+'})\par
05606         e = e.substr(1);\par
05607     {\cf19 if} (e.empty())\par
05608         __testlib_fail({\cf22 "Opts: expected typical exponential notation but '"} + compress(s) + {\cf22 "' found"});\par
05609     {\cf19 if} (e.length() > 20)\par
05610         __testlib_fail({\cf22 "Opts: expected typical exponential notation but '"} + compress(s) + {\cf22 "' found"});\par
05611     {\cf18 int} ne = optValueToIntegral<int>(e, {\cf17 false});\par
05612     std::string num = s.substr(0, pos);\par
05613     {\cf19 if} (num.length() > 20)\par
05614         __testlib_fail({\cf22 "Opts: expected typical exponential notation but '"} + compress(s) + {\cf22 "' found"});\par
05615     {\cf19 if} (!num.empty() && num[0] == {\cf23 '+'})\par
05616         num = num.substr(1);\par
05617     optValueToLongDouble(num);\par
05618     {\cf18 bool} minus = {\cf17 false};\par
05619     {\cf19 if} (num[0] == {\cf23 '-'}) \{\par
05620         minus = {\cf17 true};\par
05621         num = num.substr(1);\par
05622     \}\par
05623     {\cf19 for} ({\cf18 int} i = 0; i < +ne; i++) \{\par
05624         {\cf18 size_t} sep = num.find({\cf23 '.'});\par
05625         {\cf19 if} (sep == std::string::npos)\par
05626             num += {\cf23 '0'};\par
05627         {\cf19 else} \{\par
05628             {\cf19 if} (sep + 1 == num.length())\par
05629                 num[sep] = {\cf23 '0'};\par
05630             {\cf19 else}\par
05631                 std::swap(num[sep], num[sep + 1]);\par
05632         \}\par
05633     \}\par
05634     {\cf19 for} ({\cf18 int} i = 0; i < -ne; i++) \{\par
05635         {\cf18 size_t} sep = num.find({\cf23 '.'});\par
05636         {\cf19 if} (sep == std::string::npos)\par
05637             num.insert(num.begin() + {\cf18 int}(num.length()) - 1, {\cf23 '.'});\par
05638         {\cf19 else} \{\par
05639             {\cf19 if} (sep == 0)\par
05640                 num.insert(num.begin() + 1, {\cf23 '0'});\par
05641             {\cf19 else}\par
05642                 std::swap(num[sep - 1], num[sep]);\par
05643         \}\par
05644     \}\par
05645     {\cf19 while} (!num.empty() && num[0] == {\cf23 '0'})\par
05646         num = num.substr(1);\par
05647     {\cf19 while} (num.find({\cf23 '.'}) != std::string::npos && num.back() == {\cf23 '0'})\par
05648         num = num.substr(0, num.length() - 1);\par
05649     {\cf19 if} (!num.empty() && num.back() == {\cf23 '.'})\par
05650         num = num.substr(0, num.length() - 1);\par
05651     {\cf19 if} ((!num.empty() && num[0] == {\cf23 '.'}) || num.empty())\par
05652         num.insert(num.begin(), {\cf23 '0'});\par
05653     {\cf19 return} (minus ? {\cf22 "-"} : {\cf22 ""}) + num;\par
05654 \}\par
05655 \par
05656 {\cf17 template}<{\cf17 typename} T>\par
05657 T optValueToIntegral({\cf17 const} std::string &s_, {\cf18 bool} nonnegative) \{\par
05658     std::string s(parseExponentialOptValue(s_));\par
05659     {\cf19 if} (s.empty())\par
05660         __testlib_fail({\cf22 "Opts: expected integer but '"} + compress(s_) + {\cf22 "' found"});\par
05661     T value = 0;\par
05662     {\cf18 long} {\cf18 double} about = 0.0;\par
05663     {\cf18 signed} {\cf18 char} sign = +1;\par
05664     {\cf18 size_t} pos = 0;\par
05665     {\cf19 if} (s[pos] == {\cf23 '-'}) \{\par
05666         {\cf19 if} (nonnegative)\par
05667             __testlib_fail({\cf22 "Opts: expected non-negative integer but '"} + compress(s_) + {\cf22 "' found"});\par
05668         sign = -1;\par
05669         pos++;\par
05670     \}\par
05671     {\cf19 for} ({\cf18 size_t} i = pos; i < s.length(); i++) \{\par
05672         {\cf19 if} (s[i] < {\cf23 '0'} || s[i] > {\cf23 '9'})\par
05673             __testlib_fail({\cf22 "Opts: expected integer but '"} + compress(s_) + {\cf22 "' found"});\par
05674         value = T(value * 10 + s[i] - {\cf23 '0'});\par
05675         about = about * 10 + s[i] - {\cf23 '0'};\par
05676     \}\par
05677     value *= sign;\par
05678     about *= sign;\par
05679     {\cf19 if} (fabsl(value - about) > 0.1)\par
05680         __testlib_fail({\cf22 "Opts: integer overflow: expected integer but '"} + compress(s_) + {\cf22 "' found"});\par
05681     {\cf19 return} value;\par
05682 \}\par
05683 \par
05684 {\cf18 long} {\cf18 double} optValueToLongDouble({\cf17 const} std::string &s_) \{\par
05685     std::string s(parseExponentialOptValue(s_));\par
05686     {\cf19 if} (s.empty())\par
05687         __testlib_fail({\cf22 "Opts: expected float number but '"} + compress(s_) + {\cf22 "' found"});\par
05688     {\cf18 long} {\cf18 double} value = 0.0;\par
05689     {\cf18 signed} {\cf18 char} sign = +1;\par
05690     {\cf18 size_t} pos = 0;\par
05691     {\cf19 if} (s[pos] == {\cf23 '-'}) \{\par
05692         sign = -1;\par
05693         pos++;\par
05694     \}\par
05695     {\cf18 bool} period = {\cf17 false};\par
05696     {\cf18 long} {\cf18 double} mul = 1.0;\par
05697     {\cf19 for} ({\cf18 size_t} i = pos; i < s.length(); i++) \{\par
05698         {\cf19 if} (s[i] == {\cf23 '.'}) \{\par
05699             {\cf19 if} (period)\par
05700                 __testlib_fail({\cf22 "Opts: expected float number but '"} + compress(s_) + {\cf22 "' found"});\par
05701             {\cf19 else} \{\par
05702                 period = {\cf17 true};\par
05703                 {\cf19 continue};\par
05704             \}\par
05705         \}\par
05706         {\cf19 if} (period)\par
05707             mul *= 10.0;\par
05708         {\cf19 if} (s[i] < {\cf23 '0'} || s[i] > {\cf23 '9'})\par
05709             __testlib_fail({\cf22 "Opts: expected float number but '"} + compress(s_) + {\cf22 "' found"});\par
05710         {\cf19 if} (period)\par
05711             value += (s[i] - {\cf23 '0'}) / mul;\par
05712         {\cf19 else}\par
05713             value = value * 10 + s[i] - {\cf23 '0'};\par
05714     \}\par
05715     value *= sign;\par
05716     {\cf19 return} value;\par
05717 \}\par
05718 \par
05726 {\cf18 bool} has_opt({\cf17 const} std::string &key) \{\par
05727     __testlib_ensureNoUnusedOptsFlag = {\cf17 true};\par
05728     {\cf19 return} __testlib_opts.count(key) != 0;\par
05729 \}\par
05730 \par
05731 {\cf20 /* About the following part for opt with 2 and 3 arguments.}\par
05732 {\cf20  * }\par
05733 {\cf20  * To parse the argv/opts correctly for a give type (integer, floating point or}\par
05734 {\cf20  * string), some meta programming must be done to determine the type of}\par
05735 {\cf20  * the type, and use the correct parsing function accordingly.}\par
05736 {\cf20  * }\par
05737 {\cf20  * The pseudo algorithm for determining the type of T and parse it accordingly}\par
05738 {\cf20  * is as follows:}\par
05739 {\cf20  * }\par
05740 {\cf20  * if (T is integral type) \{}\par
05741 {\cf20  *   if (T is unsigned) \{}\par
05742 {\cf20  *     parse the argv/opt as an **unsigned integer** of type T.}\par
05743 {\cf20  *   \} else \{}\par
05744 {\cf20  *     parse the argv/opt as an **signed integer** of type T.}\par
05745 {\cf20  * \} else \{}\par
05746 {\cf20  *   if (T is floating point type) \{}\par
05747 {\cf20  *     parse the argv/opt as an **floating point** of type T.}\par
05748 {\cf20  *   \} else \{}\par
05749 {\cf20  *     // T should be std::string}\par
05750 {\cf20  *     just the raw content of the argv/opts.}\par
05751 {\cf20  *   \}}\par
05752 {\cf20  * \}}\par
05753 {\cf20  * }\par
05754 {\cf20  * To help with meta programming, some `opt` function with 2 or 3 arguments are}\par
05755 {\cf20  * defined.}\par
05756 {\cf20  * }\par
05757 {\cf20  * Opt with 3 arguments:    T opt(true/false is_integral, true/false is_unsigned, index/key)}\par
05758 {\cf20  * }\par
05759 {\cf20  *   + The first argument is for determining whether the type T is an integral}\par
05760 {\cf20  *   type. That is, the result of std::is_integral<T>() should be passed to}\par
05761 {\cf20  *   this argument. When false, the type _should_ be either floating point or a}\par
05762 {\cf20  *   std::string.}\par
05763 {\cf20  *   }\par
05764 {\cf20  *   + The second argument is for determining whether the signedness of the type}\par
05765 {\cf20  *   T (if it is unsigned or signed). That is, the result of}\par
05766 {\cf20  *   std::is_unsigned<T>() should be passed to this argument. This argument can}\par
05767 {\cf20  *   be ignored if the first one is false, because it only applies to integer.}\par
05768 {\cf20  *}\par
05769 {\cf20  * Opt with 2 arguments:    T opt(true/false is_floating_point, index/key)}\par
05770 {\cf20  *   + The first argument is for determining whether the type T is a floating}\par
05771 {\cf20  *   point type. That is, the result of std::is_floating_point<T>() should be}\par
05772 {\cf20  *   passed to this argument. When false, the type _should_ be a std::string.}\par
05773 {\cf20  */}\par
05774 \par
05775 {\cf17 template}<{\cf17 typename} T>\par
05776 T opt(std::false_type is_floating_point, {\cf18 int} index);\par
05777 \par
05778 {\cf17 template}<>\par
05779 std::string opt(std::false_type {\cf20 /*is_floating_point*/}, {\cf18 int} index) \{\par
05780     {\cf19 return} __testlib_indexToArgv(index);\par
05781 \}\par
05782 \par
05783 {\cf17 template}<{\cf17 typename} T>\par
05784 T opt(std::true_type {\cf20 /*is_floating_point*/}, {\cf18 int} index) \{\par
05785     {\cf19 return} T(optValueToLongDouble(__testlib_indexToArgv(index)));\par
05786 \}\par
05787 \par
05788 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U>\par
05789 T opt(std::false_type {\cf20 /*is_integral*/}, U {\cf20 /*is_unsigned*/}, {\cf18 int} index) \{\par
05790     {\cf19 return} opt<T>(std::is_floating_point<T>(), index);\par
05791 \}\par
05792 \par
05793 {\cf17 template}<{\cf17 typename} T>\par
05794 T opt(std::true_type {\cf20 /*is_integral*/}, std::false_type {\cf20 /*is_unsigned*/}, {\cf18 int} index) \{\par
05795     {\cf19 return} optValueToIntegral<T>(__testlib_indexToArgv(index), {\cf17 false});\par
05796 \}\par
05797 \par
05798 {\cf17 template}<{\cf17 typename} T>\par
05799 T opt(std::true_type {\cf20 /*is_integral*/}, std::true_type {\cf20 /*is_unsigned*/}, {\cf18 int} index) \{\par
05800     {\cf19 return} optValueToIntegral<T>(__testlib_indexToArgv(index), {\cf17 true});\par
05801 \}\par
05802 \par
05803 {\cf17 template}<>\par
05804 {\cf18 bool} opt(std::true_type {\cf20 /*is_integral*/}, std::true_type {\cf20 /*is_unsigned*/}, {\cf18 int} index) \{\par
05805     std::string value = __testlib_indexToArgv(index);\par
05806     {\cf19 if} (value == {\cf22 "true"} || value == {\cf22 "1"})\par
05807         {\cf19 return} {\cf17 true};\par
05808     {\cf19 if} (value == {\cf22 "false"} || value == {\cf22 "0"})\par
05809         {\cf19 return} {\cf17 false};\par
05810     __testlib_fail({\cf22 "Opts: opt by index '"} + toString(index) + {\cf22 "': expected bool true/false or 0/1 but '"}\par
05811             + compress(value) + {\cf22 "' found"});\par
05812 \}\par
05813 \par
05817 {\cf17 template}<{\cf17 typename} T>\par
05818 T opt({\cf18 int} index) \{\par
05819     {\cf19 return} opt<T>(std::is_integral<T>(), std::is_unsigned<T>(), index);\par
05820 \}\par
05821 \par
05825 std::string opt({\cf18 int} index) \{\par
05826     {\cf19 return} opt<std::string>(index);\par
05827 \}\par
05828 \par
05833 {\cf17 template}<{\cf17 typename} T>\par
05834 T opt({\cf18 int} index, {\cf17 const} T &default_value) \{\par
05835     {\cf19 if} (index >= {\cf18 int}(__testlib_argv.size())) \{\par
05836         {\cf19 return} default_value;\par
05837     \}\par
05838     {\cf19 return} opt<T>(index);\par
05839 \}\par
05840 \par
05845 std::string opt({\cf18 int} index, {\cf17 const} std::string &default_value) \{\par
05846     {\cf19 return} opt<std::string>(index, default_value);\par
05847 \}\par
05848 \par
05849 {\cf17 template}<{\cf17 typename} T>\par
05850 T opt(std::false_type is_floating_point, {\cf17 const} std::string &key);\par
05851 \par
05852 {\cf17 template}<>\par
05853 std::string opt(std::false_type {\cf20 /*is_floating_point*/}, {\cf17 const} std::string &key) \{\par
05854     {\cf19 return} __testlib_keyToOpts(key);\par
05855 \}\par
05856 \par
05857 {\cf17 template}<{\cf17 typename} T>\par
05858 T opt(std::true_type {\cf20 /*is_integral*/}, {\cf17 const} std::string &key) \{\par
05859     {\cf19 return} T(optValueToLongDouble(__testlib_keyToOpts(key)));\par
05860 \}\par
05861 \par
05862 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U>\par
05863 T opt(std::false_type {\cf20 /*is_integral*/}, U, {\cf17 const} std::string &key) \{\par
05864     {\cf19 return} opt<T>(std::is_floating_point<T>(), key);\par
05865 \}\par
05866 \par
05867 {\cf17 template}<{\cf17 typename} T>\par
05868 T opt(std::true_type {\cf20 /*is_integral*/}, std::false_type {\cf20 /*is_unsigned*/}, {\cf17 const} std::string &key) \{\par
05869     {\cf19 return} optValueToIntegral<T>(__testlib_keyToOpts(key), {\cf17 false});\par
05870 \}\par
05871 \par
05872 {\cf17 template}<{\cf17 typename} T>\par
05873 T opt(std::true_type {\cf20 /*is_integral*/}, std::true_type {\cf20 /*is_unsigned*/}, {\cf17 const} std::string &key) \{\par
05874     {\cf19 return} optValueToIntegral<T>(__testlib_keyToOpts(key), {\cf17 true});\par
05875 \}\par
05876 \par
05877 {\cf17 template}<>\par
05878 {\cf18 bool} opt(std::true_type {\cf20 /*is_integral*/}, std::true_type {\cf20 /*is_unsigned*/}, {\cf17 const} std::string &key) \{\par
05879     {\cf19 if} (!has_opt(key))\par
05880         {\cf19 return} {\cf17 false};\par
05881     std::string value = __testlib_keyToOpts(key);\par
05882     {\cf19 if} (value == {\cf22 "true"} || value == {\cf22 "1"})\par
05883         {\cf19 return} {\cf17 true};\par
05884     {\cf19 if} (value == {\cf22 "false"} || value == {\cf22 "0"})\par
05885         {\cf19 return} {\cf17 false};\par
05886     __testlib_fail({\cf22 "Opts: key '"} + compress(key) + {\cf22 "': expected bool true/false or 0/1 but '"}\par
05887         + compress(value) + {\cf22 "' found"});\par
05888 \}\par
05889 \par
05893 {\cf17 template}<{\cf17 typename} T>\par
05894 T opt({\cf17 const} std::string &key) \{\par
05895     {\cf19 return} opt<T>(std::is_integral<T>(), std::is_unsigned<T>(), key);\par
05896 \}\par
05897 \par
05901 std::string opt({\cf17 const} std::string &key) \{\par
05902     {\cf19 return} opt<std::string>(key);\par
05903 \}\par
05904 \par
05905 {\cf20 /* Scorer started. */}\par
05906 \par
05907 {\cf17 enum} TestResultVerdict \{\par
05908     SKIPPED,\par
05909     OK,\par
05910     WRONG_ANSWER,\par
05911     RUNTIME_ERROR,\par
05912     TIME_LIMIT_EXCEEDED,\par
05913     IDLENESS_LIMIT_EXCEEDED,\par
05914     MEMORY_LIMIT_EXCEEDED,\par
05915     COMPILATION_ERROR,\par
05916     CRASHED,\par
05917     FAILED\par
05918 \};\par
05919 \par
05920 std::string serializeVerdict(TestResultVerdict verdict) \{\par
05921     {\cf19 switch} (verdict) \{\par
05922         {\cf19 case} SKIPPED: {\cf19 return} {\cf22 "SKIPPED"};\par
05923         {\cf19 case} OK: {\cf19 return} {\cf22 "OK"};\par
05924         {\cf19 case} WRONG_ANSWER: {\cf19 return} {\cf22 "WRONG_ANSWER"};\par
05925         {\cf19 case} RUNTIME_ERROR: {\cf19 return} {\cf22 "RUNTIME_ERROR"};\par
05926         {\cf19 case} TIME_LIMIT_EXCEEDED: {\cf19 return} {\cf22 "TIME_LIMIT_EXCEEDED"};\par
05927         {\cf19 case} IDLENESS_LIMIT_EXCEEDED: {\cf19 return} {\cf22 "IDLENESS_LIMIT_EXCEEDED"};\par
05928         {\cf19 case} MEMORY_LIMIT_EXCEEDED: {\cf19 return} {\cf22 "MEMORY_LIMIT_EXCEEDED"};\par
05929         {\cf19 case} COMPILATION_ERROR: {\cf19 return} {\cf22 "COMPILATION_ERROR"};\par
05930         {\cf19 case} CRASHED: {\cf19 return} {\cf22 "CRASHED"};\par
05931         {\cf19 case} FAILED: {\cf19 return} {\cf22 "FAILED"};\par
05932     \}\par
05933     {\cf19 throw} {\cf22 "Unexpected verdict"};\par
05934 \}\par
05935 \par
05936 TestResultVerdict deserializeTestResultVerdict(std::string s) \{\par
05937     {\cf19 if} (s == {\cf22 "SKIPPED"})\par
05938         {\cf19 return} SKIPPED;\par
05939     {\cf19 else} {\cf19 if} (s == {\cf22 "OK"})\par
05940         {\cf19 return} OK;\par
05941     {\cf19 else} {\cf19 if} (s == {\cf22 "WRONG_ANSWER"})\par
05942         {\cf19 return} WRONG_ANSWER;\par
05943     {\cf19 else} {\cf19 if} (s == {\cf22 "RUNTIME_ERROR"})\par
05944         {\cf19 return} RUNTIME_ERROR;\par
05945     {\cf19 else} {\cf19 if} (s == {\cf22 "TIME_LIMIT_EXCEEDED"})\par
05946         {\cf19 return} TIME_LIMIT_EXCEEDED;\par
05947     {\cf19 else} {\cf19 if} (s == {\cf22 "IDLENESS_LIMIT_EXCEEDED"})\par
05948         {\cf19 return} IDLENESS_LIMIT_EXCEEDED;\par
05949     {\cf19 else} {\cf19 if} (s == {\cf22 "MEMORY_LIMIT_EXCEEDED"})\par
05950         {\cf19 return} MEMORY_LIMIT_EXCEEDED;\par
05951     {\cf19 else} {\cf19 if} (s == {\cf22 "COMPILATION_ERROR"})\par
05952         {\cf19 return} COMPILATION_ERROR;\par
05953     {\cf19 else} {\cf19 if} (s == {\cf22 "CRASHED"})\par
05954         {\cf19 return} CRASHED;\par
05955     {\cf19 else} {\cf19 if} (s == {\cf22 "FAILED"})\par
05956         {\cf19 return} FAILED;\par
05957     ensuref({\cf17 false}, {\cf22 "Unexpected serialized TestResultVerdict"});\par
05958     {\cf20 // No return actually.}\par
05959     {\cf19 return} FAILED;\par
05960 \}\par
05961 \par
05962 {\cf17 struct }TestResult \{\par
05963     {\cf18 int} testIndex;\par
05964     std::string testset;\par
05965     std::string group;\par
05966     TestResultVerdict verdict;\par
05967     {\cf18 double} points;\par
05968     {\cf18 long} {\cf18 long} timeConsumed;\par
05969     {\cf18 long} {\cf18 long} memoryConsumed;\par
05970     std::string input;\par
05971     std::string output;\par
05972     std::string answer;\par
05973     {\cf18 int} exitCode;\par
05974     std::string checkerComment;\par
05975 \};\par
05976 \par
05977 std::string serializePoints({\cf18 double} points) \{\par
05978     {\cf19 if} (std::isnan(points))\par
05979         {\cf19 return} {\cf22 ""};\par
05980     {\cf19 else} \{\par
05981         {\cf18 char} c[64];\par
05982         snprintf(c, 64, {\cf22 "%.03lf"}, points);\par
05983         {\cf19 return} c;\par
05984     \}\par
05985 \}\par
05986 \par
05987 {\cf18 double} deserializePoints(std::string s) \{\par
05988     {\cf19 if} (s.empty())\par
05989         {\cf19 return} std::numeric_limits<double>::quiet_NaN();\par
05990     {\cf19 else} \{\par
05991         {\cf18 double} result;\par
05992         ensuref(sscanf(s.c_str(), {\cf22 "%lf"}, &result) == 1, {\cf22 "Invalid serialized points"});\par
05993         {\cf19 return} result;\par
05994     \}                                              \par
05995 \}\par
05996 \par
05997 std::string escapeTestResultString(std::string s) \{\par
05998     std::string result;\par
05999     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++) \{\par
06000         {\cf19 if} (s[i] == {\cf23 '\\r'})\par
06001             {\cf19 continue};\par
06002         {\cf19 if} (s[i] == {\cf23 '\\n'}) \{\par
06003             result += {\cf22 "\\\\n"};\par
06004             {\cf19 continue};\par
06005         \}\par
06006         {\cf19 if} (s[i] == {\cf23 '\\\\'} || s[i] == {\cf23 ';'})\par
06007             result += {\cf23 '\\\\'};\par
06008         result += s[i];\par
06009     \}\par
06010     {\cf19 return} result;\par
06011 \}\par
06012 \par
06013 std::string unescapeTestResultString(std::string s) \{\par
06014     std::string result;\par
06015     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++) \{\par
06016         {\cf19 if} (s[i] == {\cf23 '\\\\'} && i + 1 < s.length()) \{\par
06017             {\cf19 if} (s[i + 1] == {\cf23 'n'}) \{\par
06018                 result += {\cf23 '\\n'};\par
06019                 i++;\par
06020                 {\cf19 continue};\par
06021             \} {\cf19 else} {\cf19 if} (s[i + 1] == {\cf23 ';'} || s[i + 1] == {\cf23 '\\\\'}) \{\par
06022                 result += s[i + 1];\par
06023                 i++;\par
06024                 {\cf19 continue};\par
06025             \}\par
06026         \}\par
06027         result += s[i];\par
06028     \}\par
06029     {\cf19 return} result;\par
06030 \}\par
06031 \par
06032 std::string serializeTestResult(TestResult tr) \{\par
06033     std::string result;\par
06034     result += std::to_string(tr.testIndex);\par
06035     result += {\cf22 ";"};\par
06036     result += escapeTestResultString(tr.testset);\par
06037     result += {\cf22 ";"};\par
06038     result += escapeTestResultString(tr.group);\par
06039     result += {\cf22 ";"};\par
06040     result += serializeVerdict(tr.verdict);\par
06041     result += {\cf22 ";"};\par
06042     result += serializePoints(tr.points);\par
06043     result += {\cf22 ";"};\par
06044     result += std::to_string(tr.timeConsumed);\par
06045     result += {\cf22 ";"};\par
06046     result += std::to_string(tr.memoryConsumed);\par
06047     result += {\cf22 ";"};\par
06048     result += escapeTestResultString(tr.input);\par
06049     result += {\cf22 ";"};\par
06050     result += escapeTestResultString(tr.output);\par
06051     result += {\cf22 ";"};\par
06052     result += escapeTestResultString(tr.answer);\par
06053     result += {\cf22 ";"};\par
06054     result += std::to_string(tr.exitCode);\par
06055     result += {\cf22 ";"};\par
06056     result += escapeTestResultString(tr.checkerComment);\par
06057     {\cf19 return} result;\par
06058 \}\par
06059 \par
06060 TestResult deserializeTestResult(std::string s) \{\par
06061     std::vector<std::string> items;\par
06062     std::string t;\par
06063     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length(); i++) \{\par
06064         {\cf19 if} (s[i] == {\cf23 '\\\\'}) \{\par
06065             t += s[i];\par
06066             {\cf19 if} (i + 1 < s.length())\par
06067                 t += s[i + 1];\par
06068             i++;\par
06069             {\cf19 continue};\par
06070         \} {\cf19 else} \{\par
06071             {\cf19 if} (s[i] == {\cf23 ';'}) \{\par
06072                 items.push_back(t);\par
06073                 t = {\cf22 ""};\par
06074             \} {\cf19 else}\par
06075                 t += s[i];\par
06076         \}\par
06077     \}\par
06078     items.push_back(t);\par
06079 \par
06080     ensuref(items.size() == 12, {\cf22 "Invalid TestResult serialization: expected exactly 12 items"});\par
06081     \par
06082     TestResult tr;\par
06083     {\cf18 size_t} pos = 0;\par
06084     tr.testIndex = stoi(items[pos++]);\par
06085     tr.testset = unescapeTestResultString(items[pos++]);\par
06086     tr.group = unescapeTestResultString(items[pos++]);\par
06087     tr.verdict = deserializeTestResultVerdict(items[pos++]);\par
06088     tr.points = deserializePoints(items[pos++]);\par
06089     tr.timeConsumed = stoll(items[pos++]);\par
06090     tr.memoryConsumed = stoll(items[pos++]);\par
06091     tr.input = unescapeTestResultString(items[pos++]);\par
06092     tr.output = unescapeTestResultString(items[pos++]);\par
06093     tr.answer = unescapeTestResultString(items[pos++]);\par
06094     tr.exitCode = stoi(items[pos++]);\par
06095     tr.checkerComment = unescapeTestResultString(items[pos++]);\par
06096     \par
06097     {\cf19 return} tr;\par
06098 \}\par
06099 \par
06100 std::vector<TestResult> readTestResults(std::string fileName) \{\par
06101     std::ifstream stream;\par
06102     stream.open(fileName.c_str(), std::ios::in);\par
06103     ensuref(stream.is_open(), {\cf22 "Can't read test results file '%s'"}, fileName.c_str());\par
06104     std::vector<TestResult> result;\par
06105     std::string line;\par
06106     {\cf19 while} (getline(stream, line))\par
06107         {\cf19 if} (!line.empty())\par
06108             result.push_back(deserializeTestResult(line));\par
06109     stream.close();\par
06110     {\cf19 return} result;\par
06111 \}\par
06112 \par
06113 std::function<double(std::vector<TestResult>)> __testlib_scorer;\par
06114 \par
06115 {\cf17 struct }TestlibScorerGuard \{\par
06116     ~TestlibScorerGuard() \{\par
06117         {\cf19 if} (testlibMode == _scorer) \{\par
06118             std::vector<TestResult> testResults;\par
06119             {\cf19 while} (!inf.eof()) \{\par
06120                 std::string line = inf.readLine();\par
06121                 {\cf19 if} (!line.empty())\par
06122                     testResults.push_back(deserializeTestResult(line));\par
06123             \}\par
06124             inf.readEof();\par
06125             printf({\cf22 "%.3f\\n"}, __testlib_scorer(testResults));\par
06126         \}\par
06127     \}\par
06128 \} __testlib_scorer_guard;\par
06129 \par
06130 {\cf18 void} registerScorer({\cf18 int} argc, {\cf18 char} *argv[], std::function<{\cf18 double}(std::vector<TestResult>)> scorer) \{\par
06131     {\cf20 /* Suppress unused. */}\par
06132     (void)(argc), (void)(argv);\par
06133 \par
06134     __testlib_ensuresPreconditions();\par
06135 \par
06136     testlibMode = _scorer;\par
06137     __testlib_set_binary(stdin);\par
06138 \par
06139     inf.init(stdin, _input);\par
06140     inf.strict = {\cf17 false};\par
06141 \par
06142     __testlib_scorer = scorer;\par
06143 \}\par
06144 \par
06145 {\cf20 /* Scorer ended. */}\par
06146 \par
06155 {\cf17 template}<{\cf17 typename} T>\par
06156 T opt({\cf17 const} std::string &key, {\cf17 const} T &default_value) \{\par
06157     {\cf19 if} (!has_opt(key)) \{\par
06158         {\cf19 return} default_value;\par
06159     \}\par
06160     {\cf19 return} opt<T>(key);\par
06161 \}\par
06162 \par
06171 std::string opt({\cf17 const} std::string &key, {\cf17 const} std::string &default_value) \{\par
06172     {\cf19 return} opt<std::string>(key, default_value);\par
06173 \}\par
06174 \par
06182 {\cf18 void} ensureNoUnusedOpts() \{\par
06183     {\cf19 for} ({\cf17 const} {\cf17 auto} &opt: __testlib_opts) \{\par
06184         {\cf19 if} (!opt.second.used) \{\par
06185             __testlib_fail(format({\cf22 "Opts: unused key '%s'"}, compress(opt.first).c_str()));\par
06186         \}\par
06187     \}\par
06188 \}\par
06189 \par
06190 {\cf18 void} suppressEnsureNoUnusedOpts() \{\par
06191     __testlib_ensureNoUnusedOptsSuppressed = {\cf17 true};\par
06192 \}\par
06193 \par
06194 {\cf18 void} TestlibFinalizeGuard::autoEnsureNoUnusedOpts() \{\par
06195     {\cf19 if} (__testlib_ensureNoUnusedOptsFlag && !__testlib_ensureNoUnusedOptsSuppressed) \{\par
06196         ensureNoUnusedOpts();\par
06197     \}\par
06198 \}\par
06199 \par
06200 TestlibFinalizeGuard testlibFinalizeGuard;\par
06201 \par
06202 {\cf21 #endif}\par
06203 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/validator.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/validator.cpp}
{\xe \v src/validator.cpp}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "testlib.h"}\par
{\f2 #include <bits/stdc++.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b prime} (int x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:validator.cpp}
{\xe \v validator.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b validator.cpp}.}\par
}
{\xe \v prime\:validator.cpp}
{\xe \v validator.cpp\:prime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool prime (int  {\i x})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b validator.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
validator.cpp\par \pard\plain 
{\tc\tcl2 \v src/validator.cpp}
{\xe \v src/validator.cpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "testlib.h"}\par
00002 {\cf21 #include <bits/stdc++.h>}\par
00003 \par
00004 {\cf17 using namespace }std;\par
00005 {\cf18 bool} prime({\cf18 int} x) \{\par
00006     {\cf19 if} (x == 1)\par
00007         {\cf19 return} {\cf17 false};\par
00008     {\cf19 for} ({\cf18 int} i = 2; i * i <= x; i++) \{\par
00009         {\cf19 if} (x % i == 0)\par
00010             {\cf19 return} {\cf17 false};\par
00011     \}\par
00012     {\cf19 return} {\cf17 true};\par
00013 \}\par
00014 {\cf18 int} main({\cf18 int} argc, {\cf18 char} **argv) \{\par
00015     registerValidation(argc, argv);\par
00016     {\cf18 int} n = inf.readInt(1, 1000, {\cf22 "N"});\par
00017     inf.readEoln();\par
00018     {\cf18 bool} has_prime = {\cf17 false};\par
00019     {\cf19 for} ({\cf18 int} i = 1; i <= n; i++) \{\par
00020         {\cf18 int} x = inf.readInt(1, 1000, {\cf22 "X"});\par
00021         has_prime |= prime(x);\par
00022         {\cf19 if} (i != n)\par
00023             inf.readSpace();\par
00024     \}\par
00025     inf.readEoln();\par
00026     ensuref(has_prime, {\cf22 "There is no prime number!"});\par
00027     inf.readEof();\par
00028     {\cf19 return} 0;\par
00029 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
